\newcommand{\UTxOEpState}{\type{UTxOEpState}}
\newcommand{\Accnt}{\type{Accnt}}
\newcommand{\AccntEnv}{\type{AccntEnv}}
\newcommand{\AccntState}{\type{AccntState}}
\newcommand{\StPlCleanEnv}{\type{StPlCleanEnv}}
\newcommand{\StPlCleanState}{\type{StPlCleanState}}
\newcommand{\NewProtoConstsEnv}{\type{NewProtoConstsEnv}}
\newcommand{\NewProtoConstsState}{\type{NewProtoConstsState}}
\newcommand{\EpochEnv}{\type{EpochEnv}}
\newcommand{\EpochState}{\type{EpochState}}
\newcommand{\Production}{\type{Production}}

\newcommand{\obligation}[4]{\fun{obligation}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\reward}[5]{\fun{reward}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}~ \var{#5}}
\newcommand{\poolRefunds}[3]{\fun{poolRefunds}~ \var{#1}~ \var{#2}~ \var{#3}}

In this chapter we discuss the ledger state updates that take place at the epoch
boundary. These are necessary updates that are not triggered by a transaction.
It is impractical and unnecessary to perform the calculations and updates we
describe below every slot. The main state updates that take place at the boundary
are of an accounting nature, calculating new values for the various accounts
on the ledger (treasury, reserves, rewards, fees). However, it is also when
pools scheduled for retirement at this boundary are removed from the ledger.
In addition, if there is an update planned for any of the protocol constants,
it may only take place at the epoch boundary, and results in a ledger state
update, which we also give the details of in this chapter.

We introduce a new abstract type in this chapter, $\Production$ (see
Figure~\ref{fig:epoch-defs}), which represents the set of blocks produced by the
blockchain this epoch. We also present the abstract function $\fun{makeUTxO}$,
which builds UTxO entries out of pending withdrawal, coin values in rewards accounts,
and existing UTxO entries.

\begin{todo}
  Give details of $utxo$ generation by the $\fun{makeUTxO}$ map

  All we need here is withdrawals and existing UTxO?
\end{todo}

%%
%% Figure - Epoch Abstract Types
%%
\begin{figure}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}ll}
      \var{production} & \Production & \text{blocks produced in the epoch}\\
    \end{array}
  \end{equation*}
  \emph{Abstract Functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}ll}
      \fun{makeUTxO} & \UTxO \to \Wdrl \to (\AddrRWD \mapsto Coin)\to \UTxO &
        \\ \text{generate UTxO entries for withdrawals}\\
    \end{array}
  \end{equation*}
  \caption{Epoch definitions}
  \label{fig:epoch-defs}
\end{figure}

In Figure~\ref{fig:functions:epoch}, we give the functions
used in the deposit calculations at the boundary. Here we introduce the function
that gives the value of the total possible (decayed) refunds for both individual and
pool deposits in a given slot number, $\fun{obligation}$.

Next, we give the type of the function used to calculate additional rewards that will become
available to be claimed after the boundary. This function is denoted $\fun{reward}$,
and depends on this epoch's blocks, protocol constants and rewards made available
for claiming this epoch. Based on these values, the $\fun{reward}$ function
updates the existing records of the unclaimed coin values in each reward address.

\begin{todo}
  The delegation design document defines the $\fun{reward}$ function, but the calculation
  depends on the leader election for the epoch being determined and known at the begining
  of the epoch. We are currently rearching version of Ouroboros where this assumption
  does not hold. Therefore we have marked $\fun{reward}$ as ``to be determined".

  Additionally, we should aim to do calculations such as these as incrementally as possible.
\end{todo}

The function $\fun{poolRefunds}$ is used to calculate the total refunds
that must be distributed
for stake pools scheduled to retire at an epoch boundary. Note that this
calculation takes a slot number as a parameter because that is the type of value
needed for the decay calculation, but will only ever be invoked
when the slot number is the last before the boundary.

The map $\fun{poolRefunds}$ uses the pool decay constants in $\PrtclConsts$
to assign a refund to each pool key in the set of pools scheduled for retirement
at the epoch boundary.

%%
%% Figure - Functions for Epoch Rules
%%
\begin{figure}[htb]
  \begin{align*}
      & \fun{obligation} \in \PrtclConsts \to \Allocs \to \Allocs \to \Slot \to \Coin
      & \text{total possible refunds} \\
      & \obligation{pc}{stkeys}{stpools}{cslot} =\\
      & \sum\limits_{(\_ \mapsto s) \in \var{stkeys}}
        \refund{d_{\mathsf{val}}}{d_{\min}}{(\slotminus{cslot}{s})}{\lambda_d} \\
      & + \sum\limits_{(\_ \mapsto s) \in \var{stpools}}
        \refund{p_{\mathsf{val}}}{p_{\min}}{(\slotminus{cslot}{s})}{\lambda_p} \\
      &
      %  \where k_{\mathsf{val}}, k_{\min},p_{\mathsf{val}}, p_{\min}, \lambda \in pc
      \begin{array}{lr@{~=~}l}
        \where
          & (\dval,~d_{\min},~\lambda_d) & \fun{decayKey}~\var{pc}\\
          & (p_{\mathsf{val}},~p_{\min},~\lambda_p) & \fun{decayPool}~\var{pc}\\
      \end{array}\\
      \nextdef
      & \fun{reward} \in \Production \to \PrtclConsts \to \Coin \to DWState \to \\
      & ~~~ (\AddrRWD \mapsto \Coin) \to (\AddrRWD \mapsto \Coin)
      & \text{update rewards} \\
      & \reward{prod}{pc}{availablePool}{dwstate}{rewards} = \mathsf{TBD}\\
      \nextdef
      & \fun{poolRefunds} \in \PrtclConsts \to \Allocs \to \Slot \to (\HashKey \mapsto \Coin)
      & \text{pool refunds} \\
      & \poolRefunds{pc}{retiring}{cslot} = \\
      & \bigcup_{\var{hk}\mapsto s\in\var{retiring}}
          \var{hk}\mapsto( \refund{p_{\mathsf{val}}}{p_{\min}}{(\slotminus{cslot}{s})}{\lambda} ) \\
      &
        \where (p_{\mathsf{val}},~p_{\min},~\lambda_p) = \fun{decayPool}~\var{pc}\\
  \end{align*}
  \caption{Functions used in Deposits}
  \label{fig:functions:epoch}
\end{figure}

The type of the UTxO state transition at the epoch boundary is given in
Figure~\ref{fig:ts-types:utxoe}. There is no signal for this transition, but rather
it is the result of a change in the environment, i.e. the slot number changing
from the last slot of an epoch to the first slot of the subsequent epoch.

%%
%% Figure - UTxO Epoch Defs
%%
\begin{figure}[htb]
  \emph{UTxOE transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{utxoep}{} \var{\_}
    \subseteq \powerset (\UTxOEnv \times \UTxOState \times \UTxOState)
  \end{equation*}
  %
  \caption{UTxO Epoch transition-system types}
  \label{fig:ts-types:utxoe}
\end{figure}

The inference rule describing when the boundary UTxO state transition can
take place is presented in~\ref{fig:rules:utxoep}. As a result of the application
of this rule, the UTxO is updated by
generating UTxO entries from pending withdrawals and adding them to the
set of existing UTxO entries. The $\var{deposits}$ value is decreased by the
amount of decay of refunds this epoch (calculated by the $\fun{obligation}$
function). The $\var{fees}$ value on the ledger is set to 0, and the set of
withdrawals is emptied.

\begin{todo}
Discuss index generation

discuss prevention of double withdrawal
\end{todo}
%%
%% Figure - UTxO Epoch Rule
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:utxoep}
    \inference[UTxO-epoch]
    {
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pc}\\
        \var{stkeys}\\
        \var{stpools}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{utxo} \\
          \var{deposits} \\
          \var{fees} \\
          \var{wdrls} \\
        \end{array}
      \right)
      \trans{utxoep}{}
      \left(
        \begin{array}{r}
          \var{utxo} \cup \fun{makeUTxO}~\var{wdrls} \\
          \obligation{pc}{stkeys}{stpools}{slot} \\
          0 \\
          \emptyset \\
        \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO Epoch inference rules}
  \label{fig:rules:utxoep}
\end{figure}

The Figure~\ref{fig:ts-types:accnt} gives the definitions related to epoch
boundary ledger accounting. The figure lists the accounting fields, denoted by
$\Accnt$, which include $\var{treasury}$ (the amount of coin currently in
circulation, but not on the UTxO and not designated for rewards),
$\var{reserves}$ (the amount of coin
not yet in circulation),
and $\var{rewardPool}$ (the total amount available for distribution of rewards).
The figure also gives the set of necessary accounting environment
variables, $\AccntEnv$, and the accounting state, $\AccntState$, which includes
the delegation state and the accounting fields. The accounting state transition
type, as all transition types in this chapter, has no signal.

%%
%% Figure - Accounting Defs
%%
\begin{figure}[htb]
  \emph{Accounting Fields}
  \begin{equation*}
    \Accnt =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{treasury} & \Coin & \text{treasury pool}\\
        \var{reserves} & \Coin & \text{reserve pool}\\
        \var{rewardPool} & \Coin & \text{reward pool}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Accounting environment}
  \begin{equation*}
    \AccntEnv =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pc} & \PrtclConsts & \text{protocol constants}\\
        \var{production} & \Production & \text{blocks produced in the epoch}\\
        \var{utxoSt} & \UTxOState & \text{utxo state}\\
        \var{pstate} & \PState & \text{pool state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Accounting States}
  \begin{equation*}
    \AccntState =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{accnt} & \Accnt & \text{accounting}\\
        \var{dstate} & \DState & \text{delegation state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Accounting transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{accnt}{} \var{\_}
    \subseteq \powerset (\AccntEnv \times \AccntState \times \AccntState)
  \end{equation*}
  %
  \caption{Accounting transition-system types}
  \label{fig:ts-types:accnt}
\end{figure}

The accounting epoch boundary rule in Figure~\ref{fig:rules:accnt} is the rule
where the most attention to detail is required in order to adhere to the
preservation of value condition. In this rule, the funds in each of the
accounting variables, as well as the individual reward addresses, are adjusted
as follows:

\begin{itemize}
\item The $\var{treasury}$ has a fraction $\tau$ of the sum of
the fees accumulated from transactions this epoch, the decay amount
of all current deposits, the total reward pool, and the expansion (how much
coin is added to circulation each epoch) added to it
\item A fraction $\rho$ of the $\var{reserves}$ comes into circulation (i.e.
is removed from $\var{reserves}$)
\item The value added to $\var{treasury}$ is removed from the $\var{rewardPool}$
\item The the sum total of rewards accumulated for all addresses this epoch
is removed from the $\var{rewardPool}$
\item The accumulated fees, deposit decay, and circulation expansion is
added to the $\var{rewardPool}$
\item The rewards accumulated this epoch are distributed by
adding the amount computed for each reward address (by the $\fun{rewardPool}$ calculation)
to the value of coin corresponding to that address
\end{itemize}

Note that fees and deposit decay, above, are not explicitly removed from any account:
the fees come from transactions paying them, and are accounted for whenever
transactions are processed, and the deposit decay value comes from returning
smaller refunds for deposits than were paid upon depositing.

%%
%% Figure - Accounting Rules
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:accnt}
    \inference[Accounting]
    {
      {
      \begin{array}{r@{=}l}
        \var{obl} & \obligation{pc}{stkeys}{stpools}{slot} \\
        \var{decayed} & \var{deposits} - \var{obl} \\
        %\rho, \tau \in pc \\
        \var{expansion} & \floor*{\rho \cdot \var{reserves}} \\
        \var{totalPool} & \var{fees} + \var{decayed} + \var{rewardPool} + \var{expansion} \\
        \var{newTreasury} & \floor*{\tau \cdot \var{totalPool}} \\
        \var{availablePool} & \var{totalPool} - \var{newTreasury} \\
        \var{rewards'} & \reward{production}{pc}{availablePool}{dwstate}{rewards}\\
        \var{paidRewards} & \sum\limits_{\_\mapsto c\in\var{rewards'}}c
      \end{array}
      }
    }
    {
      \begin{array}{l}
        \var{production}\\
        \var{slot}\\
        \var{pc}\\
        \var{utxoSt}\\
        \var{pstate}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{treasury} \\
          \var{reserves} \\
          \var{rewardPool} \\
          \var{stkeys} \\
          \var{rewards} \\
          \var{delegations}
        \end{array}
      \right)
      \trans{accnt}{}
      \left(
        \begin{array}{rcl}
          \var{treasury} & + & \var{newTreasury}\\
          \var{reserves} & - & \var{expansion} \\
          \var{availablePool} & - & \var{paidRewards} \\
          \var{stkeys} \\
          \var{rewards} & \unionoverridePlus & \var{rewards'} \\
          \var{delegations}
        \end{array}
      \right)
    }
  \end{equation}
  \caption{Accounting Epoch inference rules}
  \label{fig:rules:accnt}
\end{figure}

Next, we discuss the epoch boundary pool retirement in
Figure~\ref{fig:ts-types:pool-clean}. The environment needed for the
cleanup of stake pools scheduled for retirement this epoch boundary includes
the protocol constants and the current slot number, and the state is made up of
the current UTxO, delegation and pool states. We also give the type of this
state transition, with no signal.

%%
%% Figure - Pool Clean Defs
%%
\begin{figure}[htb]
  \emph{Stake Pool Clean environment}
  \begin{equation*}
    \StPlCleanEnv =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pc} & \PrtclConsts & \text{protocol constants}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Stake Pool Clean States}
  \begin{equation*}
    \StPlCleanState =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{utxoSt} & \UTxOState & \text{utxo state}\\
        \var{dstate} & \DState & \text{delegation state}\\
        \var{pstate} & \PState & \text{pool state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Pool Clean Transition}
  \begin{equation*}
    \_ \vdash \_ \trans{poolclean}{} \_ \in
    \powerset (\StPlCleanEnv \times \StPlCleanState \times \StPlCleanState)
  \end{equation*}
  %
  \caption{Pool Clean Transition}
  \label{fig:ts-types:pool-clean}
\end{figure}

We now present the pool-cleanup transition rule in Figure~\ref{fig:rules:pool-clean}.
This rule will be applied whenever there is one or more stake pools scheduled
to retire this epoch. If so, all of the entries in $\var{stpools}$,
$\var{pparams}$, and $\var{retiring}$ which correspond to any of the hash keys
of the stake pools scheduled to retire this epoch are removed from
these variables.

In addition, the $\var{deposits}$ value on the ledger is
updated by subtracting from the existing $\var{deposits}$ value the total
value of all (decayed) refunds for the stake pools scheduled for retirement
this epoch. The refunds for stake pool retirement end up in the rewards
accounts of the pool key holders. Specifically, the set of rewards is updated by
adding to coin value corresponding to each key entry in the $\var{rewards}$
finite map the amount of (decayed) refund intended for the pool
key which deregisters the pool.

\begin{todo}
  So, refunds become rewards?

  What happens if the indivudual key is deregistered?
\end{todo}

%%
%% Figure - Pool Clean Rule
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:pool-clean}
    \inference[Pool-Clean]
    {
      \var{retired} = \var{retiring}^{-1}~\var{(\epoch{slot})}
      & \var{retired} \neq \emptyset \\
      ~ \\
      {
        \begin{array}{r@{=}l}
          \var{refunds} & \poolRefunds{pc}{(\var{retired} \restrictdom \var{stpools})}{slot} \\
          \var{deposits'} & \var{deposits} -
            \left(\sum\limits_{\{\_\mapsto c\}\in\var{refunds}} c\right) \\
          \var{rewards'} & \var{rewards} \unionoverridePlus \var{refunds} \\
        \end{array}
      } \\ ~ \\ ~ \\
      \var{utxoSt'} =
      \left(
        {
          \begin{array}{r}
            \var{utxo} \\
            \var{deposits'} \\
            \var{fees} \\
            \var{wdrls} \\
          \end{array}
        }
      \right)
      &
      \var{dstate'} =
      \left(
        {
          \begin{array}{r}
            \var{stkeys} \\
            \var{rewards'} \\
            \var{delegations}
          \end{array}
        }
      \right)
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pc}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{utxoSt} \\
          \var{dstate} \\
          \var{stpools} \\
          \var{pparams} \\
          \var{retiring}
        \end{array}
      \right)
      \trans{poolclean}{}
      \left(
        \begin{array}{rcl}
          \var{utxoSt'} \\
          \var{dstate'} \\
          \var{retired} & \subtractdom & \var{stpools} \\
          \var{retired} & \subtractdom & \var{pparams} \\
          \var{retired} & \subtractdom & \var{retiring} \\
        \end{array}
      \right)
    }
  \end{equation}
  \caption{Pool Clean Inference Rule}
  \label{fig:rules:pool-clean}
\end{figure}

Finally, reaching the epoch boundary may trigger a change in the protocol
constants. Besides the current slot number, delegation and pool states, the
protocol constant environment includes the old and new protocol constants.
The state change is a change of the $\UTxOState$ and the $\Accnt$ states.
The type of this state transition is given in Figure~\ref{fig:ts-types:new-proto-consts}.

%%
%% Figure - New Proto Consts Defs
%%
\begin{figure}[htb]
  \emph{New Proto Consts environment}
  \begin{equation*}
    \NewProtoConstsEnv =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pcOld} & \PrtclConsts & \text{old protocol constants}\\
        \var{pcNew} & \PrtclConsts & \text{new protocol constants}\\
        \var{dstate} & \DState & \text{delegation state}\\
        \var{pstate} & \PState & \text{pool state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{New Proto Consts States}
  \begin{equation*}
    \NewProtoConstsState =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{utxoSt} & \UTxOState & \text{utxo state}\\
        \var{accnt} & \Accnt & \text{accounting}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{New Proto Consts transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{newpc}{} \var{\_}
    \subseteq \powerset (\NewProtoConstsEnv \times
    \NewProtoConstsState \times \NewProtoConstsState)
  \end{equation*}
  %
  \caption{New Proto Consts transition-system types}
  \label{fig:ts-types:new-proto-consts}
\end{figure}

The inference rule for changing protocol constants either:

\begin{itemize}
\item if there are more total possible refunds
available calculated based on the old protocol constants than the new ones,
moves the difference between the two values into the $\var{reserves}$
from the $\var{deposits}$ variable, \textit{or}

\item if there are more refunds available based on the new constants, it moves
the difference between the two calculations from $\var{deposits}$
to $\var{reserves}$, \textit{provided that} there is enough coin in the
$\var{reserves}$ to cover the entire value of the transfer
\end{itemize}


%%
%% Figure - New Proto Consts Rule
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:new-pc}
    \inference[New-Proto-Consts]
    {
      \var{oblgOld} = \obligation{pcOld}{stkeys}{stpools}{slot} \\
      \var{oblgNew} = \obligation{pcNew}{stkeys}{stpools}{slot} \\
      ~\\
      \var{reserves} + \var{oblgOld} \geq \var{oblgNew}\\
      \var{diff} = \var{oblgOld} - \var{oblgNew} \\
      ~\\
      \var{utxoSt'} =
      \left(
        {
          \begin{array}{r}
            \var{utxo} \\
            \var{oblgNew} \\
            \var{fees} \\
            \var{wdrls} \\
          \end{array}
        }
      \right)
      &
      \var{accnt'} =
      \left(
        {
          \begin{array}{r}
            \var{treasury} \\
            \var{reserves} + \var{diff} \\
            \var{rewardPool} \\
            \var{rewards} \\
          \end{array}
        }
      \right)
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pc}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{utxoSt} \\
          \var{accnt}
        \end{array}
      \right)
      \trans{newpc}{}
      \left(
        \begin{array}{rcl}
          \var{utxoSt'}\\
          \var{accnt'} \\
        \end{array}
      \right)
    }
  \end{equation}
  \caption{New Proto Consts Inference Rule}
  \label{fig:rules:new-proto-consts}
\end{figure}

Finally, it is possible to define the complete epoch boundary transition type. It
In the environment of this transition, we have the slot number, blocks produced
this epoch, and both the old and the new protocol constants. The state is
made up of the accounting state, the UTxO, the delegation state and the
pool state.

%%
%% Figure - Epoch Defs
%%
\begin{figure}[htb]
  \emph{Epoch environment}
  \begin{equation*}
    \EpochEnv =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pcOld} & \PrtclConsts & \text{old protocol constants}\\
        \var{pcNew} & \PrtclConsts & \text{new protocol constants}\\
        \var{production} & \Production & \text{blocks produced in the epoch}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Epoch States}
  \begin{equation*}
    \EpochState =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{utxoSt} & \UTxOState & \text{utxo state}\\
        \var{accnt} & \Accnt & \text{accounting}\\
        \var{dstate} & \DState & \text{delegation state}\\
        \var{pstate} & \PState & \text{pool state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Epoch transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{epoch}{} \var{\_}
    \subseteq \powerset (\EpochEnv \times \EpochState \times \EpochState)
  \end{equation*}
  %
  \caption{Epoch transition-system types}
  \label{fig:ts-types:epoch}
\end{figure}

The epoch transition rule is a compilation of all the state transition rules
we have defined above. That is, whenever the UTXOEP, ACCNT, POOLCLEAN, and
NEWPC are all valid transitions between their respective pairs of sets of
state variables, the total transition between the pair of sets of state variables
which include all the variables in these four transitions is a valid transition
forthe complete ledger state at the epoch boundary.

Recall that the epoch boundary is \textit{a point in time}. When the clock signals
a change of slot $x$ to slot $x+1$, also resulting in an epoch change,
this transition occurs. The calculations in this transition are done
\textit{after} this change, so that all the processing in the previous slot
number is complete, and no new transactions will begin to be processed that
arrived after the epoch change until the boundary update is complete.
A stable ledger state is required for this transition to have the correct
outcome.

Note that the slot numbers used as \textit{current slot numbers}
for the epoch boundary calculations where they are required are set to
be the \textit{last slot of the epoch before the boundary}, i.e. $x$ in the
example above.

%%
%% Figure - Epoch Rule
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:epoch}
    \inference[Epoch]
    {
      {
        \begin{array}{l}
          \var{slot}\\
          \var{pcOld}\\
          \var{dstate}\\
          \var{pstate}\\
        \end{array}
      }
      \vdash \var{utxoSt} \trans{utxoep}{} \var{utxoSt'}
      \\~\\~\\
      {
        \begin{array}{l}
          \var{production}\\
          \var{slot}\\
          \var{pcOld}\\
          \var{utxoSt'}\\
          \var{pstate}\\
        \end{array}
      }
      \vdash
      \left(
        {
          \begin{array}{r}
            \var{accnt} \\
            \var{dstate} \\
          \end{array}
        }
      \right)
      \trans{accnt}{}
      \left(
      {
        \begin{array}{rcl}
          \var{accnt'} \\
          \var{dstate'} \\
        \end{array}
      }
      \right)
      \\~\\~\\
      {
        \begin{array}{l}
          \var{slot}\\
          \var{pcOld}\\
        \end{array}
      }
      \vdash
      \left(
        {
          \begin{array}{r}
            \var{utxoSt'} \\
            \var{dstate'} \\
            \var{pstate} \\
          \end{array}
        }
      \right)
      \trans{poolclean}{}
      \left(
      {
        \begin{array}{rcl}
            \var{utxoSt''} \\
            \var{dstate''} \\
            \var{pstate'} \\
        \end{array}
      }
      \right)
      \\~\\~\\
      {
        \begin{array}{l}
          \var{slot}\\
          \var{pcOld}\\
          \var{pcNew}\\
          \var{dstate''}\\
          \var{pstate'}\\
        \end{array}
      }
      \vdash
      \left(
        {
          \begin{array}{r}
            \var{utxoSt''} \\
            \var{accnt'} \\
          \end{array}
        }
      \right)
      \trans{newpc}{}
      \left(
      {
        \begin{array}{rcl}
            \var{utxoSt'''} \\
            \var{accnt''} \\
        \end{array}
      }
      \right)
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pcOld}\\
        \var{pcNew}\\
        \var{production}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxoSt} \\
        \var{accnt} \\
        \var{dstate} \\
        \var{pstate}
      \end{array}
      \right)
      \trans{epoch}{}
      \left(
      \begin{array}{rcl}
        \var{utxoSt'''} \\
        \var{accnt''} \\
        \var{dstate''} \\
        \var{pstate'}
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Epoch Inference Rule}
  \label{fig:rules:epoch}
\end{figure}
