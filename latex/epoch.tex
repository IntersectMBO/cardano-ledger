\newcommand{\UTxOEpState}{\type{UTxOEpState}}
\newcommand{\Acnt}{\type{Acnt}}
\newcommand{\AcntEnv}{\type{AcntEnv}}
\newcommand{\AcntState}{\type{AcntState}}
\newcommand{\PlReapState}{\type{PlReapState}}
\newcommand{\NewPParamEnv}{\type{NewPParamEnv}}
\newcommand{\NewPParamState}{\type{NewPParamState}}
\newcommand{\EpochEnv}{\type{EpochEnv}}
\newcommand{\EpochState}{\type{EpochState}}
\newcommand{\BlocksMade}{\type{BlocksMade}}
\newcommand{\Stake}{\type{Stake}}
\newcommand{\Avgs}{\type{Avgs}}

\newcommand{\obligation}[4]{\fun{obligation}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\reward}[5]{\fun{reward}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}~ \var{#5}}
\newcommand{\rewardOnePool}[9]{\fun{rewardOnePool}~\var{#1}~\var{#2}~\var{#3}~\var{#4}~\var{#5}~\var{#6}~\var{#7}~\var{#8}~\var{#9}}
\newcommand{\isActive}[4]{\fun{isActive}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\activeStake}[5]{\fun{activeStake}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}~ \var{#5}}
\newcommand{\poolRefunds}[3]{\fun{poolRefunds}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\poolStake}[4]{\fun{poolStake}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\poolDistr}[3]{\fun{poolDistr}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\lReward}[4]{\fun{r_{leader}}~ \var{#1}~ \var{#2}~ \var{#3}~ {#4}}
\newcommand{\mReward}[4]{\fun{r_{member}}~ \var{#1}~ \var{#2}~ \var{#3}~ {#4}}
\newcommand{\poolReward}[6]{\fun{poolReward}~\var{#1}~\var{#2}~\var{#3}~\var{#4}~\var{#5}~\var{#6}}
\newcommand{\movingAvg}[5]{\fun{movingAvg}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}~ \var{#5}}
\newcommand{\updateAvgs}[4]{\fun{updateAvgs}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}

In this chapter we discuss updates to the ledger state that take place at the epoch boundary.
These are necessary updates that are not triggered by a transaction.
Rewards for the proof of stake leader election are calculated, and various accounting values
are updated, such as the treasury and the reserves.  Additionally, pools scheduled for retirement
are actually retired, and protocol updates can occur.

Figure~\ref{fig:epoch-defs} introduces three new derived types:
\begin{itemize}
  \item $\type{BlocksMade}$ represents the number of blocks each stake pool produced
    during an epoch.
  \item $\type{Stake}$ represents the amount of stake (in $\type{Coin}$) controlled by each
    stake pool.
  \item $\type{Stake}$ represents the performance moving averages of the stake pools.
\end{itemize}

%%
%% Figure - Epoch Abstract Types
%%
\begin{figure}[htb]
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{prod}
      & \BlocksMade
      & \HashKey \mapsto \N
      & \text{blocks made by a pool} \\
      \var{stake}
      & \Stake
      & \HashKey \mapsto \Coin
      & \text{stake} \\
      \var{avgs}
      & \Avgs
      & \HashKey \mapsto \Rnn
      & \text{performance moving averages} \\
    \end{array}
  \end{equation*}
  \caption{Epoch definitions}
  \label{fig:epoch-defs}
\end{figure}

\subsection{Stake Distribution Calculation}
\label{sec:stake-dist}

This section defines the stake distribution calculations performed at the epoch boundary.
Figure~\ref{fig:functions:helper-stake-distribution} defines some helper functions.
\begin{itemize}
  \item $\fun{consolidate}$ transforms UTxO into a mapping from addresses to the total amount
    of $\type{Coin}$ controlled by each address in the UTxO.
  \item $\fun{baseStake}$ transforms the consolidated stake, as computed above by
    $\fun{consolidated}$, into a mapping from the base address stake hashkeys to the coin value.
  \item $\fun{ptrStake}$ transforms the consolidated stake, as computed above by
    $\fun{consolidated}$, into a mapping from the pointer address stake hashkeys to the coin value.
    It uses the certificate pointers to create this mapping.
  \item $\fun{rewardStake}$ transforms the reward accounts into a mapping from hashkeys to coin
    values.
  \item $\fun{poolStake}$ filters all stake in the system into just the stake controlled by a given
    stake pool.  Additionally, it combines all of the stake controlled by the pool owners into
    a single key-value pair mapping the pool operator's hashkey to the owner-operator total.
\end{itemize}

%%
%% Figure - Helper Functions for Stake Distribution
%%
\begin{figure}[htb]
  \emph{Stake Distribution helper functions}
  %
  \begin{align*}
      & \fun{consolidate} \in \UTxO \to (\Addr \mapsto \Coin) \\
      & \fun{consolidate}~{utxo} =
        \left\{a \mapsto \left(\sum_{\wcard\mapsto(a,c)\in\var{utxo}}c\right)
        ~\Big\vert~
        \wcard\mapsto(a,~\wcard)\in\var{utxo} \right\} \\
      \nextdef
      & \fun{baseStake} \in (\Addr\mapsto\Coin) \to \Stake \\
      & \fun{baseStake}~{vals} =
          \{\fun{stakeHK_b}~{addr}\mapsto c \mid a\mapsto c\in\var{vals},~a\in\AddrB\} \\
      \nextdef
      & \fun{ptrStake} \in (\Addr\mapsto\Coin) \to (\HashKey\mapsto\Ptr) \to \Stake \\
      & \fun{ptrStake}~{vals}~{ptrs} =
          \{\var{hk}\mapsto c
          \mid a\mapsto
          c\in~\var{vals},~a\in\AddrP,~(\fun{addrPtr}~a) \mapsto hk\in\var{ptrs}\} \\
      \nextdef
      & \fun{rewardStake} \in (\AddrRWD\mapsto\Coin) \to \Stake \\
      & \fun{rewardStake}~{rewards} =
          \{\fun{stakeHK_r}~{addr}\mapsto c \mid a\mapsto c\in\var{rewards}\} \\
      \nextdef
      & \fun{poolStake} \in \HashKey \to \powerset{\HashKey} \to (\HashKey \mapsto \HashKey)
          \to \Stake \to \Stake \\
      & \poolStake{operator}{owners}{stake}{delegations} = \\
      & ~~ \left\{hk\mapsto c \mid hk\notin\var{owners'},~hk\mapsto c\in\var{poolStake} \right\}
           \cup
           \left\{ \var{operator}\mapsto
             \sum_{\substack{hk\in\var{owners'} \\ hk\mapsto c\in\var{poolStake}}} c\right\} \\
      & ~~ \where \\
      & ~~~~~~ \var{owners'} = owners \cup \{operator\} \\
      & ~~~~~~ \var{poolStake} =
                 \{hk \mapsto c
                 \mid
                 hk \mapsto c\in\var{stake},~hk\mapsto\var{operator}\in\var{delegations} \} \\
  \end{align*}
  \caption{Helper Functions used in Stake Distribution}
  \label{fig:functions:helper-stake-distribution}
\end{figure}

The stake distribution calculations are given in Figure~\ref{fig:functions:stake-distribution}.
\begin{itemize}
  \item $\fun{stakeDistr}$ combines the stake from base addresses, pointer addresses, and reward
    accounts into a single mapping of hashkeys to coin, filtering out keys that are not both
    registered and delegated.
  \item $\fun{poolDistr}$ groups the stake distribution calculated by $\fun{stakeDistr}$ above
    by stake pool operator.
\end{itemize}

%%
%% Figure Functions for Stake Distribution
%%
\begin{figure}[htb]
  \emph{Stake Distribution}
  %
  \begin{align*}
      & \fun{stakeDistr} \in \UTxO \to \DState \to \PState \to \Stake \\
      & \fun{stakeDistr}~{utxo}~{dstate}~{pstate} =
          (\dom{\var{activeDelegs}})\restrictdom\var{stake}\\
      & \where \\
      & ~~~~ (\var{stkeys},~\var{rewards},~\var{delegations},~\var{ptrs}) = \var{dstate} \\
      & ~~~~ (\var{stpools},~\wcard,~\wcard,~\wcard) = \var{pstate} \\
      & ~~~~ \var{outs} = \fun{consolidate}~{utxo} \\
      & ~~~~ \var{stake} = (\fun{baseStake}~{outs})
                             \unionoverridePlus (\fun{ptrStake}~{outs}~{ptrs})
                             \unionoverridePlus (\fun{rewardStake}~{rewards}) \\
      & ~~~~ \var{activeDelegs} =
               (\dom{stkeys}) \restrictdom \var{delegations} \restrictrange (\dom{stpools}) \\
      \nextdef
      & \fun{poolDistr} \in \UTxO \to \DState \to \PState \to (\HashKey_{pool} \mapsto \Stake) \\
      & \poolDistr{utxo}{dstate}{pstate} = \\
      & ~~ \{hk \mapsto \poolStake{hk}{(\fun{poolOwners}~\var{pool})}{delegations}{stake}
           \mid
           hk\mapsto pool \in \var{poolParams} \} \\
      & \where \\
      & ~~~~ (\wcard,~\wcard,~\var{delegations},~\wcard) = \var{dstate} \\
      & ~~~~ (\wcard,~\var{poolParams},~\wcard,~\wcard) = \var{pstate} \\
      & ~~~~ stake = \fun{stakeDistr}~{utxo}~{dstate}~{pstate}\\
  \end{align*}

  \caption{Stake Distribution Functions}
  \label{fig:functions:stake-distribution}
\end{figure}

\clearpage

%%
%% Figure - Functions for Epoch Rules
%%
\begin{figure}[htb]
  \begin{align*}
      & \fun{obligation} \in \PParams \to \StakeKeys \to \StakePools \to \Slot \to \Coin
      & \text{total possible refunds} \\
      & \obligation{pp}{stkeys}{stpools}{cslot} =\\
      & \sum\limits_{(\_ \mapsto s) \in \var{stkeys}}
        \refund{d_{\mathsf{val}}}{d_{\min}}{\lambda_d}{(\slotminus{cslot}{s})} \\
      & + \sum\limits_{(\_ \mapsto s) \in \var{stpools}}
        \refund{p_{\mathsf{val}}}{p_{\min}}{\lambda_p}{(\slotminus{cslot}{s})} \\
      &
      \begin{array}{lr@{~=~}l}
        \where
          & (\dval,~d_{\min},~\lambda_d) & \fun{decayKey}~\var{pp}\\
          & (p_{\mathsf{val}},~p_{\min},~\lambda_p) & \fun{decayPool}~\var{pp}\\
      \end{array}\\
      \nextdef
      & \fun{poolRefunds} \in \PParams \to (\HashKey \mapsto \Slot) \\
      & ~~ \to \Slot \to (\HashKey \mapsto \Coin)
      & \text{pool refunds} \\
      & \poolRefunds{pp}{retiring}{cslot} = \\
      & \bigcup_{\var{hk}\mapsto s\in\var{retiring}}
          \var{hk}\mapsto( \refund{p_{\mathsf{val}}}{p_{\min}}{\lambda}{(\slotminus{cslot}{s})} ) \\
      &
        \where (p_{\mathsf{val}},~p_{\min},~\lambda_p) = \fun{decayPool}~\var{pp}\\
  \end{align*}
  \caption{Functions used in Accounting}
  \label{fig:functions:epoch}
\end{figure}

\subsection{Rewards Distribution}
\label{sec:reward-dist}

This section defines the reward calculation for the proof of stake leader election.
Figure~\ref{fig:functions:rewards} defines the pool reward as described in section
6.5.1 of \cite{delegation_design}.

\begin{itemize}
  \item The function $\fun{maxPool}$ gives the maximum reward a stake pool can receive in an epoch.
    This is a fraction of the total available rewards for the epoch.
    The result depends on the pool's relative stake, the pool's pledge, and the following
    protocol parameters:
    \begin{itemize}
      \item $\var{a_0}$, the leader-stake influence
      \item $n_{opt}$, the optimal number of saturated stake pools
    \end{itemize}
  \item The function $\fun{movingAvg}$ calculates the new moving average for a given stake pool
    based on its performance and the protocol parameter:
    \begin{itemize}
      \item $\alpha$, the moving average weight
    \end{itemize}
  \item The function $\fun{poolReward}$ gives the total rewards available to be distributed
    to the members of the given pool. It depends on one additional protocol parameter:
    \begin{itemize}
      \item $\gamma$, the moving average exponent
    \end{itemize}
\end{itemize}

%%
%% Figure - Functions for the Reward Calculation
%%
\begin{figure}[htb]
  \emph{Maximal Reward Function, called $f(s,\sigma)$ in section 6.5.1 of \cite{delegation_design}}
  %
  \begin{align*}
      & \fun{maxPool} \in \PParams \to \Coin \to \unitInterval \to \unitInterval \to \Coin \\
      & \fun{maxPool}~\var{pp}~\var{R}~\sigma~\var{p_r} =
          ~~~\floor*{
             \frac{R}{1 + a_0}
             \cdot
             \left(
               \sigma' + p'\cdot a_0\cdot\frac{\sigma' - p'\frac{z_0-\sigma'}{z_0}}{z_0}
             \right)} \\
      & ~~~\where \\
      & ~~~~~~~a_0 = \fun{influence}~pp \\
      & ~~~~~~~n_{opt} = \fun{nopt}~pp \\
      & ~~~~~~~z_0 = 1/n_{opt} \\
      & ~~~~~~~\sigma'=\min(\sigma,~z_0) \\
      & ~~~~~~~p'=\min(p_r,~z_0) \\
  \end{align*}

  \emph{Exponential moving average, see in section 6.5.1 of \cite{delegation_design}}
  %
  \begin{align*}
      & \fun{movingAvg} \in \PParams \to \HashKey \to \N \to \Rnn \to \Avgs \to \R \\
      & \movingAvg{pp}{hk}{n}{\overline{N}}{avgs} =
        \begin{cases}
        \frac{n}{\max(\overline{N}, 1)}
        & hk\notin \dom\var{avgs}\\
        \\
          \alpha\cdot\frac{n}{\max(\overline{N}, 1)}+(1-\alpha)\cdot\var{prev}
        & hk\mapsto\var{prev}\in\var{avgs}\\
        \end{cases} \\
      & ~~~\where \\
      & ~~~~~~~\alpha = \fun{movingAvgWeight}~pp \\
  \end{align*}

  \emph{Actual Reward Function, called $\hat{f}_j$ in section 6.5.1 of \cite{delegation_design}}
  %
  \begin{align*}
      & \fun{poolReward} \in \PParams \to \HashKey \to \N \to \Rnn \to \Avgs \to \Coin \to \Coin \\
      & \poolReward{pp}{hk}{n}{\overline{N}}{avgs}{maxP} =
      \floor*{avg^\gamma\cdot \var{maxP}}\\
      & ~~~\where \\
      & ~~~~~~~\gamma = \fun{movingAvgExp}~pp \\
      & ~~~~~~~\var{avg} = \movingAvg{pp}{hk}{n}{\overline{N}}{avgs} \\
  \end{align*}
  \caption{Functions used in the Reward Calculation}
  \label{fig:functions:rewards}
\end{figure}

\clearpage

Figure~\ref{fig:functions:reward-splitting} gives the calculation for
splitting the pool rewards with its members, as described 6.5.2 of \cite{delegation_design}.
The portion of rewards allocated to the pool operator and owners is different
than that of the members.

\begin{itemize}
  \item The $\fun{r_{leader}}$ function calculates the leader reward, based on the pool cost,
    margin, and proportion of the pool's total stake.  Note that this reward will go to the
    reward account specified in the pool registration certificate.
  \item The $\fun{r_{member}}$ function calculates the member reward, proportionally to their
    stake after the cost and margin are removed.
\end{itemize}

%%
%% Figure - Functions for the Reward Splitting
%%
\begin{figure}[htb]
  \emph{Pool leader reward, from section 6.5.2 of \cite{delegation_design}}
  %
  \begin{align*}
      & \fun{r_{leader}} \in \Coin \to \PoolParam \to \unitInterval \to \unitInterval \to \Coin \\
      & \lReward{\hat{f}}{pool}{s}{\sigma} =
        \begin{cases}
        \hat{f} & \hat{f} \leq c\\
        c + \floor*{(\hat{f} - c)\cdot\left(m + (1-m)\cdot\frac{s}{\sigma}\right) }&
        \text{otherwise.}
      \end{cases} \\
      & ~~~\where \\
      & ~~~~~~~c = \fun{poolCost}~pool \\
      & ~~~~~~~m = \fun{poolMargin}~pool \\
  \end{align*}

  \emph{Pool member reward, from section 6.5.2 of \cite{delegation_design}}
  %
  \begin{align*}
    & \fun{mReward} \in \Coin \to \PoolParam \to \unitInterval \to \unitInterval \to \Coin \\
    & \mReward{\hat{f}}{pool}{t}{\sigma} =
      \begin{cases}
        0 & \hat{f} \leq c\\
        \floor*{(\hat{f} - c)\cdot(1-m)\cdot\frac{t}{\sigma}} &
        \text{otherwise.}
      \end{cases} \\
    & ~~~\where \\
    & ~~~~~~~c = \fun{poolCost}~pool \\
    & ~~~~~~~m = \fun{poolMargin}~pool \\
  \end{align*}

  \caption{Functions used in the Reward Splitting}
  \label{fig:functions:reward-splitting}
\end{figure}


Finally, the full reward calculation is presented in Figure~\ref{fig:functions:reward-calc}.
The calculation is done pool-by-pool.
\begin{itemize}
  \item The $\fun{rewardOnePool}$ function calculates the rewards given out to each member of a
    given pool. The pool leader identified by the stake key of the pool operator.  The function
    returns both the rewards and the total amount of unrealized potential rewards.  The unrealized
    amount will go to the treasury. The rewards include that of the the pool operator, provided
    the reward account from the pool registration certificate is still registered.  If the pool
    reward account is not registered, the operator reward is added to the unrealized total.
  \item The $\fun{reward}$ function applies $\fun{rewardOnePool}$ to each registered stake
    pool, calculating both the full reward mapping and the total unrealized rewards value.
\end{itemize}

%%
%% Figure - The Reward Calculation
%%
\begin{figure}[htb]
  \emph{Calculation to reward a single stake pool}
  %
  \begin{align*}
      & \fun{rewardOnePool} \in \PParams \to \Coin \to \N \to \HashKey \to \PoolParam\\
      & ~~~\to \Stake \to \Avgs \to \Coin \to \StakeKeys \to (\AddrRWD \mapsto \Coin)\times\Coin \\
      & \rewardOnePool{pp}{R}{n}{poolHK}{pool}{stake}{avgs}{tot}{stkeys} =
          (\var{rewards},~\var{unrealized})\\
      & ~~~\where \\
      & ~~~~~~~\var{pstake} = \sum_{\_\mapsto t\in\var{stake}} t \\
      & ~~~~~~~\sigma = \var{pstake} / tot \\
      & ~~~~~~~\var{\overline{N}} = \sigma * (\fun{slotsPerEpoch}~{pp})\\
      & ~~~~~~~\var{pledge} = \fun{poolPledge}~pool \\
      & ~~~~~~~p_{r} = \var{pledge} / \var{tot} \\
      & ~~~~~~~maxP =
      \begin{cases}
        \fun{maxPool}~\var{pp}~\var{R}~\sigma~\var{p_r}&
        \var{pledge} \leq \var{pstake}\\
        0 & \text{otherwise.}
      \end{cases} \\
      & ~~~~~~~\var{poolR} = \poolReward{pp}{hk}{n}{\overline{N}}{avgs}{maxP} \\
      & ~~~~~~~\var{mRewards} = \left\{
                                  \addrRw~hk\mapsto\mReward{poolR}{pool}{\frac{c}{tot}}{\sigma}
                                  ~\Big\vert~
                                  hk\mapsto c\in\var{stake},~~hk \neq\var{poolHK}
                               \right\}\\
      & ~~~~~~~\var{lReward} = \lReward{poolR}{pool}{\frac{\var{stake}~\var{poolHK}}{tot}}{\sigma} \\
      & ~~~~~~~\var{poolAcnt} = \fun{poolAcntHK}~\var{pool} \\
      & ~~~~~~~\var{rewards} =
                 \begin{cases}
                   \var{mReward}\cup\{\addrRw{\var{poolAcnt}}\mapsto\var{lReward}\}
                   & \var{poolAcnt} \in \dom{stkeys} \\
                   \var{mReward} & \text{otherwise.} \\
                 \end{cases} \\
      & ~~~~~~~\var{unrealized} =
                 \begin{cases}
                   \var{maxP} - \var{poolR} & \var{poolAcnt} \in \dom{stkeys} \\
                   (\var{maxP} - \var{poolR})+\var{lReward} & \text{otherwise.} \\
                 \end{cases} \\
  \end{align*}

  \emph{Calculation to reward all stake pools}
  %
  \begin{align*}
      & \fun{reward} \in \PParams \to \BlocksMade \to \Coin\to \DPState \\
      & ~~~ \to (\HashKey_{pool} \mapsto \Stake) \to (\AddrRWD \mapsto \Coin)\times\Coin \\
      & \reward{pp}{blocks}{R}{dpstate}{pooledStake} = (\var{rewards},~\var{unrealized})\\
      & ~~~\where \\
      & ~~~~~~~(\var{dstate},~\var{pstate}) = \var{dpstate} \\
      & ~~~~~~~(~\var{stkeys},~\wcard,~\wcard,~\wcard) = \var{dstate} \\
      & ~~~~~~~(\wcard,~\var{poolParams},~\wcard,~\var{avgs}) = \var{pstate} \\
      & ~~~~~~~tot = \sum_{\_\mapsto st\in \var{pooledStake}}
                       \left(
                       \sum_{\wcard\mapsto c\in\var{st}}c
                       \right) \\
      & ~~~~~~~pdata = \left\{
        hk\mapsto (p, n, s)  \mathrel{\Bigg|}
        \begin{array}{r@{\mapsto}c@{~\in~}l}
          hk & \var{p} & \var{poolParams} \\
          hk & \var{n} & \var{blocks} \\
          hk & \var{s} & \var{pooledStake} \\
        \end{array}
      \right\} \\
      & ~~~~~~~\var{results} = \left\{
                 hk \mapsto \rewardOnePool{pp}{R}{n}{hk}{p}{s}{avgs}{tot}{stkeys}
                 \mid
                 hk\mapsto(p, n, s)\in\var{pdata} \right\} \\
      & ~~~~~~~\var{unrealized} = \sum_{\wcard\mapsto (\wcard,~u)\in\var{results}}u \\
      & ~~~~~~~\var{rewards} = \bigcup_{\wcard\mapsto(\var{rwds},~\wcard)}\var{rwds}
  \end{align*}
  \caption{The Reward Calculation}
  \label{fig:functions:reward-calc}
\end{figure}

\clearpage

\subsection{Accounting Transition}
\label{sec:acc-trans}

Figure~\ref{fig:funcs:acnt} defines the helper functions needed for the accounting transition.

\begin{itemize}
  \item The function $\fun{obligation}$ calculates the the minimal amount of coin needed to
    pay out all depot refunds, as of the current slot.
  \item The function $\fun{poolRefunds}$ is used to calculate the total refunds
    that must be distributed for stake pools scheduled to retire at an epoch boundary.
    Note that this calculation takes a slot number corresponding to the epoch boundary slot
    when the calculation is performed.
  \item The function $\fun{updateAvgs}$ calculates the new performance moving averages.
    Note that these values are computed by the $\fun{poolReward}$ function and could be cached
    in order to prevent calculating them twice.
\end{itemize}


%%
%% Figure - Functions for Epoch Rules
%%
\begin{figure}[htb]
  \emph{Total possible refunds}
  \begin{align*}
      & \fun{obligation} \in \PParams \to \StakeKeys \to \StakePools \to \Slot \to \Coin \\
      & \obligation{pp}{stkeys}{stpools}{cslot} =\\
      & \sum\limits_{(\_ \mapsto s) \in \var{stkeys}}
        \refund{d_{\mathsf{val}}}{d_{\min}}{\lambda_d}{(\slotminus{cslot}{s})}
        + \sum\limits_{(\_ \mapsto s) \in \var{stpools}}
        \refund{p_{\mathsf{val}}}{p_{\min}}{\lambda_p}{(\slotminus{cslot}{s})} \\
      &
      \begin{array}{lr@{~=~}l}
        \where
          & \dval,~d_{\min},~\lambda_d
          & \fun{keyDeposit}~\var{pp},~\fun{keyMinRefund}~\var{pp},~\fun{keyDecayRate}~\var{pp}
          \\
          & p_{\mathsf{val}},~p_{\min},~\lambda_p
          & \fun{poolDeposit}~\var{pp},~\fun{poolMinRefund}~\var{pp},~\fun{poolDecayRate}~\var{pp}
      \end{array}\\
  \end{align*}
  \emph{Pool refunds}
  \begin{align*}
      & \fun{poolRefunds} \in \PParams \to (\HashKey \mapsto \Epoch) \to \Slot \to
        (\HashKey \mapsto \Coin) \\
      & \poolRefunds{pp}{retiring}{cslot} = \left\{
        \var{hk}\mapsto
          \refund{p_{\mathsf{val}}}{p_{\min}}{\lambda}{(\slotminus{cslot}{(\fun{firstSlot}~e)})}
          \mid
          \var{hk}\mapsto e\in\var{retiring}
        \right\}\\
      & \where p_{\mathsf{val}},~p_{\min},~\lambda_p =
          \fun{poolDeposit}~\var{pp},~\fun{poolMinRefund}~\var{pp},~\fun{poolDecayRate}~\var{pp} \\
  \end{align*}

  \emph{Update Moving Averages}
  \begin{align*}
      & \fun{updateAvgs} \in \PParams \to \Avgs \to \BlocksMade \to
          (\HashKey_{pool}\mapsto \Stake) \to \Avgs \\
      & \updateAvgs{pp}{avgs}{blocks}{pooledStake} = \\
      & ~~~ \left\{hk\mapsto \movingAvg{pp}{hk}{n}{\overline{N}}{avgs}
            \mid
            hk\mapsto n\in\var{blocks}, hk\mapsto\overline{N}\in\var{expectations}
            \right\} \\
      & \where \\
      & ~~~~~ \var{tot} = \sum_{\_\mapsto st\in \var{pooledStake}}
                          \left(\sum_{\wcard\mapsto c\in\var{st}}c\right) \\
      & ~~~~~ \var{expectations} =
                \left\{
                  hk\mapsto\left(\sum_{
                    \wcard\mapsto c\in\var{st}}c\right)*(\fun{slotsPerEpoch}~{pp}) / tot
                  \mid
                  hk\mapsto\var{st} \in pooledStake
                \right\}
  \end{align*}
  \caption{Helper Functions used in Accounting}
  \label{fig:funcs:acnt}
\end{figure}



Figure~\ref{fig:ts-types:acnt} gives the definitions for the accounting transition.
The figure lists the accounting fields, denoted by $\Acnt$, which consists of:
\begin{itemize}
  \item The value $\var{treasury}$ tracks the amount of coin currently stored in the treasury.
    Initially there will be no way to remove these funds.
  \item The value $\var{reserves}$ tracks the amount of coin currently stored in the reserves.
    This pot is used to pay rewards.
  \item The value $\var{rewardPot}$ to tracks the rewards from the previous epoch that were not
    payed out.
\end{itemize}
The figure also defines the accounting environment, $\AcntEnv$, and the accounting state,
$\AcntState$, which combines the accounting fields described above with the UTxO State,
the delegation state, and the pool state.
The accounting state transition type, like all the transition types in this section, has no signal.

%%
%% Figure - Accounting Defs
%%
\begin{figure}[htb]
  \emph{Accounting Fields}
  \begin{equation*}
    \Acnt =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{treasury} & \Coin & \text{treasury pot}\\
        \var{reserves} & \Coin & \text{reserve pot}\\
        \var{rewardPot} & \Coin & \text{reward pot}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Accounting environment}
  \begin{equation*}
    \AcntEnv =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{slot} & \Slot & \text{last slot of epoch}\\
        \var{pp} & \PParams & \text{protocol parameters}\\
        \var{blocks} & \BlocksMade & \text{blocks made in the epoch}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Accounting States}
  \begin{equation*}
    \AcntState =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{acnt} & \Acnt & \text{accounting}\\
        \var{dstate} & \DState & \text{delegation state}\\
        \var{pstate} & \PState & \text{pool state}\\
        \var{utxoSt} & \UTxOState & \text{utxo state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Accounting transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{acnt}{} \var{\_}
    \subseteq \powerset (\AcntEnv \times \AcntState \times \AcntState)
  \end{equation*}
  %
  \caption{Accounting transition-system types}
  \label{fig:ts-types:acnt}
\end{figure}

\clearpage

Figure~\ref{fig:rules:acnt} defines the accounting transition rule.  Value is moved between
accounting pots, but the total amount of value in the system remains constant.
The accounting transition has no preconditions.

\begin{itemize}
  \item First we calculate $\var{totalPot}$, the total amount of coin available for rewards this epoch,
    , as described in section 6.4 of \cite{delegation_design}. It consists of four pots:
    \begin{itemize}
      \item The fee pot, containing the transaction fees from the epoch.
      \item The amount of coin in the deposit pot that is no longer needed, due to decay.
      \item The reward pot, which is the left-over rewards from the previous epoch.
      \item Some amount of monetary expansion from the reserves, as determined by the
        $\rho$ protocol parameter.
    \end{itemize}
  \item Some proportion of the total pot is moved to the treasury,
    as determined by the $\tau$ protocol parameter. The remaining pot is called the
    $\var{availablePool}$, which is also called $R$ in section 6.5 of \cite{delegation_design}.
  \item The stake distribution is calculated based on the UTxO and the delegation and pool state.
  \item The $\var{availablePool}$ is now distributed as rewards. As given by $\fun{maxPool}$,
    each pool can receive a maximal amount, as determined by its performance.
    The difference between the maximal amount and the actual amount received is
    moved to the treasury.
  \item The reward pot is now set to the $\var{availablePool}$ minus the total amount of rewards
    actually paid out and the unrealized rewards given to the treasury.
  \item The moving averages are updated.
  \item The deposit pot is set to the minimal amount to cover the total refund obligation.
  \item The fee pot is set to zero.
\end{itemize}

Note that fees and deposit decay, above, are not explicitly removed from any account:
the fees come from transactions paying them, and are accounted for whenever
transactions are processed, and the deposit decay value comes from returning
smaller refunds for deposits than were paid upon depositing.

Figure \ref{fig:fund-preservation} captures the potential movement of funds
between these various locations during the epoch transition and transaction
processing. In particular, the red subgraph represents the inputs and outputs to
the ``total pot'' used during the epoch transition in Figure \ref{fig:rules:acnt}.
The blue arrows represent the movement of funds that pass through the ``total pot''.

\begin{figure}[htb]
  \begin{center}
    \begin{tikzpicture}
      [ x=30mm, y=30mm
      , direct/.style={black, draw}
      , implied/.style={blue, draw}
      , toTotPot/.style={red, draw}
      ]
    \node (C) at (3,3) {Circulation};
    \node (R) at (5, 1) {Reserves};
    \node (D) at (1, 2) {Deposits};
    \node (FR) at (1,1) {Fees/Reward pot};
    \node (RA) at (5, 2) {Reward accounts};
    \node (T) at (3,0) {Treasury};

    \draw[->, direct, thick]
    (C) edge (D)
    (C) edge (FR)

    (D) edge (C)
    (D) edge (FR)

    (RA) edge (C);

    \draw[->, implied, thick]
    (D) edge (RA)
    (D) edge (T)

    (FR) edge (T)
    (FR) edge (RA)

    (R) edge (FR)
    (R) edge (T)
    (R) edge (RA);

    \node (TP) at (3, 1.25) {Total pot};

    \draw[->, toTotPot, thick]
    (D) edge (TP)
    (FR) edge (TP)
    (R) edge (TP)

    (TP) edge (RA)
    (TP) edge (FR)
    (TP) edge (T);

  \end{tikzpicture}
  \end{center}
  \caption{Conservation of money}
  \label{fig:fund-preservation}
\end{figure}

\clearpage

%%
%% Figure - Accounting Rules
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:acnt}
    \inference[Accounting]
    {
      {
      \begin{array}{r@{=}l}
        \var{obl} & \obligation{pp}{stkeys}{stpools}{slot} \\
        \var{decayed} & \var{deposits} - \var{obl} \\
        \var{expansion} & \floor*{(\fun{rho}~{pp}) \cdot \var{reserves}} \\
        \var{totalPot} & \var{fees} + \var{decayed} + \var{rewardPot} + \var{expansion} \\
        \var{newTreasury} & \floor*{(\fun{tau}~{pp}) \cdot \var{totalPot}} \\
        \var{availablePool} & \var{totalPot} - \var{newTreasury} \\
        \var{pooledStake} & \poolDistr{utxo}{dstate}{pstate} \\
        \var{rewards'},~\var{unrealized} & \reward{pp}{blocks}{availablePool}{dpstate}{pooledStake}\\
        \var{newTreasury'} & \var{newTreasury} + \var{unrealized} \\
        \var{paidRewards} & \left(
                            \sum\limits_{\_\mapsto c\in\var{rewards'}}c
                            \right) + \var{unrealized} \\
        \var{avgs'} & \updateAvgs{pp}{avgs}{blocks}{pooledStake} \\
      \end{array}
      }
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{blocks}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{treasury} \\
          \var{reserves} \\
          \var{rewardPot} \\
          \var{stkeys} \\
          \var{rewards} \\
          \var{delegations} \\
          \var{ptrs} \\
          \var{stpools} \\
          \var{poolParams} \\
          \var{retiring} \\
          \var{avgs} \\
          \var{utxo} \\
          \var{deposits} \\
          \var{fees} \\
        \end{array}
      \right)
      \trans{acnt}{}
      \left(
        \begin{array}{rcl}
          \varUpdate{\var{treasury}} & \varUpdate{+} & \varUpdate{\var{newTreasury'}} \\
          \varUpdate{\var{reserves}} & \varUpdate{-} & \varUpdate{\var{expansion}} \\
          \varUpdate{\var{availablePool}} & \varUpdate{-} & \varUpdate{\var{paidRewards}} \\
          \var{stkeys} \\
          \varUpdate{\var{rewards}} & \varUpdate{\unionoverridePlus} & \varUpdate{\var{rewards'}} \\
          \var{delegations} \\
          \var{ptrs} \\
          \var{stpools} \\
          \var{poolParams} \\
          \var{retiring} \\
          \varUpdate{\var{avgs'}} \\
          \var{utxo} \\
          \varUpdate{obl} \\
          \varUpdate{0} \\
        \end{array}
      \right)
    }
  \end{equation}
  \caption{Accounting Epoch inference rules}
  \label{fig:rules:acnt}
\end{figure}

\subsection{Epoch Boundary Pool Reaping}
\label{sec:pool-reap}

Figure~\ref{fig:ts-types:pool-reap} defines the types for the pool reap transition,
which is responsible for removing pools slated for retirement in the given epoch.

%%
%% Figure - Pool Reap Defs
%%
\begin{figure}[htb]
  \emph{Pool Reap State}
  \begin{equation*}
    \PlReapState =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{acnt} & \Acnt & \text{accounting}\\
        \var{dstate} & \DState & \text{delegation state}\\
        \var{pstate} & \PState & \text{pool state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Pool Reap transitions}
  \begin{equation*}
    \_ \vdash \_ \trans{poolreap}{} \_ \in
    \powerset (\Slot \times \PlReapState \times \PlReapState)
  \end{equation*}
  %
  \caption{Pool Reap Transition}
  \label{fig:ts-types:pool-reap}
\end{figure}


The pool-reap transition rule is given in Figure~\ref{fig:rules:pool-reap}.
This transition has no preconditions and results in the following state change:

\begin{itemize}
  \item For each retiring pool, the refund for the pool registration deposit is added to the
    pool's registered reward account, provided the reward account is still registered.
  \item The sum of all the pool deposit refunds for pools without a registered reward
    accounts is added to the treasury.
  \item Any delegation to a retiring pool is removed.
  \item Each retiring pool is removed from all the four maps in the pool state.
\end{itemize}

%%
%% Figure - Pool Reap Rule
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:pool-reap}
    \inference[Pool-Reap]
    {
      {
      \begin{array}{r@{=}l}
        \var{retired} & \var{retiring}^{-1}~\var{(\epoch{slot})} \\
        \var{pr} & \poolRefunds{pp}{retiring}{cslot} \\
        \var{rewardAcnts} & \{\var{hk}\mapsto \fun{poolAcntHK}~\var{pool} \mid
                            \var{hk}\mapsto\var{pool} \in \var{poolParams},
                            ~\var{hk}\in\var{retired}\} \\
        \var{refunds} & \left\{
                        \addrRw{hk'} \mapsto c
                        \mathrel{\Bigg|}
                        \begin{array}{r@{~\in~}l}
                          \var{hk} \mapsto c & \var{pr}, \\
                          \var{hk}\mapsto\var{hk'} & \var{rewardAcnts}, \\
                          \var{hk'} & \dom\var{stkeys}
                        \end{array}
                      \right\} \\
        \var{unclaimed} & \sum\limits_{\substack{
                          hk \mapsto c \in \var{pr} \\
                          \var{hk}\mapsto\var{hk'} \in \var{rewardAcnts}, \\
                          \var{hk'} \notin \var{stkeys}
                          }} c
      \end{array}
      }
    }
    {
      \begin{array}{l}
        \var{slot}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{treasury} \\
          \var{reserves} \\
          \var{rewardPot} \\
          \var{stkeys} \\
          \var{rewards} \\
          \var{delegations} \\
          \var{ptrs} \\
          \var{stpools} \\
          \var{poolParams} \\
          \var{retiring} \\
          \var{avgs} \\
        \end{array}
      \right)
      \trans{poolreap}{}
      \left(
        \begin{array}{rcl}
          \varUpdate{\var{treasury}} & \varUpdate{+} & \varUpdate{\var{unclaimed}} \\
          \var{reserves} \\
          \var{rewardPot} \\
          \var{stkeys} \\
          \varUpdate{\var{rewards}} & \varUpdate{\unionoverridePlus} & \varUpdate{\var{refunds}} \\
          \varUpdate{\var{delegations}} & \varUpdate{\subtractrange} & \varUpdate{\var{retiring}} \\
          \var{ptrs} \\
          \varUpdate{\var{retired}} & \varUpdate{\subtractdom} & \varUpdate{\var{stpools}} \\
          \varUpdate{\var{retired}} & \varUpdate{\subtractdom} & \varUpdate{\var{poolParams}} \\
          \varUpdate{\var{retired}} & \varUpdate{\subtractdom} & \varUpdate{\var{retiring}} \\
          \varUpdate{\var{retired}} & \varUpdate{\subtractdom} & \varUpdate{\var{avgs}} \\
        \end{array}
      \right)
    }
  \end{equation}
  \caption{Pool Reap Inference Rule}
  \label{fig:rules:pool-reap}
\end{figure}

\clearpage

\subsection{Epoch Boundary Protocol Constants Update}
\label{sec:prot-param-epoch}

Finally, reaching the epoch boundary may trigger a change in the protocol
parameters. Besides the current slot number, delegation and pool states, the
protocol parameters environment includes new protocol parameters.
The state change is a change of the $\UTxOState$, the $\Acnt$ states, and the current
$\PParams$.
The type of this state transition is given in Figure~\ref{fig:ts-types:new-proto-param}.

%%
%% Figure - New Proto Param Defs
%%
\begin{figure}[htb]
  \emph{New Proto Param environment}
  \begin{equation*}
    \NewPParamEnv =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{slot} & \Slot & \text{current slot}\\
        \var{ppNew} & \PParams & \text{new protocol parameters}\\
        \var{dstate} & \DState & \text{delegation state}\\
        \var{pstate} & \PState & \text{pool state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{New Proto Param States}
  \begin{equation*}
    \NewPParamState =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{utxoSt} & \UTxOState & \text{utxo state}\\
        \var{acnt} & \Acnt & \text{accounting}\\
        \var{pp} & \PParams & \text{current protocol parameters}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{New Proto Param transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{newpp}{} \var{\_}
    \subseteq \powerset (\NewPParamEnv \times \NewPParamState \times \NewPParamState)
  \end{equation*}
  %
  \caption{New Proto Param transition-system types}
  \label{fig:ts-types:new-proto-param}
\end{figure}


Figure~\ref{fig:rules:new-proto-param} defines the new protocol parameter transition.
The transition has two rules, depending on whether or not the new protocol parameters
would incur a debt on the system that could not be covered by the reserves.
The transition has two rules, each with one precondition. The preconditions are
negations of each other, so that exactly one rule will have its precondition met.
This transition results in the following state change:

\begin{itemize}
  \item If the new protocol parameters mean that \textbf{fewer} funds are required in the
    deposit pot to cover all possible refunds, then Rule~\ref{eq:new-pc-accepted} meets
    the precondition. The excess is moved to the reserves and the protocol parameters are updated.

  \item If the new protocol parameters mean that \textbf{more} funds are required in the
    deposit pot to cover all possible refunds, and the difference is \textbf{less} than
    the reserve pot, then Rule~\ref{eq:new-pc-accepted} meets the precondition.  Funds are moved
    from the reserve pot to cover the difference and the protocol parameters are updated.

  \item If the new protocol parameters mean that \textbf{more} funds are required in the
    deposit pot to cover all possible refunds, and the difference is \textbf{more} than
    the reserve pot, then Rule~\ref{eq:new-pc-denied} meets the precondition and no state change happens.
\end{itemize}

Note that here, unlike most of the inference rules in this document,
the $\var{utxoSt'}$ and the $\var{acnt'}$ do not come from valid UTxO or
accounts transitions in the antecedent. We simply define the consequent
transition using these directly (instead of listing all the fields in both
states in the consequent transition). It is done this way here
for ease of reading.

%%
%% Figure - New Proto Param Rule
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:new-pc-accepted}
    \inference[New-Proto-Param-Accepted]
    {
      \var{oblgCur} = \obligation{pp}{stkeys}{stpools}{slot} \\
      \var{oblgNew} = \obligation{ppNew}{stkeys}{stpools}{slot} \\
      ~\\
      \var{diff} = \var{oblgCur} - \var{oblgNew} \\
      \var{reserves} + \var{diff} \geq 0\\
      ~\\
      \var{utxoSt'} =
      \left(
        {
          \begin{array}{r}
            \var{utxo} \\
            \varUpdate{oblgNew} \\
            \var{fees} \\
          \end{array}
        }
      \right)
      &
      \var{acnt'} =
      \left(
        {
          \begin{array}{r}
            \var{treasury} \\
            \varUpdate{reserves + diff} \\
            \var{rewardPot} \\
            \var{rewards} \\
          \end{array}
        }
      \right)
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{ppNew}\\
        \var{dstate}\\
        \var{pstate}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{utxoSt} \\
          \var{acnt} \\
          \var{pp}
        \end{array}
      \right)
      \trans{newpp}{}
      \left(
        \begin{array}{rcl}
          \varUpdate{utxoSt'}\\
          \varUpdate{acnt'} \\
          \varUpdate{\var{ppNew}} \\
        \end{array}
      \right)
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:new-pc-denied}
    \inference[New-Proto-Param-Denied]
    {
      \var{oblgCur} = \obligation{pp}{stkeys}{stpools}{slot} \\
      \var{oblgNew} = \obligation{ppNew}{stkeys}{stpools}{slot} \\
      ~\\
      \var{diff} = \var{oblgCur} - \var{oblgNew} \\
      \var{reserves} + \var{diff} < 0\\
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{ppNew}\\
        \var{dstate}\\
        \var{pstate}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{utxoSt} \\
          \var{acnt} \\
          \var{pp}
        \end{array}
      \right)
      \trans{newpp}{}
      \left(
        \begin{array}{rcl}
          \var{utxoSt} \\
          \var{acnt} \\
          \var{pp}
        \end{array}
      \right)
    }
  \end{equation}
  \caption{New Proto Param Inference Rule}
  \label{fig:rules:new-proto-param}
\end{figure}

\clearpage

\subsection{Complete Epoch Boundary Transition}
\label{sec:total-epoch}

Finally, it is possible to define the complete epoch boundary transition type,
which is defined in Figure~\ref{fig:ts-types:epoch}.
In the environment of this transition, we have the slot number, potentially new
protocol parameters, and the blocks made this epoch.  The state is made up of the
the UTxO state, the accounting state, the delegation state, the pool state, and
the current protocol parameters.

%%
%% Figure - Epoch Defs
%%
\begin{figure}[htb]
  \emph{Epoch environment}
  \begin{equation*}
    \EpochEnv =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{slot} & \Slot & \text{current slot}\\
        \var{ppNew} & \PParams & \text{new protocol parameters}\\
        \var{blocks} & \HashKey \mapsto \N & \text{blocks made in the epoch}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Epoch States}
  \begin{equation*}
    \EpochState =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{utxoSt} & \UTxOState & \text{utxo state}\\
        \var{acnt} & \Acnt & \text{accounting}\\
        \var{dstate} & \DState & \text{delegation state}\\
        \var{pstate} & \PState & \text{pool state}\\
        \var{pp} & \PParams & \text{current protocol parameters}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Epoch transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{epoch}{} \var{\_}
    \subseteq \powerset (\EpochEnv \times \EpochState \times \EpochState)
  \end{equation*}
  %
  \caption{Epoch transition-system types}
  \label{fig:ts-types:epoch}
\end{figure}


The epoch transition rule is a composition of all the state transition rules we have defined above.
It calls $\mathsf{ACNT}$, $\mathsf{POOLREAP}$, and $\mathsf{NEWPP}$ in sequence.

Note that the slot number used as \textit{current slot number}
for the epoch boundary calculations where a slot number is required is set to
be the \textit{last slot of the epoch before the boundary}.

%%
%% Figure - Epoch Rule
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:epoch}
    \inference[Epoch]
    {
      {
        \begin{array}{l}
          \var{slot}\\
          \var{pp}\\
          \var{blocks}\\
        \end{array}
      }
      \vdash
      \left(
        {
          \begin{array}{r}
            \var{acnt} \\
            \var{dstate} \\
            \var{pstate} \\
            \var{utxoSt} \\
          \end{array}
        }
      \right)
      \trans{acnt}{}
      \left(
      {
        \begin{array}{rcl}
          \var{acnt'} \\
          \var{dstate'} \\
          \var{pstate'} \\
          \var{utxoSt'} \\
        \end{array}
      }
      \right)
      \\~\\~\\
      {
        \begin{array}{l}
          \var{slot}
        \end{array}
      }
      \vdash
      \left(
        {
          \begin{array}{r}
            \var{acnt'} \\
            \var{dstate'} \\
            \var{pstate'} \\
          \end{array}
        }
      \right)
      \trans{poolreap}{}
      \left(
      {
        \begin{array}{rcl}
            \var{acnt''} \\
            \var{dstate''} \\
            \var{pstate''} \\
        \end{array}
      }
      \right)
      \\~\\~\\
      {
        \begin{array}{l}
          \var{slot}\\
          \var{ppNew}\\
          \var{dstate'}\\
          \var{pstate''}\\
        \end{array}
      }
      \vdash
      \left(
        {
          \begin{array}{r}
            \var{utxoSt'} \\
            \var{acnt''} \\
            \var{pp}\\
          \end{array}
        }
      \right)
      \trans{newpp}{}
      \left(
      {
        \begin{array}{rcl}
            \var{utxoSt''} \\
            \var{acnt'''} \\
            \var{pp'}\\
        \end{array}
      }
      \right)
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{ppNew}\\
        \var{blocks}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxoSt} \\
        \var{acnt} \\
        \var{dstate} \\
        \var{pstate} \\
        \var{pp} \\
      \end{array}
      \right)
      \trans{epoch}{}
      \left(
      \begin{array}{rcl}
        \varUpdate{\var{utxoSt''}} \\
        \varUpdate{\var{acnt'''}} \\
        \varUpdate{\var{dstate''}} \\
        \varUpdate{\var{pstate''}} \\
        \varUpdate{\var{pp'}}
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Epoch Inference Rule}
  \label{fig:rules:epoch}
\end{figure}
