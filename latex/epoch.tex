\newcommand{\UTxOEpState}{\type{UTxOEpState}}
\newcommand{\Accnt}{\type{Accnt}}
\newcommand{\AccntEnv}{\type{AccntEnv}}
\newcommand{\AccntState}{\type{AccntState}}
\newcommand{\StPlCleanEnv}{\type{StPlCleanEnv}}
\newcommand{\StPlCleanState}{\type{StPlCleanState}}
\newcommand{\NewProtoConstsEnv}{\type{NewProtoConstsEnv}}
\newcommand{\NewProtoConstsState}{\type{NewProtoConstsState}}
\newcommand{\EpochEnv}{\type{EpochEnv}}
\newcommand{\EpochState}{\type{EpochState}}
\newcommand{\Production}{\type{Production}}

\newcommand{\obligation}[4]{\fun{obligation}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\reward}[5]{\fun{reward}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}~ \var{#5}}
\newcommand{\poolRefunds}[3]{\fun{poolRefunds}~ \var{#1}~ \var{#2}~ \var{#3}}

In this chapter we discuss the ledger state updates that take place at the epoch
boundary. These are necessary updates that are not triggered by a transaction.
It is impractical and unnecessary to perform the calculations and updates we
describe below every slot. The main state updates that take place at the boundary
are of an accounting nature, calculating new values for the various accounts
on the ledger (treasury, reserves, rewards, fees).

However, it is also when
pools scheduled for retirement at this boundary are removed from the ledger.
In addition, if there is an update planned for any of the protocol constants,
it may only take place at the epoch boundary, and results in a ledger state
update, which we also give the details of in this chapter.
Note that witnessing here is not necessary because there is no data to sign
in the signal.

We introduce a new abstract type in this chapter, $\Production$ (see
Figure~\ref{fig:epoch-defs}), which represents the set of blocks produced by the
blockchain this epoch.

%%
%% Figure - Epoch Abstract Types
%%
\begin{figure}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}ll}
      \var{production} & \Production & \text{blocks produced in the epoch}\\
    \end{array}
  \end{equation*}
  \caption{Epoch definitions}
  \label{fig:epoch-defs}
\end{figure}


In Figure~\ref{fig:functions:epoch}, we give the functions
used in the deposit calculations at the boundary. Here we introduce the function
that gives the value of the total possible (decayed) refunds for both individual and
pool deposits in a given slot number, $\fun{obligation}$.

Next, we give the type of the function used to calculate additional rewards that will become
available to be claimed after the boundary. This function is denoted $\fun{reward}$,
and depends on this epoch's blocks, protocol constants, the delegation
and pool states, and existing rewards unclaimed in the previous epoch.
The $\fun{reward}$ function
updates the existing records of the unclaimed coin values by adding newly
accumulated rewards this epoch to the value in each reward address.

\begin{todo}
  This calculation has been decided on already?
\end{todo}

The function $\fun{poolRefunds}$ is used to calculate the total refunds
that must be distributed
for stake pools scheduled to retire at an epoch boundary. Note that this
calculation takes a slot number as a parameter because that is the type of value
needed for the decay calculation, but will only ever be invoked
when the slot number is the last before the boundary.

The map $\fun{poolRefunds}$ uses the pool decay constants in $\PrtclConsts$
to assign a refund to each pool key in the set of pools scheduled for retirement
at the epoch boundary.

%%
%% Figure - Functions for Epoch Rules
%%
\begin{figure}[htb]
  \begin{align*}
      & \fun{obligation} \in \PrtclConsts \to \Allocs \to \Allocs \to \Slot \to \Coin
      & \text{total possible refunds} \\
      & \obligation{pc}{stkeys}{stpools}{cslot} =\\
      & \sum\limits_{(\_ \mapsto s) \in \var{stkeys}}
        \refund{d_{\mathsf{val}}}{d_{\min}}{(\slotminus{cslot}{s})}{\lambda_d} \\
      & + \sum\limits_{(\_ \mapsto s) \in \var{stpools}}
        \refund{p_{\mathsf{val}}}{p_{\min}}{(\slotminus{cslot}{s})}{\lambda_p} \\
      &
      %  \where k_{\mathsf{val}}, k_{\min},p_{\mathsf{val}}, p_{\min}, \lambda \in pc
      \begin{array}{lr@{~=~}l}
        \where
          & (\dval,~d_{\min},~\lambda_d) & \fun{decayKey}~\var{pc}\\
          & (p_{\mathsf{val}},~p_{\min},~\lambda_p) & \fun{decayPool}~\var{pc}\\
      \end{array}\\
      \nextdef
      & \fun{reward} \in \Production \to \PrtclConsts \to \Coin \to DWState \to \\
      & ~~~ (\AddrRWD \mapsto \Coin) \to (\AddrRWD \mapsto \Coin)
      & \text{update rewards} \\
      & \reward{prod}{pc}{availablePool}{dwstate}{rewards} = \mathsf{TBD}\\
      \nextdef
      & \fun{poolRefunds} \in \PrtclConsts \to \Allocs \to \Slot \to (\HashKey \mapsto \Coin)
      & \text{pool refunds} \\
      & \poolRefunds{pc}{retiring}{cslot} = \\
      & \bigcup_{\var{hk}\mapsto s\in\var{retiring}}
          \var{hk}\mapsto( \refund{p_{\mathsf{val}}}{p_{\min}}{(\slotminus{cslot}{s})}{\lambda} ) \\
      &
        \where (p_{\mathsf{val}},~p_{\min},~\lambda_p) = \fun{decayPool}~\var{pc}\\
  \end{align*}
  \caption{Functions used in Deposits}
  \label{fig:functions:epoch}
\end{figure}


The type of the UTxO state transition at the epoch boundary is given in
Figure~\ref{fig:ts-types:utxoe}. There is no signal for this transition, but rather
it is the result of a change in the environment, i.e. the slot number changing
from the last slot of an epoch to the first slot of the subsequent epoch.

%%
%% Figure - UTxO Epoch Defs
%%
\begin{figure}[htb]
  \emph{UTxOE transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{utxoep}{} \var{\_}
    \subseteq \powerset (\UTxOEnv \times \UTxOState \times \UTxOState)
  \end{equation*}
  %
  \caption{UTxO Epoch transition-system types}
  \label{fig:ts-types:utxoe}
\end{figure}


The inference rule describing when the boundary UTxO state transition can
take place is presented in~\ref{fig:rules:utxoep}. As a result of the application
of this rule, the $\var{deposits}$ value is decreased by the
amount of decay of refunds this epoch (calculated by the $\fun{obligation}$
function), and $\var{fees}$ value on the ledger is set to 0.

%%
%% Figure - UTxO Epoch Rule
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:utxoep}
    \inference[UTxO-epoch]
    {
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pc}\\
        \var{stkeys}\\
        \var{stpools}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{utxo} \\
          \var{deposits} \\
          \var{fees} \\
        \end{array}
      \right)
      \trans{utxoep}{}
      \left(
        \begin{array}{r}
          \var{utxo} \\
          \obligation{pc}{stkeys}{stpools}{slot} \\
          0 \\
        \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO Epoch inference rules}
  \label{fig:rules:utxoep}
\end{figure}


The Figure~\ref{fig:ts-types:accnt} gives the definitions related to epoch
boundary ledger accounting. The figure lists the accounting fields, denoted by
$\Accnt$, which include $\var{treasury}$ (the amount of coin currently in
circulation, but not on the UTxO and not designated for rewards),
$\var{reserves}$ (the amount of coin
not yet in circulation),
and $\var{rewardPool}$ (the total amount available for distribution of rewards).
The figure also gives the set of necessary accounting environment
variables, $\AccntEnv$, and the accounting state, $\AccntState$, which includes
the delegation state and the accounting fields. The accounting state transition
type, as all transition types in this chapter, has no signal.

%%
%% Figure - Accounting Defs
%%
\begin{figure}[htb]
  \emph{Accounting Fields}
  \begin{equation*}
    \Accnt =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{treasury} & \Coin & \text{treasury pool}\\
        \var{reserves} & \Coin & \text{reserve pool}\\
        \var{rewardPool} & \Coin & \text{reward pool}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Accounting environment}
  \begin{equation*}
    \AccntEnv =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pc} & \PrtclConsts & \text{protocol constants}\\
        \var{production} & \Production & \text{blocks produced in the epoch}\\
        \var{utxoSt} & \UTxOState & \text{utxo state}\\
        \var{pstate} & \PState & \text{pool state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Accounting States}
  \begin{equation*}
    \AccntState =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{accnt} & \Accnt & \text{accounting}\\
        \var{dstate} & \DState & \text{delegation state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Accounting transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{accnt}{} \var{\_}
    \subseteq \powerset (\AccntEnv \times \AccntState \times \AccntState)
  \end{equation*}
  %
  \caption{Accounting transition-system types}
  \label{fig:ts-types:accnt}
\end{figure}


The accounting epoch boundary rule in Figure~\ref{fig:rules:accnt} is the rule
where the most attention to detail is required in order to adhere to the
preservation of value condition. In this rule, the funds in each of the
accounting variables, as well as the individual reward addresses, are adjusted
as follows:

\begin{itemize}
\item The $\var{treasury}$ has a fraction $\tau$ of the sum of
the fees accumulated from transactions this epoch, the decay amount
of all current deposits, the total reward pool, and the expansion (how much
coin is added to circulation each epoch) added to it
\item A fraction $\rho$ of the $\var{reserves}$ comes into circulation (i.e.
is removed from $\var{reserves}$)
\item The value added to $\var{treasury}$ is removed from the $\var{rewardPool}$
\item The the sum total of rewards accumulated for all addresses this epoch
is removed from the $\var{rewardPool}$
\item The accumulated fees, deposit decay, and circulation expansion is
added to the $\var{rewardPool}$
\item The rewards accumulated this epoch are distributed by
adding the amount computed for each reward address (by the $\fun{rewardPool}$ calculation)
to the value of coin corresponding to that address
\end{itemize}

Note that fees and deposit decay, above, are not explicitly removed from any account:
the fees come from transactions paying them, and are accounted for whenever
transactions are processed, and the deposit decay value comes from returning
smaller refunds for deposits than were paid upon depositing.

%%
%% Figure - Accounting Rules
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:accnt}
    \inference[Accounting]
    {
      {
      \begin{array}{r@{=}l}
        \var{obl} & \obligation{pc}{stkeys}{stpools}{slot} \\
        \var{decayed} & \var{deposits} - \var{obl} \\
        %\rho, \tau \in pc \\
        \var{expansion} & \floor*{\rho \cdot \var{reserves}} \\
        \var{totalPool} & \var{fees} + \var{decayed} + \var{rewardPool} + \var{expansion} \\
        \var{newTreasury} & \floor*{\tau \cdot \var{totalPool}} \\
        \var{availablePool} & \var{totalPool} - \var{newTreasury} \\
        \var{rewards'} & \reward{production}{pc}{availablePool}{dwstate}{rewards}\\
        \var{paidRewards} & \sum\limits_{\_\mapsto c\in\var{rewards'}}c
      \end{array}
      }
    }
    {
      \begin{array}{l}
        \var{production}\\
        \var{slot}\\
        \var{pc}\\
        \var{utxoSt}\\
        \var{pstate}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{treasury} \\
          \var{reserves} \\
          \var{rewardPool} \\
          \var{stkeys} \\
          \var{rewards} \\
          \var{delegations} \\
          \var{pointeraddr} \\
        \end{array}
      \right)
      \trans{accnt}{}
      \left(
        \begin{array}{rcl}
          \var{treasury} & + & \var{newTreasury}\\
          \var{reserves} & - & \var{expansion} \\
          \var{availablePool} & - & \var{paidRewards} \\
          \var{stkeys} \\
          \var{rewards} & \unionoverridePlus & \var{rewards'} \\
          \var{delegations} \\
          \var{pointeraddr} \\
        \end{array}
      \right)
    }
  \end{equation}
  \caption{Accounting Epoch inference rules}
  \label{fig:rules:accnt}
\end{figure}


Next, we discuss the epoch boundary pool retirement in
Figure~\ref{fig:ts-types:pool-clean}. The type of this transition is similar
to the other $\PState$ transition type we defined earlier, which is triggered
by a signal certificate,
however, this one has an empty signal (as it happens at the boundary).

%%
%% Figure - Pool Clean Defs
%%
\begin{figure}[htb]
  \begin{equation*}
    \_ \vdash \_ \trans{poolclean}{} \_ \in
    \powerset (\Slot \times \PState \times \PState)
  \end{equation*}
  %
  \caption{Pool Clean Transition}
  \label{fig:ts-types:pool-clean}
\end{figure}


We now present the pool-cleanup transition rule in Figure~\ref{fig:rules:pool-clean}.
This rule will be applied whenever there is one or more stake pools scheduled
to retire this epoch. If so, all of the entries in $\var{stpools}$,
$\var{pparams}$, and $\var{retiring}$ which correspond to any of the hash keys
of the stake pools scheduled to retire this epoch are removed from
these variables.

It is important to note here that we \textit{do not} clean up delegations to
retired stake pools. While we do not allow registration to non-existent
stake pools (because that is a meaningless operation likely to be the result
of an error), delegating to a pool that was once active means that there may
be stake associated with this delegation. While this stake becomes inactive when
the pool is retired, the delegations to that pool must remain on the ledger
for potential future use.

%%
%% Figure - Pool Clean Rule
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:pool-clean}
    \inference[Pool-Clean]
    {
      \var{retired} = \var{retiring}^{-1}~\var{(\epoch{slot})}
      & \var{retired} \neq \emptyset \\
      ~ \\
    }
    {
      \begin{array}{l}
        \var{slot}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{stpools} \\
          \var{pparams} \\
          \var{retiring}
        \end{array}
      \right)
      \trans{poolclean}{}
      \left(
        \begin{array}{rcl}
          \var{retired} & \subtractdom & \var{stpools} \\
          \var{retired} & \subtractdom & \var{pparams} \\
          \var{retired} & \subtractdom & \var{retiring} \\
        \end{array}
      \right)
    }
  \end{equation}
  \caption{Pool Clean Inference Rule}
  \label{fig:rules:pool-clean}
\end{figure}


Finally, reaching the epoch boundary may trigger a change in the protocol
constants. Besides the current slot number, delegation and pool states, the
protocol constant environment includes the old and new protocol constants.
The state change is a change of the $\UTxOState$ and the $\Accnt$ states.
The type of this state transition is given in Figure~\ref{fig:ts-types:new-proto-consts}.

%%
%% Figure - New Proto Consts Defs
%%
\begin{figure}[htb]
  \emph{New Proto Consts environment}
  \begin{equation*}
    \NewProtoConstsEnv =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pcOld} & \PrtclConsts & \text{old protocol constants}\\
        \var{pcNew} & \PrtclConsts & \text{new protocol constants}\\
        \var{dstate} & \DState & \text{delegation state}\\
        \var{pstate} & \PState & \text{pool state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{New Proto Consts States}
  \begin{equation*}
    \NewProtoConstsState =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{utxoSt} & \UTxOState & \text{utxo state}\\
        \var{accnt} & \Accnt & \text{accounting}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{New Proto Consts transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{newpc}{} \var{\_}
    \subseteq \powerset (\NewProtoConstsEnv \times
    \NewProtoConstsState \times \NewProtoConstsState)
  \end{equation*}
  %
  \caption{New Proto Consts transition-system types}
  \label{fig:ts-types:new-proto-consts}
\end{figure}


The inference rule for changing protocol constants does one of the following:

\begin{itemize}
\item if there are more (or the same amount of) total possible refunds
available calculated based on the old protocol constants than the new ones,
moves the difference between the two values into the $\var{reserves}$
from the $\var{deposits}$ variable, \textit{or}

\item if there are more refunds available based on the new constants, it moves
the difference between the two calculations from $\var{deposits}$
to $\var{reserves}$, \textit{provided that} there is enough coin in the
$\var{reserves}$ to cover the entire value of the transfer
\end{itemize}

This update of protocol constants ensures that any time a deposit refund is
requested, the necessary amount of funds is available in the $\var{deposits}$
pool.

Note that here, unlike most of the inference rules in this document,
the $\var{utsoSt'}$ and the $\var{accnt'}$ do not come from valid UTxO or
accounts transitions in the antecedent. We simply define the consequent
transition using these directly (instead of listing all the fields in both
states in the consequent transition). It is done this way here
for ease of reading.

%%
%% Figure - New Proto Consts Rule
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:new-pc}
    \inference[New-Proto-Consts]
    {
      \var{oblgOld} = \obligation{pcOld}{stkeys}{stpools}{slot} \\
      \var{oblgNew} = \obligation{pcNew}{stkeys}{stpools}{slot} \\
      ~\\
      \var{reserves} + \var{oblgOld} \geq \var{oblgNew}\\
      \var{diff} = \var{oblgOld} - \var{oblgNew} \\
      ~\\
      \var{utxoSt'} =
      \left(
        {
          \begin{array}{r}
            \var{utxo} \\
            \var{oblgNew} \\
            \var{fees} \\
          \end{array}
        }
      \right)
      &
      \var{accnt'} =
      \left(
        {
          \begin{array}{r}
            \var{treasury} \\
            \var{reserves} + \var{diff} \\
            \var{rewardPool} \\
            \var{rewards} \\
          \end{array}
        }
      \right)
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pc}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{r}
          \var{utxoSt} \\
          \var{accnt}
        \end{array}
      \right)
      \trans{newpc}{}
      \left(
        \begin{array}{rcl}
          \var{utxoSt'}\\
          \var{accnt'} \\
        \end{array}
      \right)
    }
  \end{equation}
  \caption{New Proto Consts Inference Rule}
  \label{fig:rules:new-proto-consts}
\end{figure}


Finally, it is possible to define the complete epoch boundary transition type. It
In the environment of this transition, we have the slot number, blocks produced
this epoch, and both the old and the new protocol constants. The state is
made up of the accounting state, the UTxO, the delegation state and the
pool state.

%%
%% Figure - Epoch Defs
%%
\begin{figure}[htb]
  \emph{Epoch environment}
  \begin{equation*}
    \EpochEnv =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pcOld} & \PrtclConsts & \text{old protocol constants}\\
        \var{pcNew} & \PrtclConsts & \text{new protocol constants}\\
        \var{production} & \Production & \text{blocks produced in the epoch}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Epoch States}
  \begin{equation*}
    \EpochState =
    \left(
      \begin{array}{r@{~\in~}ll}
        \var{utxoSt} & \UTxOState & \text{utxo state}\\
        \var{accnt} & \Accnt & \text{accounting}\\
        \var{dstate} & \DState & \text{delegation state}\\
        \var{pstate} & \PState & \text{pool state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Epoch transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{epoch}{} \var{\_}
    \subseteq \powerset (\EpochEnv \times \EpochState \times \EpochState)
  \end{equation*}
  %
  \caption{Epoch transition-system types}
  \label{fig:ts-types:epoch}
\end{figure}


The epoch transition rule is a composition of all the state transition rules
we have defined above. That is, whenever the UTXOEP, ACCNT, POOLCLEAN, and
NEWPC are all valid transitions between their respective pairs of sets of
state variables, the total transition epoch boundary ledger state transition
is a composition of these four rules in that order.

Note that the slot number used as \textit{current slot number}
for the epoch boundary calculations where a slot number is required is set to
be the \textit{last slot of the epoch before the boundary}.

%%
%% Figure - Epoch Rule
%%
\begin{figure}[htb]
  \begin{equation}\label{eq:epoch}
    \inference[Epoch]
    {
      {
        \begin{array}{l}
          \var{slot}\\
          \var{pcOld}\\
          \var{dstate}\\
          \var{pstate}\\
        \end{array}
      }
      \vdash \var{utxoSt} \trans{utxoep}{} \var{utxoSt'}
      \\~\\~\\
      {
        \begin{array}{l}
          \var{production}\\
          \var{slot}\\
          \var{pcOld}\\
          \var{utxoSt'}\\
          \var{pstate}\\
        \end{array}
      }
      \vdash
      \left(
        {
          \begin{array}{r}
            \var{accnt} \\
            \var{dstate} \\
          \end{array}
        }
      \right)
      \trans{accnt}{}
      \left(
      {
        \begin{array}{rcl}
          \var{accnt'} \\
          \var{dstate'} \\
        \end{array}
      }
      \right)
      \\~\\~\\
      {
        \begin{array}{l}
          \var{slot}\\
          \var{pcOld}\\
        \end{array}
      }
      \vdash
      \left(
        {
          \begin{array}{r}
            \var{pstate} \\
          \end{array}
        }
      \right)
      \trans{poolclean}{}
      \left(
      {
        \begin{array}{rcl}
            \var{pstate'} \\
        \end{array}
      }
      \right)
      \\~\\~\\
      {
        \begin{array}{l}
          \var{slot}\\
          \var{pcOld}\\
          \var{pcNew}\\
          \var{dstate'}\\
          \var{pstate'}\\
        \end{array}
      }
      \vdash
      \left(
        {
          \begin{array}{r}
            \var{utxoSt'} \\
            \var{accnt'} \\
          \end{array}
        }
      \right)
      \trans{newpc}{}
      \left(
      {
        \begin{array}{rcl}
            \var{utxoSt''} \\
            \var{accnt''} \\
        \end{array}
      }
      \right)
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pcOld}\\
        \var{pcNew}\\
        \var{production}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxoSt} \\
        \var{accnt} \\
        \var{dstate} \\
        \var{pstate}
      \end{array}
      \right)
      \trans{epoch}{}
      \left(
      \begin{array}{rcl}
        \var{utxoSt''} \\
        \var{accnt''} \\
        \var{dstate'} \\
        \var{pstate'}
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Epoch Inference Rule}
  \label{fig:rules:epoch}
\end{figure}
