\section{Blockchain layer}
\label{sec:chain}

\newcommand{\Seed}{\type{Seed}}
\newcommand{\seedOp}{\star}
\newcommand{\Proof}{\type{Proof}}
\newcommand{\Seedl}{\mathsf{Seed}_\ell}
\newcommand{\Seede}{\mathsf{Seed}_\eta}
\newcommand{\SlotsPrior}{\mathsf{SlotsPrior}}
\newcommand{\StartRewards}{\mathsf{StartRewards}}
\newcommand{\ActiveSlotCoeff}{\mathsf{ActiveSlotCoeff}}
\newcommand{\slotToSeed}[1]{\fun{slotToSeed}~ \var{#1}}

\newcommand{\Bool}{\type{Bool}}
\newcommand{\T}{\type{T}}
\newcommand{\vrf}[3]{\fun{vrf}_{#1} ~ #2 ~ #3}
\newcommand{\verifyVrf}[4]{\fun{verifyVrf}_{#1} ~ #2 ~ #3 ~#4}

\newcommand{\HashHeader}{\type{HashHeader}}
\newcommand{\bhHash}[1]{\fun{bhHash}~ \var{#1}}
\newcommand{\bHeaderSize}[1]{\fun{bHeaderSize}~ \var{#1}}
\newcommand{\bSize}[1]{\fun{bSize}~ \var{#1}}
\newcommand{\bBodySize}[1]{\fun{bBodySize}~ \var{#1}}
\newcommand{\OCert}{\type{OCert}}
\newcommand{\BHeader}{\type{BHeader}}
\newcommand{\BHBody}{\type{BHBody}}

\newcommand{\bheader}[1]{\fun{bheader}~\var{#1}}
\newcommand{\hsig}[1]{\fun{hsig}~\var{#1}}
\newcommand{\bprev}[1]{\fun{bprev}~\var{#1}}
\newcommand{\bhash}[1]{\fun{bhash}~\var{#1}}
\newcommand{\bsig}[1]{\fun{bsig}~\var{#1}}
\newcommand{\bissuer}[1]{\fun{bissuer}~\var{#1}}
\newcommand{\bseedl}[1]{\fun{bseed}_{\ell}~\var{#1}}
\newcommand{\bprfn}[1]{\fun{bprf}_{n}~\var{#1}}
\newcommand{\bseedn}[1]{\fun{bseed}_{n}~\var{#1}}
\newcommand{\bprfl}[1]{\fun{bprf}_{\ell}~\var{#1}}
\newcommand{\bocert}[1]{\fun{bocert}~\var{#1}}

\newcommand{\PraosEnv}{\type{PraosEnv}}
\newcommand{\PraosState}{\type{PraosState}}
\newcommand{\BHeaderEnv}{\type{BHeaderEnv}}
\newcommand{\BHeaderState}{\type{BHeaderState}}
\newcommand{\VRFEnv}{\type{VRFEnv}}
\newcommand{\VRFState}{\type{VRFState}}
\newcommand{\NewEpochEnv}{\type{NewEpochEnv}}
\newcommand{\NewEpochState}{\type{NewEpochState}}
\newcommand{\PoolDistr}{\type{PoolDistr}}
\newcommand{\BBodyEnv}{\type{BBodyEnv}}
\newcommand{\BBodyState}{\type{BBodyState}}
\newcommand{\RUpdEnv}{\type{RUpdEnv}}
\newcommand{\ChainEnv}{\type{ChainEnv}}
\newcommand{\ChainState}{\type{ChainState}}
\newcommand{\ChainSig}{\type{ChainSig}}


\begin{note}
  This section is a work in progress.
  See \cite{ouroboros_praos}.
\end{note}

This chapter introduces the view of the blockchain layer as required for the
ledger. This includes in particular the information required for the epoch
boundary and its rewards calculation as described in Section~\ref{sec:epoch}. It
also covers the transitions that keep track of produced blocks in order to
calculate rewards and penalties for stake pools.

The main transition rule is $\mathsf{CHAIN}$ which calls the subrules
$\mathsf{NEWEPOCH}$ and $\mathsf{UPDN}$, $\mathsf{VRF}$ and $\mathsf{BBODY}$.

\subsection{Verifiable Random Functions (VRF)}
\label{sec:defs-vrf}

\begin{figure}[htb]
  %
  \emph{Abstract types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{seed} & \Seed  & \text{seed for pseudo-random number generator}\\
      \var{prf} & \Proof  & \text{VRF proof}\\
    \end{array}
  \end{equation*}
  %
  \emph{Abstract functions ($T$ an arbitrary type)}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \seedOp & \Seed \to \Seed \to \Seed & \text{monoidial seed operation} \\
      \vrf{\T}{}{} & \SKey \to \Seed \to \T\times\Proof
                   & \text{verifiable random function} \\
                   %
      \verifyVrf{\T}{}{}{} & \VKey \to \Seed \to \T\times\Proof \to \Bool
                           & \text{verify vrf proof} \\
                           %
    \end{array}
  \end{equation*}
  %
  \emph{Constraints}
  \begin{align*}
    & \forall (sk, vk) \in \KeyPair,~ seed \in \Seed,~
    \verifyVrf{T}{vk}{seed}{\left(\vrf{T}{sk}{seed}\right)}
  \end{align*}
  %
  \emph{Constants}
  \begin{align*}
    & \Seedl \in \Seed & \text{leader seed constant} \\
    & \Seede \in \Seed & \text{nonce seed constant}\\
    & \SlotsPrior \in \Duration & \tau\text{ in \cite{ouroboros_praos}}\\
    & \StartRewards \in \Duration & \text{duration to start reward calculations}\\
    & \ActiveSlotCoeff \in \unitInterval & f\text{ in \cite{ouroboros_praos}}\\
  \end{align*}

  \caption{VRF definitions}
  \label{fig:defs-vrf}
\end{figure}

\begin{question}
  Are there any constraints on $\seedOp$?
\end{question}

\begin{question}
  What are good values for $\SlotsPrior$, $\StartRewards$, and $\ActiveSlotCoeff$?
  Which are better as a constant or a protocol parameter?
  % $2\cdot\fun{stableAfter}$?
\end{question}

\clearpage

\subsection{Block Definitions}
\label{sec:defs-blocks}

\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{h} & \HashHeader & \text{hash of a block header}\\
    \end{array}
  \end{equation*}
  %
  \emph{Operational Certificate}
  %
  \begin{equation*}
    \OCert =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{vk_{hot}} & \VKeyEv & \text{operational (hot) key}\\
        \var{n} & \N & \text{counter}\\
        c_0 & \KESPeriod & \text{start KES period}\\
        \sigma & \Sig & \text{cold key signature}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Block Header Body}
  %
  \begin{equation*}
    \BHBody =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{prev} & \HashHeader & \text{hash of previous block body}\\
        \var{vk} & \VKey & \text{block issuer}\\
        \var{slot} & \Slot & \text{block slot}\\
        \eta & \Seed & \text{nonce}\\
        \var{prf}_{\eta} & \Proof & \text{nonce proof}\\
        \ell & \unitInterval & \text{leader election value}\\
        \var{prf_{\ell}} & \Proof & \text{leader election proof}\\
        \var{sig} & \Sig & \text{block body signature}\\
        \var{oc} & \OCert & \text{operational certificate}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Block Types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{bh}
      & \BHeader
      & \BHBody \times \Sig
      \\
      \var{b}
      & \Block
      & \BHeader \times \seqof{\Tx}
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \bhHash{} & \BHeader \to \HashHeader
                   & \text{hash of a block header} \\
      \bHeaderSize{} & \BHeader \to \N
                   & \text{size of a block header} \\
      \bBodySize{} & \seqof{\Tx} \to \N
                   & \text{size of a block body} \\
      \slotToSeed{} & \Slot \to \Seed
                    & \text{convert a slot to a seed} \\
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{bheader} & \Block \to \BHeader \\
      \fun{bhbody} & \Block \to \BHBody \\
      \fun{hsig} & \BHeader \to \Sig\\
      \fun{bbody} & \Block \to \seqof{\Tx} \\
      \fun{bprev} & \BHBody \to \HashHeader\\
      \fun{bissuer} & \BHBody \to \VKey\\
      \fun{bslot} & \BHBody \to \Slot\\
      \fun{bnonce} & \BHBody \to \Seed\\
      \fun{bprf}_\eta & \BHBody \to \Proof\\
      \fun{bleader} & \BHBody \to \unitInterval\\
      \fun{bprf}_\ell & \BHBody \to \Proof\\
      \fun{bsig} & \BHBody \to \Sig \\
      \fun{bocert} & \BHBody \to \OCert \\
    \end{array}
  \end{equation*}
  %
  \caption{Block Definitions}
  \label{fig:defs:blocks}
\end{figure*}

\clearpage

\subsection{New Epoch Transition}
\label{sec:new-epoch-trans}

For the transition to a new epoch ($\mathsf{NEWEPOCH}$), the environment is
given in Figure~\ref{fig:ts-types:newepoch}, it consists of

\begin{itemize}
\item The epoch nonce.
\item The new protocol parameters.
\item An optional rewards update.
\end{itemize}
The new epoch state is given in Figure~\ref{fig:ts-types:newepoch}, it consists
of

\begin{itemize}
\item The number of the last epoch.
\item The old epoch nonce.
\item The information about produced blocks for each stake pool.
\item The old epoch state.
\item An optional rewards update.
\item The stake pool distribution of the epoch.
\end{itemize}

\begin{note}
  Where is \PoolDistr defined?
\end{note}

\begin{figure}
  \emph{New Epoch environments}
  \begin{equation*}
    \NewEpochEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \eta_1 & \Seed & \text{epoch nonce} \\
        \var{pp_n} & \PParams & \text{new protocol parameters} \\
        \var{ru} & \RewardUpdate^? & \text{potential reward update} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{New Epoch states}
  \begin{equation*}
    \NewEpochState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{e_\ell} & \Epoch & \text{last epoch} \\
        \eta_0 & \Seed & \text{epoch nonce} \\
        \var{b} & \BlocksMade & \text{blocks made} \\
        \var{es} & \EpochState & \text{epoch state} \\
        \var{ru} & \RewardUpdate^? & \text{reward update} \\
        \var{pd} & \PoolDistr & \text{pool stake distribution} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{New Epoch Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{newepoch}{\_} \var{\_} \subseteq
    \powerset (\NewEpochEnv \times \NewEpochState \times \Epoch \times \NewEpochState)
  \end{equation*}
  \caption{NewEpoch transition-system types}
  \label{fig:ts-types:newepoch}
\end{figure}

Figure~\ref{fig:rules:not-new-epoch} defines the new epoch state transition. It
has two rules: the first one is the case of the epoch signal $e$ is before the
current epoch \var{e_\ell}. This rule does not change the state. The second rule
describes the change in the case of $e$ being equal to the next epoch
$e_\ell+ 1$. It also calls the $\mathsf{EPOCH}$ rule.

In the second case, the new epoch state is updated as follows:

\begin{itemize}
\item The epoch is set to the new epoch $e$.
\item The epoch nonce is replaced with the new one from the new epoch
  environment.
\item The mapping for the blocks produced by each stake pool is set to the empty
  map.
\item The epoch state is updated first with the rewards update \var{ru} and then
  via the call to $\mathsf{EPOCH}$.
\item The rewards update to set to \Nothing.
\item The pool distribution is updated according to the changes in the stake
  pools.
\end{itemize}

The new pool distribution \var{pd}' is calculated from the delegation map and
stake allocation of the previous epoch. It associates every stake pool key
($\HashKey_{pool}$) to which a staking key ($\HashKey_{stake}$) delegates with
the stake that $\HashKey_{stake}$ has. The sum of all stake the staking keys
delegating to $\HashKey_{pool}$ then becomes the new entry of $\HashKey_{pool}$
in the pool distribution.

\begin{figure}[ht]
  \begin{equation}\label{eq:new-epoch}
    \inference[New-Epoch]
    {
      e = e_\ell + 1
      &
      \var{es}' \leteq \fun{applyRUpd}~\var{ru}~\var{es}
      \\
      {
        \left(
          {\begin{array}{c}
              \var{e} \\
              \var{pp}_n \\
              \var{b} \\
          \end{array}}
        \right)
        \vdash
        \var{es'}\trans{epoch}{\var{e}}\var{es''}
      }
      \\~\\~\\
      {\begin{array}{r@{~\leteq~}l}
          (\wcard,~\wcard,~\var{ss},~\wcard) & \var{es} \\
          (\wcard,~\var{pstake_{set}},~\wcard,~\wcard,~\wcard,~\wcard) & \var{ss} \\
          (\var{stake}, \var{delegs}) & \var{pstake_{set}} \\
          \var{pd'} & \fun{aggregate_{+}}~\var{delegs}^{-1}\circ\var{stake}\
      \end{array}}
    }
    {
      \left(
        {\begin{array}{c}
            \eta_1 \\
            \var{pp_n} \\
            \var{ru} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{e_\ell} \\
            \eta_0 \\
            \var{b} \\
            \var{es} \\
            \var{ru} \\
            \var{pd} \\
      \end{array}\right)}
      \trans{newepoch}{\var{e}}
      {\left(\begin{array}{c}
            \varUpdate{\var{e}} \\
            \varUpdate{\eta_1} \\
            \varUpdate{\emptyset} \\
            \varUpdate{\var{es}''} \\
            \varUpdate{\Nothing} \\
            \varUpdate{\var{pd}'} \\
      \end{array}\right)}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:not-new-epoch}
    \inference[Not-New-Epoch]
    {
      e_\ell \neq e + 1
    }
    {
      \left(
        {\begin{array}{c}
            \eta_1 \\
            \var{pp_n} \\
            \var{ru} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{e_\ell} \\
            \eta_0 \\
            \var{b} \\
            \var{es} \\
            \var{ru} \\
            \var{pd} \\
      \end{array}\right)}
      \trans{newepoch}{\var{e}}
      {\left(\begin{array}{c}
            \var{e_\ell} \\
            \eta_0 \\
            \var{b} \\
            \var{es} \\
            \var{ru} \\
            \var{pd} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{New Epoch rules}
  \label{fig:rules:not-new-epoch}
\end{figure}

\begin{question}
  Is $\var{pstake_{set}}$ definitely the correct snapshot to be
  used for leader election in the new epoch?
  See Equation~\ref{eq:new-epoch}
\end{question}

\subsection{Update Nonces Transition}
\label{sec:update-nonces-trans}

\begin{figure}
  \emph{Update Nonce Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{updn}{\_} \var{\_} \subseteq
    \powerset (\Seed \times (\Seed\times\Seed) \times \Slot \times (\Seed\times\Seed))
  \end{equation*}
  \caption{UpdNonce transition-system types}
  \label{fig:ts-types:updnonce}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:update-both}
    \inference[Update-Both]
    {
      s < \firstSlot{((\epoch{s}) + 1) - \SlotsPrior}
    }
    {
      \left(
        {\begin{array}{c}
            \eta \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \eta_v \\
            \eta_c \\
      \end{array}\right)}
      \trans{updn}{\var{s}}
      {\left(\begin{array}{c}
            \varUpdate{\eta_v\seedOp\eta} \\
            \varUpdate{\eta_c\seedOp\eta} \\
      \end{array}\right)}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:only-evolve}
    \inference[Only-Evolve]
    {
      s \geq \firstSlot{((\epoch{s}) + 1) - \SlotsPrior}
    }
    {
      \left(
        {\begin{array}{c}
            \eta \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \eta_v \\
            \eta_c \\
      \end{array}\right)}
      \trans{updn}{\var{s}}
      {\left(\begin{array}{c}
            \varUpdate{\eta_v\seedOp\eta} \\
            \eta_c \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{Update Nonce rules}
  \label{fig:rules:update-nonce}
\end{figure}


\subsection{Block Header Transition}
\label{sec:block-header-trans}

\begin{figure}
  \emph{Operational Certificate Transitions}
  \begin{equation*}
    \vdash \var{\_} \trans{ocert}{\_} \var{\_} \subseteq
    \powerset (\PState \times \BHBody \times \PState)
  \end{equation*}
  \caption{OCert transition-system types}
  \label{fig:ts-types:ocert}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:ocert}
    \inference[OCert]
    {
      (\var{vk_{hot}},~n,~d_{0},~\sigma) \leteq \bocert{bhb}
      &
      \var{vk_{cold}} \leteq \bissuer{bhb}
      &
      \var{hk} \leteq \hashKey{vk_{cold}}
      \\~\\
      c_0 \leq \kesPeriod{\bslot{bhb}} < c_0 + 90
      \\
      \var{hk}\mapsto m\in\var{cs}
      &
      m \leq n
      &
      \mathcal{V}_{\var{vk_{cold}}}{\serialised{(\var{vk_{hot}},~n,~c_0)}}_{\sigma}
    }
    {
      \vdash
      \left(
      \begin{array}{r}
        \var{stpools} \\
        \var{poolParams} \\
        \var{retiring} \\
        \var{avgs} \\
        \var{cs} \\
      \end{array}
      \right)
      \trans{ocert}{\var{bhb}}
      \left(
      \begin{array}{rcl}
        \var{stpools} \\
        \var{poolParams} \\
        \var{retiring} \\
        \var{avgs} \\
        \varUpdate{\var{cs}\unionoverrideRight\{\var{hk}\mapsto n\}} \\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{OCert rules}
  \label{fig:rules:ocert}
\end{figure}

\begin{figure}
  \emph{Block Header environments}
  \begin{equation*}
    \BHeaderEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{s_{now}} & \Slot & \text{current slot (wall-clock)} \\
        \var{pp} & \PParams & \text{protocol parameters} \\
        \var{stpools} & \StakePools & \text{stake pools} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Block Header states}
  \begin{equation*}
    \BHeaderState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{h} & \HashHeader & \text{latest header hash} \\
        \var{s_\ell} & \Slot & \text{last slot} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Block Header Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{bhead}{\_} \var{\_} \subseteq
    \powerset (\BHeaderEnv \times \BHeaderState \times \BHeader \times \BHeaderState)
  \end{equation*}
  \caption{BHeader transition-system types}
  \label{fig:ts-types:bheader}
\end{figure}

\begin{question}
  Is it okay to use wall-clock in the evironment in $\BHeaderEnv$?
  See Figure~\ref{fig:ts-types:bheader}.
\end{question}

\begin{figure}[ht]
  \begin{equation}\label{eq:bheader}
    \inference[BHead]
    {
      (\var{bhb},~\sigma) \leteq \var{bh}
      &
      \var{slot} \leteq \bslot{bh}
      \\
      (\var{vk_{hot}},~\wcard,~\wcard,~\wcard) \leteq \bocert{block}
      \\~\\
      \var{vk_{hot}}\mapsto s_0\in\var{stpools}
      &
      t \leteq \kesPeriod{slot} - \kesPeriod{s_0}
      \\~\\
      \var{s_{last}} < \var{slot} \leq \var{s_{now}}
      &
      \var{h} = \bprev{bh}
      \\
      \mathcal{V}_{\var{vk_{hot}}}{\serialised{txs}}_{\sigma}^{t}
      &
      \bHeaderSize{bh} < \fun{maxBHSize}~\var{pp}
    }
    {
      \left(
        {\begin{array}{c}
            \var{s_{now}} \\
            \var{pp} \\
            \var{stpools} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{h} \\
            \var{s_\ell} \\
      \end{array}\right)}
      \trans{bhead}{\var{bh}}
      {\left(\begin{array}{c}
            \varUpdate{\bhHash{bh}} \\
            \varUpdate{slot} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{BHeader rules}
  \label{fig:rules:bheader}
\end{figure}

\begin{figure}
  \emph{VRF environments}
  \begin{equation*}
    \VRFEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{s_{now}} & \Slot & \text{current slot} \\
        \var{pp} & \PParams & \text{protocol parameters} \\
        \eta_0 & \Seed & \text{epoch nonce} \\
        \var{pd} & \PoolDistr & \text{pool stake distribution} \\
        \var{stpools} & \StakePools & \text{stake pools} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{VRF states}
  \begin{equation*}
    \VRFState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{h} & \HashHeader & \text{latest header hash} \\
        \var{s_\ell} & \Slot & \text{last slot} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{VRF Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{vrf}{\_} \var{\_} \subseteq
    \powerset (\VRFEnv \times \VRFState \times \BHeader \times \VRFState)
  \end{equation*}
  \caption{VRF transition-system types}
  \label{fig:ts-types:vrf}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:vrf}
    \inference[VRF]
    {
      \var{bhb} \leteq \fun{bhbody}~{\var{bh}}
      &
      f \leteq \ActiveSlotCoeff
      \\
      \var{vk} \leteq \bissuer bhb
      &
      \var{ss} \leteq \slotToSeed{\bslot{bhb}}
      \\~\\
      \verifyVrf{\Seed}{vk}{(\eta_0\seedOp ss\seedOp\Seede)}{(\bprfn{bhb})}
      \\
      \verifyVrf{\unitInterval}{vk}{(\eta_0\seedOp ss\seedOp\Seedl)}{(\bprfl{bhb})}
      \\
      \var{vk}\mapsto \sigma\in\var{pd}
      &
      \fun{bleader}~\var{bhb} < 1 - (1 - f)^{\sigma}
      \\~\\
      {
        \left(
          {\begin{array}{c}
             \var{s_{now}} \\
             \var{pp} \\
             \var{stpools} \\
           \end{array}}
        \right)
        \vdash
        \left(
          {\begin{array}{c}
             \var{h} \\
             \var{s_{\ell}} \\
           \end{array}}
        \right)
        \trans{bhead}{\var{bh}}
        \left(
          {\begin{array}{c}
             \var{h}' \\
             \var{s_{\ell}}' \\
           \end{array}}
        \right)
      }
    }
    {
      \left(
        {\begin{array}{c}
            \var{s_{now}} \\
            \var{pp} \\
            \eta_0 \\
            \var{pd} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{h} \\
            \var{s_\ell} \\
      \end{array}\right)}
      \trans{vrf}{\var{bh}}
      {\left(\begin{array}{c}
            \varUpdate{\var{h}'} \\
            \varUpdate{\var{s_\ell}'} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{VRF rules}
  \label{fig:rules:vrf}
\end{figure}

\subsection{Block Body Transition}
\label{sec:block-body-trans}

\begin{figure}
  \emph{BBody Transitions}

  \begin{equation*}
    \_ \vdash \var{\_} \trans{bbody}{\_} \var{\_} \subseteq
    \powerset (\PParams \times (\LState\times\BlocksMade)
    \times \Block \times (\LState\times\BlocksMade))
  \end{equation*}
  \caption{BBody transition-system types}
  \label{fig:ts-types:bbody}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:bbody}
    \inference[Block-Body]
    {
      \var{bhb} \leteq \bhbody{block}
      &
      \var{txs} \leteq \bbody{block}
      &
      \var{vk} \leteq \bissuer{bhb}
      \\
      \bSize{bh} < \fun{maxBBSize}~\var{pp}
      &
      \var{vk}\mapsto n\in (b \unionoverrideLeft \{\var{vk}\mapsto 0\})
      \\~\\
      {
        \left(
          {\begin{array}{c}
             \bslot{bhb} \\
             \var{pp} \\
           \end{array}}
        \right)
        \vdash
             \var{ls} \\
        \trans{ledgers}{\var{txs}}
             \var{ls}' \\
      }
    }
    {
      \left(
        {\begin{array}{c}
            \var{pp} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{ls} \\
            \var{b} \\
      \end{array}\right)}
      \trans{bbody}{\var{block}}
      {\left(\begin{array}{c}
            \varUpdate{\var{ls}'} \\
            \varUpdate{b \unionoverrideRight \{\var{vk}\mapsto n+1\}} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{BBody rules}
  \label{fig:rules:bbody}
\end{figure}


\subsection{Chain Transition}
\label{sec:chain-trans}

\begin{figure}
  \emph{Reward Upda environments}
  \begin{equation*}
    \RUpdEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{b} & \BlocksMade & \text{blocks made} \\
        \var{es} & \EpochState & \text{epoch state} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Reward Update Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{ru}{\_} \var{\_} \subseteq
    \powerset (\RUpdEnv \times \RewardUpdate^? \times \Slot \times \RewardUpdate^?)
  \end{equation*}
  \caption{Reward Update transition-system types}
  \label{fig:ts-types:reward-update}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:reward-update}
    \inference[Reward-Update]
    {
      s > (\firstSlot{\epoch{s}}) + \StartRewards
      &
      ru = \Nothing
      \\~\\
      ru' \leteq \createRUpd{ru}{es}
    }
    {
      \left(
        {\begin{array}{c}
            \var{b} \\
            \var{es} \\
        \end{array}}
      \right)
      \vdash
      \var{ru}\trans{rupd}{\var{slot}}\varUpdate{\var{ru}'}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:no-reward-update}
    \inference[No-Reward-Update]
    {
      ru \neq \Nothing
    }
    {
      \left(
        {\begin{array}{c}
            \var{b} \\
            \var{es} \\
        \end{array}}
      \right)
      \vdash
      \var{ru}\trans{rupd}{\var{slot}}\var{ru}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:reward-too-early}
    \inference[Reward-Too-Early]
    {
      s \leq (\firstSlot{\epoch{s}}) + \StartRewards
    }
    {
      \left(
        {\begin{array}{c}
            \var{b} \\
            \var{es} \\
        \end{array}}
      \right)
      \vdash
      \var{ru}\trans{rupd}{\var{slot}}\var{ru}
    }
  \end{equation}

  \caption{Reward Update rules}
  \label{fig:rules:reward-update}
\end{figure}


\begin{figure}
  \emph{Chain environments}
  \begin{equation*}
    \ChainEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{s_{now}} & \Slot & \text{current slot} \\
        \var{pp_n} & \PParams & \text{new protocol parameters} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Chain states}
  \begin{equation*}
    \ChainState =
    \left(
      \begin{array}{r@{~\in~}lr}
        (\eta_0,~\eta_c,~\eta_v) & \Seed\times\Seed\times\Seed & \text{nonces} \\
        \var{b} & \BlocksMade & \text{blocks made} \\
        \var{s_\ell} & \Slot & \text{last slot} \\
        \var{e_\ell} & \Epoch & \text{lats epoch} \\
        \var{es} & \EpochState & \text{epoch state} \\
        \var{ru} & \RewardUpdate^? & \text{potential reward update} \\
        \var{pd} & \PoolDistr & \text{pool stake distribution} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Chain Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{chain}{\_} \var{\_} \subseteq
    \powerset (\ChainEnv \times \ChainState \times \Block \times \ChainState)
  \end{equation*}
  \caption{Chain transition-system types}
  \label{fig:ts-types:chain}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:chain}
    \inference[Chain]
    {
      \var{bhb} \leteq \bhbody{block}
      &
      \eta \leteq \fun{bnonce}~\var{bhb}
      &
      \var{s} \leteq \bslot{bhb}
      \\~\\
      {
        \left(
          {\begin{array}{c}
              \eta_c \\
              \var{pp_n} \\
              \var{ru} \\
          \end{array}}
        \right)
        \vdash
        {\left(\begin{array}{c}
              \var{e_\ell} \\
              \eta_0 \\
              \var{b} \\
              \var{es} \\
              \var{ru} \\
              \var{pd} \\
        \end{array}\right)}
        \trans{newepoch}{\var{e}}
        {\left(\begin{array}{c}
              \var{e_\ell}' \\
              \eta_0' \\
              \var{b}' \\
              \var{es}'' \\
              \var{ru}' \\
              \var{pd}' \\
        \end{array}\right)}
      }
      &
      {
        \eta \vdash
        {\left(\begin{array}{c}
              \eta_v \\
              \eta_c \\
        \end{array}\right)}
        \trans{updn}{\var{s}}
        {\left(\begin{array}{c}
              \eta_v' \\
              \eta_c' \\
        \end{array}\right)}
      }
      \\~\\
      (\var{acnt}',~\var{pp}',~\var{ss}',~\var{ls}') \leteq \var{es}'
      &
      (\var{us}',~(\var{ds}',~\var{ps'})) \leteq \var{ls}'
      \\
      \vdash\var{ps}'\trans{ocert}{bhb}\var{ps}''
      &
      \var{ls}'' \leteq (\var{us}',~(\var{ds}',~\var{ps}''))
      &
      (\var{stpools},~\wcard,~\wcard,~\wcard,~\wcard) \leteq \var{ps}''
      \\
      {
        \left(
          {\begin{array}{c}
              \var{s_{now}} \\
              \var{pp}' \\
              \eta_0' \\
              \var{pd}' \\
              \var{stpools} \\
          \end{array}}
        \right)
        \vdash
        {\left(\begin{array}{c}
              \var{h} \\
              \var{s_\ell} \\
        \end{array}\right)}
        \trans{vrf}{\var{bh}}
        {\left(\begin{array}{c}
              \var{h}' \\
              \var{s_\ell}' \\
        \end{array}\right)}
      }
      &
      {
        \left(
          {\begin{array}{c}
              \var{b} \\
              \var{ru}' \\
          \end{array}}
        \right)
        \vdash \var{ru}' \trans{ru}{\var{s}} \var{ru}''
      }
      \\
      {
        \var{pp}\vdash
        {\left(\begin{array}{c}
              \var{ls}'' \\
              \var{b'} \\
        \end{array}\right)}
        \trans{bbody}{\var{block}}
        {\left(\begin{array}{c}
              \var{ls}''' \\
              b'' \\
        \end{array}\right)}
      }
      &
      \var{es}'' \leteq (\var{acnt}',~\var{pp}'~\var{ss}'~\var{ls}''')
    }
    {
      \left(
        {\begin{array}{c}
            \var{s_{now}} \\
            \var{pp_n} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            (\eta_0,~\eta_c,~\eta_v) \\
            \var{b} \\
            \var{s_\ell} \\
            \var{e_\ell} \\
            \var{es} \\
            \var{ru} \\
            \var{pd} \\
      \end{array}\right)}
      \trans{chain}{\var{block}}
      {\left(\begin{array}{c}
            \varUpdate{(\eta_0',~\eta_c',~\eta_v')} \\
            \varUpdate{\var{b}''} \\
            \varUpdate{\var{s_\ell}'} \\
            \varUpdate{\var{e_\ell}'} \\
            \varUpdate{\var{es}''} \\
            \varUpdate{\var{ru}''} \\
            \varUpdate{\var{pd}'} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{Chain rules}
  \label{fig:rules:chain}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "ledger-spec"
%%% End:
