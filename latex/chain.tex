\section{Blockchain layer}
\label{sec:chain}

\newcommand{\Seed}{\type{Seed}}
\newcommand{\seedOp}{\star}
\newcommand{\Proof}{\type{Proof}}
\newcommand{\Seedl}{\mathsf{Seed}_\ell}
\newcommand{\Seede}{\mathsf{Seed}_\eta}
\newcommand{\SlotsPrior}{\mathsf{SlotsPrior}}
\newcommand{\StartRewards}{\mathsf{StartRewards}}
\newcommand{\ActiveSlotCoeff}{\mathsf{ActiveSlotCoeff}}
\newcommand{\slotToSeed}[1]{\fun{slotToSeed}~ \var{#1}}

\newcommand{\Bool}{\type{Bool}}
\newcommand{\T}{\type{T}}
\newcommand{\vrf}[3]{\fun{vrf}_{#1} ~ #2 ~ #3}
\newcommand{\verifyVrf}[4]{\fun{verifyVrf}_{#1} ~ #2 ~ #3 ~#4}

\newcommand{\HashHeader}{\type{HashHeader}}
\newcommand{\bhHash}[1]{\fun{bhHash}~ \var{#1}}
\newcommand{\bHeaderSize}[1]{\fun{bHeaderSize}~ \var{#1}}
\newcommand{\bSize}[1]{\fun{bSize}~ \var{#1}}
\newcommand{\bBodySize}[1]{\fun{bBodySize}~ \var{#1}}
\newcommand{\BHeader}{\type{BHeader}}
\newcommand{\BHBody}{\type{BHBody}}

\newcommand{\bheader}[1]{\fun{bheader}~\var{#1}}
\newcommand{\hsig}[1]{\fun{hsig}~\var{#1}}
\newcommand{\bprev}[1]{\fun{bprev}~\var{#1}}
\newcommand{\bhash}[1]{\fun{bhash}~\var{#1}}
\newcommand{\bsig}[1]{\fun{bsig}~\var{#1}}
\newcommand{\bissuer}[1]{\fun{bissuer}~\var{#1}}
\newcommand{\bseedl}[1]{\fun{bseed}_{\ell}~\var{#1}}
\newcommand{\bprfn}[1]{\fun{bprf}_{n}~\var{#1}}
\newcommand{\bseedn}[1]{\fun{bseed}_{n}~\var{#1}}
\newcommand{\bprfl}[1]{\fun{bprf}_{\ell}~\var{#1}}

\newcommand{\PraosEnv}{\type{PraosEnv}}
\newcommand{\PraosState}{\type{PraosState}}
\newcommand{\BHeaderEnv}{\type{BHeaderEnv}}
\newcommand{\BHeaderState}{\type{BHeaderState}}
\newcommand{\VRFEnv}{\type{VRFEnv}}
\newcommand{\VRFState}{\type{VRFState}}
\newcommand{\NewEpochEnv}{\type{NewEpochEnv}}
\newcommand{\NewEpochState}{\type{NewEpochState}}
\newcommand{\PoolDistr}{\type{PoolDistr}}
\newcommand{\BBodyEnv}{\type{BBodyEnv}}
\newcommand{\BBodyState}{\type{BBodyState}}
\newcommand{\RUpdEnv}{\type{RUpdEnv}}
\newcommand{\ChainEnv}{\type{ChainEnv}}
\newcommand{\ChainState}{\type{ChainState}}
\newcommand{\ChainSig}{\type{ChainSig}}


\begin{note}
  This section is a work in progress.
  See \cite{ouroboros_praos}.
\end{note}

\subsection{Verifiable Random Functions (VRF)}
\label{sec:defs-vrf}

\begin{figure}[htb]
  %
  \emph{Abstract types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{seed} & \Seed  & \text{seed for pseudo-random number generator}\\
      \var{prf} & \Proof  & \text{VRF proof}\\
    \end{array}
  \end{equation*}
  %
  \emph{Abstract functions ($T$ an arbitrary type)}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \seedOp & \Seed \to \Seed \to \Seed & \text{monoidial seed operation} \\
      \vrf{\T}{}{} & \SKey \to \Seed \to \T\times\Proof
                   & \text{verifiable random function} \\
                   %
      \verifyVrf{\T}{}{}{} & \VKey \to \Seed \to \T\times\Proof \to \Bool
                           & \text{verify vrf proof} \\
                           %
    \end{array}
  \end{equation*}
  %
  \emph{Constraints}
  \begin{align*}
    & \forall (sk, vk) \in \KeyPair,~ seed \in \Seed,~
    \verifyVrf{T}{vk}{seed}{\left(\vrf{T}{sk}{seed}\right)}
  \end{align*}
  %
  \emph{Constants}
  \begin{align*}
    & \Seedl \in \Seed & \text{leader seed constant} \\
    & \Seede \in \Seed & \text{nonce seed constant}\\
    & \SlotsPrior \in \Duration & \tau\text{ in \cite{ouroboros_praos}}\\
    & \StartRewards \in \Duration & \text{duration to start reward calculations}\\
    & \ActiveSlotCoeff \in \unitInterval & f\text{ in \cite{ouroboros_praos}}\\
  \end{align*}

  \caption{VRF definitions}
  \label{fig:defs-vrf}
\end{figure}

\begin{question}
  Are there any constraints on $\seedOp$?
\end{question}

\begin{question}
  What are good values for $\SlotsPrior$, $\StartRewards$, and $\ActiveSlotCoeff$?
  Which are better as a constant or a protocol parameter?
  % $2\cdot\fun{stableAfter}$?
\end{question}

\clearpage

\subsection{Block Definitions}
\label{sec:defs-blocks}

\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{h} & \HashHeader & \text{hash of a block header}\\
    \end{array}
  \end{equation*}
  %
  \emph{Block Header Body}
  %
  \begin{equation*}
    \BHBody =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{prev} & \HashHeader & \text{hash of previous block body}\\
        \var{vk} & \VKey & \text{block issuer}\\
        \var{slot} & \Slot & \text{block slot}\\
        \eta & \Seed & \text{nonce}\\
        \var{prf}_{\eta} & \Proof & \text{nonce proof}\\
        \ell & \unitInterval & \text{leader election value}\\
        \var{prf_{\ell}} & \Proof & \text{leader election proof}\\
        \var{sig} & \Sig & \text{block body signature}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Block Types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{bh}
      & \BHeader
      & \BHBody \times \Sig
      \\
      \var{b}
      & \Block
      & \BHeader \times \seqof{\Tx}
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \bhHash{} & \BHeader \to \HashHeader
                   & \text{hash of a block header} \\
      \bHeaderSize{} & \BHeader \to \N
                   & \text{size of a block header} \\
      \bBodySize{} & \seqof{\Tx} \to \N
                   & \text{size of a block body} \\
      \slotToSeed{} & \Slot \to \Seed
                    & \text{convert a slot to a seed} \\
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{bheader} & \Block \to \BHeader \\
      \fun{bhbody} & \Block \to \BHBody \\
      \fun{hsig} & \BHeader \to \Sig\\
      \fun{bbody} & \Block \to \seqof{\Tx} \\
      \fun{bprev} & \BHBody \to \HashHeader\\
      \fun{bissuer} & \BHBody \to \VKey\\
      \fun{bslot} & \BHBody \to \Slot\\
      \fun{bnonce} & \BHBody \to \Seed\\
      \fun{bprf}_\eta & \BHBody \to \Proof\\
      \fun{bleader} & \BHBody \to \unitInterval\\
      \fun{bprf}_\ell & \BHBody \to \Proof\\
      \fun{bsig} & \BHBody \to \Sig \\
    \end{array}
  \end{equation*}
  %
  \caption{Block Definitions}
  \label{fig:defs:blocks}
\end{figure*}

\clearpage

\subsection{New Epoch Transition}
\label{sec:new-epoch-trans}

\begin{figure}
  \emph{New Epoch environments}
  \begin{equation*}
    \NewEpochEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \eta_1 & \Seed & \text{epoch nonce} \\
        \var{pp_n} & \PParams & \text{new protocol parameters} \\
        \var{ru} & \RewardUpdate^? & \text{potential reward update} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{New Epoch states}
  \begin{equation*}
    \NewEpochState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{e_\ell} & \Epoch & \text{last epoch} \\
        \eta_0 & \Seed & \text{epoch nonce} \\
        \var{b} & \BlocksMade & \text{blocks made} \\
        \var{es} & \EpochState & \text{epoch state} \\
        \var{ru} & \RewardUpdate^? & \text{reward update} \\
        \var{pd} & \PoolDistr & \text{pool stake distribution} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{New Epoch Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{newepoch}{\_} \var{\_} \subseteq
    \powerset (\NewEpochEnv \times \NewEpochState \times \Epoch \times \NewEpochState)
  \end{equation*}
  \caption{NewEpoch transition-system types}
  \label{fig:ts-types:newepoch}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:new-epoch}
    \inference[New-Epoch]
    {
      e_\ell < e
      &
      \var{es}' \leteq \fun{appleRUpd}~\var{ru}~\var{es}
      \\
      {
        \left(
          {\begin{array}{c}
              \var{e} \\
              \var{pp}_n \\
              \var{b} \\
          \end{array}}
        \right)
        \vdash
        \var{es'}\trans{epoch}{\var{e}}\var{es''}
      }
      \\
      \var{pd'} \leteq \mathsf{TODO}\text{ (calculate the new pool distr from }es''\text{)}
    }
    {
      \left(
        {\begin{array}{c}
            \eta_1 \\
            \var{pp_n} \\
            \var{ru} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{e_\ell} \\
            \eta_0 \\
            \var{b} \\
            \var{es} \\
            \var{ru} \\
            \var{pd} \\
      \end{array}\right)}
      \trans{newepoch}{\var{e}}
      {\left(\begin{array}{c}
            \varUpdate{\var{e}} \\
            \varUpdate{\eta_1} \\
            \varUpdate{\emptyset} \\
            \varUpdate{\var{es}'} \\
            \varUpdate{\Nothing} \\
            \varUpdate{\var{pd}'} \\
      \end{array}\right)}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:not-new-epoch}
    \inference[Not-New-Epoch]
    {
      e_\ell \geq e
    }
    {
      \left(
        {\begin{array}{c}
            \eta_1 \\
            \var{pp_n} \\
            \var{ru} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{e_\ell} \\
            \eta_0 \\
            \var{b} \\
            \var{es} \\
            \var{ru} \\
            \var{pd} \\
      \end{array}\right)}
      \trans{newepoch}{\var{e}}
      {\left(\begin{array}{c}
            \var{e_\ell} \\
            \eta_0 \\
            \var{b} \\
            \var{es} \\
            \var{ru} \\
            \var{pd} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{New Epoch rules}
  \label{fig:rules:not-new-epoch}
\end{figure}

\subsection{Update Nonces Transition}
\label{sec:update-nonces-trans}

\begin{figure}
  \emph{Update Nonce Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{updn}{\_} \var{\_} \subseteq
    \powerset (\Seed \times (\Seed\times\Seed) \times \Slot \times (\Seed\times\Seed))
  \end{equation*}
  \caption{UpdNonce transition-system types}
  \label{fig:ts-types:updnonce}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:update-both}
    \inference[Update-Both]
    {
      s < \firstSlot{((\epoch{s}) + 1) - \SlotsPrior}
    }
    {
      \left(
        {\begin{array}{c}
            \eta \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \eta_v \\
            \eta_c \\
      \end{array}\right)}
      \trans{updn}{\var{s}}
      {\left(\begin{array}{c}
            \varUpdate{\eta_v\seedOp\eta} \\
            \varUpdate{\eta_v\seedOp\eta} \\
      \end{array}\right)}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:only-evolve}
    \inference[Only-Evolve]
    {
      s \geq \firstSlot{((\epoch{s}) + 1) - \SlotsPrior}
    }
    {
      \left(
        {\begin{array}{c}
            \eta \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \eta_v \\
            \eta_c \\
      \end{array}\right)}
      \trans{updn}{\var{s}}
      {\left(\begin{array}{c}
            \varUpdate{\eta_v\seedOp\eta} \\
            \eta_c \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{Update Nonce rules}
  \label{fig:rules:update-nonce}
\end{figure}


\subsection{Block Header Transition}
\label{sec:block-header-trans}

\begin{figure}
  \emph{Block Header environments}
  \begin{equation*}
    \BHeaderEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{s_{now}} & \Slot & \text{current slot (wall-clock)} \\
        \var{pp} & \PParams & \text{protocol parameters} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Block Header states}
  \begin{equation*}
    \BHeaderState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{h} & \HashHeader & \text{latest header hash} \\
        \var{s_\ell} & \Slot & \text{last slot} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Block Header Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{bhead}{\_} \var{\_} \subseteq
    \powerset (\BHeaderEnv \times \BHeaderState \times \BHeader \times \BHeaderState)
  \end{equation*}
  \caption{BHeader transition-system types}
  \label{fig:ts-types:bheader}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:bheader}
    \inference[BHead]
    {
      (\var{bhb},~\sigma) \leteq \var{bh}
      &
      \var{slot} \leteq \bslot{bh}
      &
      \var{vk} \leteq \bissuer{block}
      \\
      \var{s_{last}} < \var{slot} \leq \var{s_{now}}
      &
      \var{h} = \bprev{bh}
      &
      \mathcal{V}_{\var{vk}}{\serialised{txs}}_{\sigma}
      \\
      \bHeaderSize{bh} < \fun{maxBHSize}~\var{pp}
    }
    {
      \left(
        {\begin{array}{c}
            \var{s_{now}} \\
            \var{pp} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{h} \\
            \var{s_\ell} \\
      \end{array}\right)}
      \trans{bhead}{\var{bh}}
      {\left(\begin{array}{c}
            \varUpdate{\bhHash{bh}} \\
            \varUpdate{slot} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{BHeader rules}
  \label{fig:rules:bheader}
\end{figure}

\begin{figure}
  \emph{VRF environments}
  \begin{equation*}
    \VRFEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{s_{now}} & \Slot & \text{current slot} \\
        \var{pp} & \PParams & \text{protocol parameters} \\
        \eta_0 & \Seed & \text{epoch nonce} \\
        \var{pd} & \PoolDistr & \text{pool stake distribution} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{VRF states}
  \begin{equation*}
    \VRFState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{h} & \HashHeader & \text{latest header hash} \\
        \var{s_\ell} & \Slot & \text{last slot} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{VRF Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{vrf}{\_} \var{\_} \subseteq
    \powerset (\VRFEnv \times \VRFState \times \BHeader \times \VRFState)
  \end{equation*}
  \caption{VRF transition-system types}
  \label{fig:ts-types:vrf}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:vrf}
    \inference[VRF]
    {
      \var{bhb} \leteq \fun{bhbody}~{\var{bh}}
      &
      f \leteq \ActiveSlotCoeff
      \\
      \var{vk} \leteq \bissuer bhb
      &
      \var{ss} \leteq \slotToSeed{\bslot{bhb}}
      \\~\\
      \verifyVrf{\Seed}{vk}{(\eta_0\seedOp ss\seedOp\Seede)}{(\bprfn{bhb})}
      \\
      \verifyVrf{\unitInterval}{vk}{(\eta_0\seedOp ss\seedOp\Seedl)}{(\bprfl{bhb})}
      \\
      \var{vk}\mapsto \sigma\in\var{pd}
      &
      \fun{bleader}~\var{bhb} < 1 - (1 - f)^{\sigma}
      \\~\\
      {
        \left(
          {\begin{array}{c}
             \var{s_{now}} \\
             \var{pp} \\
           \end{array}}
        \right)
        \vdash
        \left(
          {\begin{array}{c}
             \var{h} \\
             \var{s_{\ell}} \\
           \end{array}}
        \right)
        \trans{bhead}{\var{bh}}
        \left(
          {\begin{array}{c}
             \var{h}' \\
             \var{s_{\ell}}' \\
           \end{array}}
        \right)
      }
    }
    {
      \left(
        {\begin{array}{c}
            \var{s_{now}} \\
            \var{pp} \\
            \eta_0 \\
            \var{pd} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{h} \\
            \var{s_\ell} \\
      \end{array}\right)}
      \trans{vrf}{\var{bh}}
      {\left(\begin{array}{c}
            \varUpdate{\var{h}'} \\
            \varUpdate{\var{s_\ell}'} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{VRF rules}
  \label{fig:rules:vrf}
\end{figure}

\subsection{Block Body Transition}
\label{sec:block-body-trans}

\begin{figure}
  \emph{BBody Transitions}

  \begin{equation*}
    \_ \vdash \var{\_} \trans{bbody}{\_} \var{\_} \subseteq
    \powerset (\PParams \times (\LState\times\BlocksMade)
    \times \Block \times (\LState\times\BlocksMade))
  \end{equation*}
  \caption{BBody transition-system types}
  \label{fig:ts-types:bbody}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:bbody}
    \inference[Block-Body]
    {
      \var{bhb} \leteq \bhbody{block}
      &
      \var{txs} \leteq \bbody{block}
      &
      \var{vk} \leteq \bissuer{bhb}
      \\
      \bSize{bh} < \fun{maxBBSize}~\var{pp}
      &
      \var{vk}\mapsto n\in (b \unionoverrideLeft \{\var{vk}\mapsto 0\})
      \\~\\
      {
        \left(
          {\begin{array}{c}
             \bslot{bhb} \\
             \var{pp} \\
           \end{array}}
        \right)
        \vdash
             \var{ls} \\
        \trans{ledgers}{\var{txs}}
             \var{ls}' \\
      }
    }
    {
      \left(
        {\begin{array}{c}
            \var{pp} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{ls} \\
            \var{b} \\
      \end{array}\right)}
      \trans{bbody}{\var{block}}
      {\left(\begin{array}{c}
            \varUpdate{\var{ls}'} \\
            \varUpdate{b \unionoverrideRight \{\var{vk}\mapsto n+1\}} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{BBody rules}
  \label{fig:rules:bbody}
\end{figure}


\subsection{Chain Transition}
\label{sec:chain-trans}

\begin{figure}
  \emph{Reward Upda environments}
  \begin{equation*}
    \RUpdEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{b} & \BlocksMade & \text{blocks made} \\
        \var{es} & \EpochState & \text{epoch state} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Reward Update Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{ru}{\_} \var{\_} \subseteq
    \powerset (\RUpdEnv \times \RewardUpdate^? \times \Slot \times \RewardUpdate^?)
  \end{equation*}
  \caption{Reward Update transition-system types}
  \label{fig:ts-types:reward-update}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:reward-update}
    \inference[Reward-Update]
    {
      s > (\firstSlot{\epoch{s}}) + \StartRewards
      &
      ru = \Nothing
      \\~\\
      \mathsf{TODO} \text{ turn the REWARD transition into} \\
      \text{a function from }b\text{ and }es\text{ to }ru
    }
    {
      \left(
        {\begin{array}{c}
            \var{b} \\
            \var{es} \\
        \end{array}}
      \right)
      \vdash
      \var{ru}\trans{rupd}{\var{slot}}\varUpdate{\var{ru}'}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:no-reward-update}
    \inference[No-Reward-Update]
    {
      ru \neq \Nothing
    }
    {
      \left(
        {\begin{array}{c}
            \var{b} \\
            \var{es} \\
        \end{array}}
      \right)
      \vdash
      \var{ru}\trans{rupd}{\var{slot}}\var{ru}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:reward-too-early}
    \inference[Reward-Too-Early]
    {
      s \leq (\firstSlot{\epoch{s}}) + \StartRewards
    }
    {
      \left(
        {\begin{array}{c}
            \var{b} \\
            \var{es} \\
        \end{array}}
      \right)
      \vdash
      \var{ru}\trans{rupd}{\var{slot}}\var{ru}
    }
  \end{equation}

  \caption{Reward Update rules}
  \label{fig:rules:reward-update}
\end{figure}


\begin{figure}
  \emph{Chain environments}
  \begin{equation*}
    \ChainEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{s_{now}} & \Slot & \text{current slot} \\
        \var{pp_n} & \PParams & \text{new protocol parameters} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Chain states}
  \begin{equation*}
    \ChainState =
    \left(
      \begin{array}{r@{~\in~}lr}
        (\eta_0,~\eta_c,~\eta_v) & \Seed\times\Seed\times\Seed & \text{nonces} \\
        \var{b} & \BlocksMade & \text{blocks made} \\
        \var{s_\ell} & \Slot & \text{last slot} \\
        \var{e_\ell} & \Epoch & \text{lats epoch} \\
        \var{es} & \EpochState & \text{epoch state} \\
        \var{ru} & \RewardUpdate^? & \text{potential reward update} \\
        \var{pd} & \PoolDistr & \text{pool stake distribution} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Chain Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{chain}{\_} \var{\_} \subseteq
    \powerset (\ChainEnv \times \ChainState \times \Block \times \ChainState)
  \end{equation*}
  \caption{Chain transition-system types}
  \label{fig:ts-types:chain}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:chain}
    \inference[Chain]
    {
      \var{bhb} \leteq \bhbody{block}
      &
      \eta \leteq \fun{bnonce}~\var{bhb}
      &
      \var{s} \leteq \bslot{bhb}
      \\~\\
      {
        \left(
          {\begin{array}{c}
              \eta_c \\
              \var{pp_n} \\
              \var{ru} \\
          \end{array}}
        \right)
        \vdash
        {\left(\begin{array}{c}
              \var{e_\ell} \\
              \eta_0 \\
              \var{b} \\
              \var{es} \\
              \var{ru} \\
              \var{pd} \\
        \end{array}\right)}
        \trans{newepoch}{\var{e}}
        {\left(\begin{array}{c}
              \var{e_\ell}' \\
              \eta_0' \\
              \var{b}' \\
              \var{es}' \\
              \var{ru}' \\
              \var{pd}' \\
        \end{array}\right)}
      }
      &
      {
        \eta \vdash
        {\left(\begin{array}{c}
              \eta_v \\
              \eta_c \\
        \end{array}\right)}
        \trans{updn}{\var{s}}
        {\left(\begin{array}{c}
              \eta_v' \\
              \eta_c' \\
        \end{array}\right)}
      }
      \\~\\
      (\var{acnt}',~\var{pp}'~\var{ss}'~\var{ls}') \leteq \var{es}'
      \\
      {
        \left(
          {\begin{array}{c}
              \var{s_{now}} \\
              \var{pp}' \\
              \eta_0' \\
              \var{pd}' \\
          \end{array}}
        \right)
        \vdash
        {\left(\begin{array}{c}
              \var{h} \\
              \var{s_\ell} \\
        \end{array}\right)}
        \trans{vrf}{\var{bh}}
        {\left(\begin{array}{c}
              \var{h}' \\
              \var{s_\ell}' \\
        \end{array}\right)}
      }
      &
      {
        \left(
          {\begin{array}{c}
              \var{b} \\
              \var{ru}' \\
          \end{array}}
        \right)
        \vdash \var{ru}' \trans{ru}{\var{s}} \var{ru}''
      }
      \\
      {
        \var{pp}\vdash
        {\left(\begin{array}{c}
              \var{ls'} \\
              \var{b'} \\
        \end{array}\right)}
        \trans{bbody}{\var{block}}
        {\left(\begin{array}{c}
              \var{ls}'' \\
              b'' \\
        \end{array}\right)}
      }
      &
      \var{es}'' \leteq (\var{acnt}',~\var{pp}'~\var{ss}'~\var{ls}'') 
    }
    {
      \left(
        {\begin{array}{c}
            \var{s_{now}} \\
            \var{pp_n} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            (\eta_0,~\eta_c,~\eta_v) \\
            \var{b} \\
            \var{s_\ell} \\
            \var{e_\ell} \\
            \var{es} \\
            \var{ru} \\
            \var{pd} \\
      \end{array}\right)}
      \trans{chain}{\var{block}}
      {\left(\begin{array}{c}
            \varUpdate{(\eta_0',~\eta_c',~\eta_v')} \\
            \varUpdate{\var{b}''} \\
            \varUpdate{\var{s_\ell}'} \\
            \varUpdate{\var{e_\ell}'} \\
            \varUpdate{\var{es}''} \\
            \varUpdate{\var{ru}''} \\
            \varUpdate{\var{pd}'} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{Chain rules}
  \label{fig:rules:chain}
\end{figure}


