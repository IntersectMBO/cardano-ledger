\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{microtype}
\usepackage{mathpazo} % nice fonts
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{extarrows}
\usepackage{slashed}
\usepackage[colon]{natbib}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage{xcolor}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\hypersetup{
  pdftitle={A Simplified Formal Specification of a UTxO Ledger},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

% For notes containing warnings, questions, etc.
\usepackage[tikz]{bclogo}
\newenvironment{question}
  {\begin{bclogo}[logo=\bcquestion, couleur=orange!10, arrondi=0.2]{ QUESTION}}
  {\end{bclogo}}
\newenvironment{todo}
  {\begin{bclogo}[logo=\bcoutil, couleur=red!5, couleurBarre=red, arrondi=0.2]{ TODO}}
    {\end{bclogo}}
\newenvironment{note}
  {\begin{bclogo}[logo=\bcattention, couleur=orange!10, arrondi=0.2]{ NOTE}}
  {\end{bclogo}}

%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
%% Setup for the semantic package
\setpremisesspace{20pt}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\subtractrange}{\mathbin{\slashed{\restrictrange}}}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\trans}[2]{\xlongrightarrow[\textsc{#1}]{#2}}

%%
%% Types
%%
\newcommand{\AddrRWD}{\type{Addr_{rwd}}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\HashKey}{\type{HashKey}}
\newcommand{\Coin}{\type{Coin}}
\newcommand{\Epoch}{\type{Epoch}}
\newcommand{\DState}{\type{DState}}
\newcommand{\PState}{\type{PState}}

\newcommand{\DCert}{\type{DCert}}
\newcommand{\DCertRegKey}{\type{DCert_{regkey}}}
\newcommand{\DCertDeRegKey}{\type{DCert_{deregkey}}}
\newcommand{\DCertDeleg}{\type{DCert_{delegate}}}
\newcommand{\DCertRegPool}{\type{DCert_{regpool}}}
\newcommand{\DCertRetirePool}{\type{DCert_{retirepool}}}

%%
%% Functions
%%
\newcommand{\hash}[1]{\fun{hash}~ \var{#1}}
\newcommand{\RegKey}[1]{\textsc{RegKey}(#1)}
\newcommand{\DeregKey}[1]{\textsc{DeregKey}(#1)}
\newcommand{\Delegate}[1]{\textsc{Delegate}(#1)}
\newcommand{\RegPool}[1]{\textsc{RegPool}(#1)}
\newcommand{\RetirePool}[1]{\textsc{RetirePool}(#1)}
\newcommand{\cauthor}[1]{\fun{author}~ \var{#1}}
\newcommand{\pool}[1]{\fun{pool}~ \var{#1}}
\newcommand{\retire}[1]{\fun{retire}~ \var{#1}}
\newcommand{\addr}[1]{\fun{addr_{rwd}}~ \var{#1}}

%%
%% Constants
%%
\newcommand{\emax}{\mathsf{E_{max}}}

\begin{document}

\title{Delegation Ledger Rules \\
       {\small (Version 0.1)}}
\author{}
%\date{}

\maketitle

\begin{abstract}
This document is a formal specification of the ledger rules for delegation,
as described in \cite{delegation_design}.
Delegation is first specified in isolation.
Afterwards a simple UTxO ledger is added to delegation rules.

This specification describes ledger rules in isolation of the
underlying blockchain protocol, Ouroboros, to the extent possible.
In particular, there is no notion of concurrency or blocks.

\end{abstract}

\tableofcontents
\listoffigures

\subsection*{Version history}

\begin{description}
\item[Version 0.1, October ?, 2018] Initial draft.
\end{description}

\section{Introduction}

We briefly describe the motivation and context for delegation.
The full context is contained in \cite{delegation_design}.

For stake to be active in the blockchain protocol,
(i.e. eligible for participation in the leader election)
the associated verification stake key must be registered
and its staking rights must be delegated to an active stake pool.
\footnote{Individuals who wish to participate in the protocol can
register themselves as a stake pool.}

Stake keys are registered (deregistered) through the use of
registration (deregistration) certificates.
Registered stake keys are delegated through the use of delegation certificates.
Finally, stake pools are registered (retired) through the use of
registration (retirement) certificates.

Stake pool retirement is handled a bit differently than stake key deregistration.
Stake keys are considered inactive as soon as a deregistration certificate
is applied to the ledger state.
Stake pool retirement certificates, however, specify the epoch in
which it will retire.

\section{Notation}

\begin{note}
There is a lot of common notation between our specifications.
We will probably put the common notation in a standalone document
and reference this document here in this section.
\end{note}

We use set theory and predicate logic as our specification language.
Sometimes we define a sets that correspond to types that we intentionally
leave abstract. The interpretation is that any choice will do provided that
the required operations on these sets all work out.

It is worth noting that we use set theoretic functions in two ways: one
that corresponds to the types of computations, and one that corresponds to
finite map data structures.

In \cref{fig:nonstandard-notation} we define some extra operators on relations (including
finite mappings) that are not standard set theory notation.

\begin{figure}
\begin{align*}
  \var{xs} \restrictdom \var{m}
& = \{ x \mapsto y \mid x \mapsto y \in \var{m}, ~ x \in \var{xs} \}
& \text{domain restriction}
\\
  \var{xs} \subtractdom \var{m}
& = \{ x \mapsto y \mid x \mapsto y \in \var{m}, ~ x \notin \var{xs} \}
& \text{domain exclusion}
\\
  \var{m} \restrictrange \var{ys}
& = \{ x \mapsto y \mid x \mapsto y \in \var{m}, ~ y \in \var{ys} \}
& \text{range restriction}
\\
  \var{m} \subtractrange \var{ys}
& = \{ x \mapsto y \mid x \mapsto y \in \var{m}, ~ y \notin \var{ys} \}
& \text{range exclusion}
\end{align*}
\caption{Extra non-standard notation on finite mappings}
\label{fig:nonstandard-notation}
\end{figure}

\section{Delegation in Isolation}

Delegation requires the following to be tracked by the ledger state:
the registered stake keys, the delegation map from registered stake keys to stake
pools, the registered stake pools, and upcoming stake pool retirements.
Additionally, the blockchain protocol rewards eligible stake, and so we must
also include a mapping from active stake keys to rewards.

In \cref{fig:delegation-definitons} we give the delegation primitives,
and in \cref{fig:delegation-transitions} we give the delegation transition rule.

The rules for registering and delegating stake keys are given in \cref{fig:delegation-rules}.
The rules for registering stake pools are given in \cref{fig:pool-rules}.

%%
%% Figure - Delegation Definitions
%%
\begin{figure}
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      a & \AddrRWD & \text{reward address} \\
      vk & \VKey & \text{verification key} \\
      hk & \HashKey & \text{hash of a key} \\
      coin & \Coin & \text{currency value} \\
      epoch & \Epoch & \text{epoch}
    \end{array}
  \end{equation*}
  %
  \emph{Constants}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \emax & \Epoch & \text{epoch bound on pool retirement}
    \end{array}
  \end{equation*}
  %
  \emph{Delegation Certificate types}
  %
  \begin{equation*}
  \begin{array}{r@{}c@{}l}
    \DCert &=& \DCertRegKey \uniondistinct \DCertDeRegKey \uniondistinct \DCertDeleg \\
                &\hfill\uniondistinct\;& \DCertRegPool \uniondistinct \DCertRetirePool \\
    \RegKey{c} \in \DCert &\iff& c \in \DCertRegKey \\
    \DeregKey{c} \in \DCert &\iff& c \in \DCertDeRegKey \\
    \Delegate{c} \in \DCert &\iff& c \in \DCertDeleg \\
    \RegPool{c} \in \DCert &\iff& c \in \DCertRegPool\\
    \RetirePool{c} \in \DCert &\iff& c \in \DCertRetirePool \\
  \end{array}
  \end{equation*}
  %
  \emph{Abstract functions}
  %
  \begin{equation*}
  \begin{array}{r@{~\in~}lr}
  \fun{hash} & \VKey \to \HashKey
  & \text{hashing a key}
  \\
  \fun{addr_{rwd}} & \HashKey \to \AddrRWD
  & \text{address of a hashkey}
  \\
  \fun{author} & \DCert \to \HashKey
  & \text{certificate author}
  \\
  \fun{pool} & \DCertDeleg \to \HashKey
  & \text{pool being delegated to}
  \\
  \fun{retire} & \DCertRetirePool \to \Epoch
  & \text{epoch of pool retirement}
  \end{array}
  \end{equation*}
  %

  \caption{Delegation Definitions}
  \label{fig:delegation-definitons}
\end{figure}

%%
%% Figure - Delegation Transitions
%%
\begin{figure}
  \emph{Delegation States}
  %
  \begin{equation*}
    \begin{array}{l}
    \DState =
    \left(\begin{array}{r@{~\in~}lr}
      \var{stkeys} & \powerset (\HashKey) & \text{registered stake keys}\\
      \var{rewards} & \AddrRWD \mapsto \Coin & \text{rewards}\\
      \var{delegations} & \HashKey \mapsto \HashKey & \text{delegations}\\
    \end{array}\right)
    \\
    \\
    \PState =
    \left(\begin{array}{r@{~\in~}lr}
      \var{stpools} & \HashKey \mapsto \DCertRegPool & \text{registered stake pools}\\
      \var{retiring} & \HashKey \mapsto \Epoch & \text{retiring stake pools}\\
    \end{array}\right)
    \end{array}
  \end{equation*}
  %
  \emph{Delegation Transitions}
  \begin{equation*}
    \_ \trans{deleg}{\_} \_ \in
      \powerset (\DState \times \DCert \times \DState)
  \end{equation*}
  %
  \begin{equation*}
    \_ \vdash \_ \trans{pool}{\_} \_ \in
      \powerset (\Epoch \times \DState \times \DCert \times \DState)
  \end{equation*}
  %
  \caption{Delegation Transitions}
  \label{fig:delegation-transitions}
\end{figure}

%%
%% Figure - Delegation Rules
%%
\begin{figure}
  \centering
  \begin{equation}\label{eq:deleg-reg}
    \inference[Deleg-Reg]
    {
      \RegKey{c} & \cauthor{c} = hk & hk \notin \var{stkeys}
    }
    {
      \left(
      \begin{array}{r}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations}
      \end{array}
      \right)
      \trans{deleg}{\var{c}}
      \left(
      \begin{array}{rcl}
        \var{stkeys} & \union & \{\var{hk}\}\\
        \var{rewards} & \unionoverride & \{\addr \var{hk} \mapsto 0\}\\
        \var{delegations}
      \end{array}
      \right)
    }
  \end{equation}

  \begin{equation}\label{eq:deleg-dereg}
    \inference[Deleg-Dereg]
    {
      \DeregKey{c} & \cauthor{c} = hk & hk \in \var{stkeys}
    }
    {
      \left(
      \begin{array}{r}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations}
      \end{array}
      \right)
      \trans{deleg}{\var{c}}
      \left(
      \begin{array}{rcl}
        \var{stkeys} & \setminus & \{\var{hk}\}\\
        \{\addr \var{hk}\} & \subtractdom & \var{rewards} \\
        \{\var{hk}\} & \subtractdom & \var{delegations}
      \end{array}
      \right)
    }
  \end{equation}

  \begin{equation}\label{eq:deleg-deleg}
    \inference[Deleg-Deleg]
    {
      \Delegate{c} & \cauthor{c} = hk & hk \in \var{stkeys}
    }
    {
      \left(
      \begin{array}{r}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations}
      \end{array}
      \right)
      \trans{deleg}{c}
      \left(
      \begin{array}{rcl}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations} & \unionoverride & \{\var{hk} \mapsto \pool c\}
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Delegation Inference Rules}
  \label{fig:delegation-rules}
\end{figure}

%%
%% Figure - Pool Rules
%%
\begin{figure}
  \begin{equation}\label{eq:pool-reg}
    \inference[Pool-Reg]
    {
      \RegPool{c} & \cauthor{c} = hk
    }
    {
      \var{cepoch} \vdash
      \left(
      \begin{array}{r}
        \var{stpools} \\
        \var{retiring}
      \end{array}
      \right)
      \trans{pool}{c}
      \left(
      \begin{array}{rcl}
        \var{stpools} & \unionoverride & \{\var{hk} \mapsto c\} \\
        \{\var{hk}\} & \subtractdom & \var{retiring} \\
      \end{array}
      \right)
    }
  \end{equation}


  \begin{equation}\label{eq:pool-ret}
    \inference[Pool-Retire]
    {
    \RetirePool{c} & \cauthor{c} = hk & \var{hk} \in \dom \var{stpools} \\
    \var{e} = \retire{c} & \var{cepoch} < \var{e} < \var{cepoch} + \emax
  }
  {
    \var{cepoch} \vdash
    \left(
      \begin{array}{r}
        \var{stpools} \\
        \var{retiring}
      \end{array}
    \right)
    \trans{pool}{c}
    \left(
      \begin{array}{rcl}
        \var{stpools} \\
        \var{retiring} & \unionoverride & \{\var{hk} \mapsto \var{e}\} \\
      \end{array}
    \right)
  }
  \end{equation}

  \begin{equation}\label{eq:pool-reap}
    \inference[Pool-Reap]
    {
      \var{retired} = \var{retiring}^{-1}~\var{cepoch}
      & \var{retired} \neq \emptyset
    }
    {
      \var{cepoch} \vdash
      \left(
      \begin{array}{r}
        \var{stpools} \\
        \var{retiring}
      \end{array}
      \right)
      \trans{pool}{c}
      \left(
      \begin{array}{rcl}
        \var{retired} & \subtractdom & \var{stpools} \\
        \var{retired} & \subtractdom & \var{retiring} \\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Pool Inference Rule}
  \label{fig:pool-rules}
\end{figure}


\section{Delegation with a UTxO Ledger}

\begin{question}
How should the certificates inside a transaction be ordered?
The order in which they appear in the transaction?
\end{question}

\addcontentsline{toc}{section}{References}
\bibliographystyle{plainnat}
\bibliography{references}

\end{document}
