We briefly describe the motivation and context for delegation.
The full context is contained in \cite{delegation_design}.

For stake to be active in the blockchain protocol,
(i.e. eligible for participation in the leader election)
the associated verification stake key must be registered
and its staking rights must be delegated to an active stake pool.
\footnote{Individuals who wish to participate in the protocol can
register themselves as a stake pool.}

Stake keys are registered (deregistered) through the use of
registration (deregistration) certificates.
Registered stake keys are delegated through the use of delegation certificates.
Finally, stake pools are registered (retired) through the use of
registration (retirement) certificates.

Stake pool retirement is handled a bit differently than stake key deregistration.
Stake keys are considered inactive as soon as a deregistration certificate
is applied to the ledger state.
Stake pool retirement certificates, however, specify the epoch in
which it will retire.

Delegation requires the following to be tracked by the ledger state:
the registered stake keys, the delegation map from registered stake keys to stake
pools, the registered stake pools, and upcoming stake pool retirements.
Additionally, the blockchain protocol rewards eligible stake, and so we must
also include a mapping from active stake keys to rewards.

In \cref{fig:delegation-definitons} we give the delegation primitives,
and in \cref{fig:delegation-transitions} we give the delegation transition rule.

The rules for registering and delegating stake keys are given in \cref{fig:delegation-rules}.
The rules for registering stake pools are given in \cref{fig:pool-rules}.

\begin{note}
  The current rules allow for delegation to a non-existent pool.
  Such stake is not eligible for leader election.
  This allows for a clean separation between the rules in
  \cref{fig:delegation-rules} and \cref{fig:pool-rules}.
  We may, however, later choose to enforce that delegation certificates
  target a registered pool. It would then make sense to remove
  mappings in $\var{delegations}$ when stake pools retire.
\end{note}

%%
%% Figure - Delegation Definitions
%%
\begin{figure}
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      a & \AddrRWD & \text{reward address} \\
      slot & \Slot & \text{slot}\\
      dur & \Duration & \text{duration}\\
      epoch & \Epoch & \text{epoch}
    \end{array}
  \end{equation*}
  %
  \emph{Constants}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \emax & \Epoch & \text{epoch bound on pool retirement}
    \end{array}
  \end{equation*}
  %
  \emph{Delegation Certificate types}
  %
  \begin{equation*}
  \begin{array}{r@{}c@{}l}
    \DCert &=& \DCertRegKey \uniondistinct \DCertDeRegKey \uniondistinct \DCertDeleg \\
                &\hfill\uniondistinct\;& \DCertRegPool \uniondistinct \DCertRetirePool \\
    \RegKey{c} \in \DCert &\iff& c \in \DCertRegKey \\
    \DeregKey{c} \in \DCert &\iff& c \in \DCertDeRegKey \\
    \Delegate{c} \in \DCert &\iff& c \in \DCertDeleg \\
    \RegPool{c} \in \DCert &\iff& c \in \DCertRegPool\\
    \RetirePool{c} \in \DCert &\iff& c \in \DCertRetirePool \\
  \end{array}
  \end{equation*}
  %
  \emph{Abstract functions}
  %
  \begin{equation*}
  \begin{array}{r@{~\in~}lr}
  \fun{hashKey} & \VKey \to \HashKey
  & \text{hashKeying a key}
  \\
  \fun{addr_{rwd}} & \HashKey \to \AddrRWD
  & \text{address of a hashKeykey}
  \\
  \fun{author} & \DCert \to \HashKey
  & \text{certificate author}
  \\
  \fun{pool} & \DCertDeleg \to \HashKey
  & \text{pool being delegated to}
  \\
  \fun{retire} & \DCertRetirePool \to \Epoch
  & \text{epoch of pool retirement}
  \\
  \fun{epoch} & \Slot \to \Epoch
  & \text{epoch of a slot}
  \\
    () & \Slot \to \Slot \to \Duration
  & \text{slot duration}
  \end{array}
  \end{equation*}
  %

  \caption{Delegation Definitions}
  \label{fig:delegation-definitons}
\end{figure}

%%
%% Figure - Delegation Transitions
%%
\begin{figure}
  \emph{Delegation States}
  %
  \begin{equation*}
    \begin{array}{l}
    \DState =
    \left(\begin{array}{r@{~\in~}lr}
      \var{stkeys} & \HashKey \mapsto \Slot & \text{registered stake keys to creation time}\\
      \var{rewards} & \AddrRWD \mapsto \Coin & \text{rewards}\\
      \var{delegations} & \HashKey \mapsto \HashKey & \text{delegations}\\
    \end{array}\right)
    \\
    \\
    \PState =
    \left(\begin{array}{r@{~\in~}lr}
      \var{stpools} & \HashKey \mapsto (\DCertRegPool \times \Slot) & \text{registered stake pools to creation time}\\
      \var{retiring} & \HashKey \mapsto \Epoch & \text{retiring stake pools}\\
    \end{array}\right)
    \end{array}
  \end{equation*}
  %
  \emph{Delegation Transitions}
  \begin{equation*}
    \_ \vdash \_ \trans{deleg}{\_} \_ \in
      \powerset (\Slot \times \DState \times \DCert \times \DState)
  \end{equation*}
  %
  \begin{equation*}
    \_ \vdash \_ \trans{pool}{\_} \_ \in
      \powerset (\Slot \times \PState \times \DCert \times \PState)
  \end{equation*}
  %
  \begin{equation*}
    \_ \vdash \_ \trans{poolreap}{} \_ \in
    \powerset (\Slot \times \PState \times \PState)
  \end{equation*}
  %
  \caption{Delegation Transitions}
  \label{fig:delegation-transitions}
\end{figure}

%%
%% Figure - Delegation Rules
%%
\begin{figure}
  \centering
  \begin{equation}\label{eq:deleg-reg}
    \inference[Deleg-Reg]
    {
      \RegKey{c} & \cauthor{c} = hk & hk \notin \var{stkeys}
    }
    {
      \var{slot} \vdash
      \left(
      \begin{array}{r}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations}
      \end{array}
      \right)
      \trans{deleg}{\var{c}}
      \left(
      \begin{array}{rcl}
        \var{stkeys} & \union & \{\var{hk} \mapsto slot\}\\
        \var{rewards} & \unionoverride & \{\addrRw \var{hk} \mapsto 0\}\\
        \var{delegations}
      \end{array}
      \right)
    }
  \end{equation}

  \begin{equation}\label{eq:deleg-dereg}
    \inference[Deleg-Dereg]
    {
      \DeregKey{c} & \cauthor{c} = hk & hk \in \var{stkeys}
    }
    {
      \var{slot} \vdash
      \left(
      \begin{array}{r}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations}
      \end{array}
      \right)
      \trans{deleg}{\var{c}}
      \left(
      \begin{array}{rcl}
        \{\var{hk}\} & \subtractdom & \var{stkeys}\\
        \{\addrRw \var{hk}\} & \subtractdom & \var{rewards} \\
        \{\var{hk}\} & \subtractdom & \var{delegations}
      \end{array}
      \right)
    }
  \end{equation}

  \begin{equation}\label{eq:deleg-deleg}
    \inference[Deleg-Deleg]
    {
      \Delegate{c} & \cauthor{c} = hk & hk \in \var{stkeys}
    }
    {
      \var{slot} \vdash
      \left(
      \begin{array}{r}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations}
      \end{array}
      \right)
      \trans{deleg}{c}
      \left(
      \begin{array}{rcl}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations} & \unionoverride & \{\var{hk} \mapsto \pool c\}
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Delegation Inference Rules}
  \label{fig:delegation-rules}
\end{figure}

%%
%% Figure - Pool Rules
%%
\begin{figure}
  \begin{equation}\label{eq:pool-reg}
    \inference[Pool-Reg]
    {
      \RegPool{c} & \cauthor{c} = hk
    }
    {
      \var{slot} \vdash
      \left(
      \begin{array}{r}
        \var{stpools} \\
        \var{retiring}
      \end{array}
      \right)
      \trans{pool}{c}
      \left(
      \begin{array}{rcl}
        \var{stpools} & \unionoverride & \{\var{hk} \mapsto c\} \\
        \{\var{hk}\} & \subtractdom & \var{retiring} \\
      \end{array}
      \right)
    }
  \end{equation}


  \begin{equation}\label{eq:pool-ret}
    \inference[Pool-Retire]
    {
    \RetirePool{c}
    & \cauthor{c} = hk
    & \var{hk} \in \dom \var{stpools} \\
    \var{e} = \retire{c}
    & \var{cepoch} = \epoch{slot}
    & \var{cepoch} < \var{e} < \var{cepoch} + \emax
  }
  {
    \var{slot} \vdash
    \left(
      \begin{array}{r}
        \var{stpools} \\
        \var{retiring}
      \end{array}
    \right)
    \trans{pool}{c}
    \left(
      \begin{array}{rcl}
        \var{stpools} \\
        \var{retiring} & \unionoverride & \{\var{hk} \mapsto \var{e}\} \\
      \end{array}
    \right)
  }
  \end{equation}

  \begin{equation}\label{eq:pool-reap}
    \inference[Pool-Reap]
    {
      \var{retired} = \var{retiring}^{-1}~\var{(\epoch{slot})}
      & \var{retired} \neq \emptyset
    }
    {
      \var{slot} \vdash
      \left(
      \begin{array}{r}
        \var{stpools} \\
        \var{retiring}
      \end{array}
      \right)
      \trans{poolreap}{}
      \left(
      \begin{array}{rcl}
        \var{retired} & \subtractdom & \var{stpools} \\
        \var{retired} & \subtractdom & \var{retiring} \\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Pool Inference Rule}
  \label{fig:pool-rules}

\end{figure}

\subsection{Witnesses}
\label{sec:delegation-witnesses}

The rule for certificate witnesses is given in
Figure~\ref{fig:rules:delegationw}. The new definitions introduced in this rule
are given in Figure~\ref{fig:defs:delegationw}.

\begin{figure}
  \emph{Abstract types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      tx & \Tx & \text{transaction}\\
      dcb & \DCertBody & \text{certificate body}\\
    \end{array}
  \end{equation*}
  %
  \emph{Abstract functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{dbody} & \DCert \mapsto \DCertBody
      & \text{body of the delegation certificate}\\
      \fun{dwit} & \DCert \mapsto (\VKey \times \Sig)
      & \text{witness for the delegation certificate}\\
      \fun{dcerts} & \Tx \to \DCert
      & \text{delegation certificate in a transaction}\\
    \end{array}
  \end{equation*}
  %
  \emph{Delegation Witnesses environment}
  \begin{equation*}
    \DWEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{tx} & \Tx & \text{transaction}\\
        \var{slot} & \Slot & \text{slot}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Delegation Witnesses state}
  \begin{equation*}
    \DWState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{dstate} & \DState & \text{delegation state}\\
        \var{pstate} & \PState & \text{pool state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Delegation Witnesses Transition}
  \begin{equation*}
    \_ \vdash \_ \trans{delegw}{\_} \_ \in
      \powerset (
        \DWEnv \times \DWState \times \DCert \times \DWState)
  \end{equation*}
  \caption{Delegation witnesses definitions}
  \label{fig:defs:delegationw}
\end{figure}

\begin{figure}
  \emph{Delegation with witness rule}
  \begin{equation}
    \label{eq:deleg-witnesses}
    \inference[Deleg-wit]
    { \dwit{c} = (\var{vk_s}, \sigma)
      & \var{slot} \vdash \var{dstate} \trans{deleg}{c} \var{dstate'}
      & \var{slot} \vdash \var{pstate} \trans{pool}{c} \var{pstate'}
      \\ ~ \\
      \verify{vk_s}{\serialised{(\dbody{c},~\txbody \var{tx})}}{\sigma}
    }
    { \left(
      \begin{array}{r}
        \var{tx} \\
        \var{slot}
      \end{array}
      \right)
      \vdash
      \left(
      \begin{array}{r}
        \var{dstate} \\
        \var{pstate}
      \end{array}
      \right)
      \trans{delegw}{c}
      \left(
      \begin{array}{rcl}
        \var{dstate'} \\
        \var{pstate'}
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Delegation witnesses inference rules}
  \label{fig:rules:delegationw}
\end{figure}

\begin{figure}
  \begin{equation}
    \inference[Seq-delg-base]
    {}
    {
      \begin{array}{r}
        \var{tx}\\
        \var{slot}
      \end{array}
      \vdash
      \var{dwstate}
      \trans{delegs}{\epsilon}
      \var{dwstate'}
    }
    \label{eq:rule:sequence-delegation-base}
  \end{equation}

  \begin{equation}
    \inference[Seq-delg-ind]
    {
      {
        \begin{array}{r}
          \var{tx}\\
          \var{slot}\\
        \end{array}
      }
      \vdash
      \var{dwstate}
      \trans{delegs}{\Gamma}
      \var{dwstate'}
    \\ ~ \\
    {
      \begin{array}{r}
        \var{tx}\\
        \var{slot}\\
      \end{array}
    }
    \vdash
      \var{dwstate'}
      \trans{delegw}{c}
      \var{dwstate''}
    }
    {
      \var{dwstate}
      \trans{delegs}{\Gamma; c}
      \var{dwstate''}
    }
    \label{eq:rule:sequence-delegation-inductive}
  \end{equation}
  \caption{Delegation sequence rules}
  \label{fig:rules:delegation-sequence}
\end{figure}

\begin{todo}
  How should we integrate the \textsc{poolreap} transition? It is conceptually
  different from the others, as it does not require a certificate, but is only
  slot / epoch dependent.
\end{todo}
