%%
%% Types
%%
\newcommand{\AddrRWD}{\type{Addr_{rwd}}}
\newcommand{\DState}{\type{DState}}
\newcommand{\PState}{\type{PState}}

\newcommand{\DCert}{\type{DCert}}
\newcommand{\DCertRegKey}{\type{DCert_{regkey}}}
\newcommand{\DCertDeRegKey}{\type{DCert_{deregkey}}}
\newcommand{\DCertDeleg}{\type{DCert_{delegate}}}
\newcommand{\DCertRegPool}{\type{DCert_{regpool}}}
\newcommand{\DCertRetirePool}{\type{DCert_{retirepool}}}

%%
%% Functions
%%
\newcommand{\RegKey}[1]{\textsc{RegKey}(#1)}
\newcommand{\DeregKey}[1]{\textsc{DeregKey}(#1)}
\newcommand{\Delegate}[1]{\textsc{Delegate}(#1)}
\newcommand{\RegPool}[1]{\textsc{RegPool}(#1)}
\newcommand{\RetirePool}[1]{\textsc{RetirePool}(#1)}
\newcommand{\cauthor}[1]{\fun{author}~ \var{#1}}
\newcommand{\pool}[1]{\fun{pool}~ \var{#1}}
\newcommand{\retire}[1]{\fun{retire}~ \var{#1}}
\newcommand{\addrRw}[1]{\fun{addr_{rwd}}~ \var{#1}}

%%
%% Constants
%%
\newcommand{\emax}{\mathsf{E_{max}}}

We briefly describe the motivation and context for delegation.
The full context is contained in \cite{delegation_design}.

Stake is said to be \textit{active} in the blockchain protocol
when it is eligible for participation in the leader election. In order for
stake to become active,
the associated verification stake key must be registered
and its staking rights must be delegated to an active stake pool.
Individuals who wish to participate in the protocol can
register themselves as a stake pool.

Stake keys are registered (deregistered) through the use of
registration (deregistration) certificates.
Registered stake keys are delegated through the use of delegation certificates.
Finally, stake pools are registered (retired) through the use of
registration (retirement) certificates.

Stake pool retirement is handled a bit differently than stake key deregistration.
Stake keys are considered inactive as soon as a deregistration certificate
is applied to the ledger state.
Stake pool retirement certificates, however, specify the epoch in
which it will retire.

\begin{note}
  Pool registration certificate data is kept as long as the pool is registered.
  Should this be part of the ledger state in some way?
\end{note}

%Additionally, the blockchain protocol rewards eligible stake, and so in the
%future we will also include a mapping from active stake keys to rewards.


\begin{note}
  The current rules allow for delegation to a non-existent pool.
  Such stake is not eligible for leader election.
  This allows for a clean separation between the rules in
  \cref{fig:delegation-rules} and \cref{fig:pool-rules}.
  We may, however, later choose to enforce that delegation certificates
  target a registered pool. It would then make sense to remove
  mappings in $\var{delegations}$ when stake pools retire.
\end{note}


\subsection{Delegation Definitions}
%%
%% Figure - Delegation Definitions
%%
\begin{figure}
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      a & \AddrRWD & \text{reward address} \\
      epoch & \Epoch & \text{epoch}
    \end{array}
  \end{equation*}
  %
  \emph{Constants}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \emax & \Epoch & \text{epoch bound on pool retirement}
    \end{array}
  \end{equation*}
  %
  \emph{Delegation Certificate types}
  %
  \begin{equation*}
  \begin{array}{r@{}c@{}l}
    \DCert &=& \DCertRegKey \uniondistinct \DCertDeRegKey \uniondistinct \DCertDeleg \\
                &\hfill\uniondistinct\;& \DCertRegPool \uniondistinct \DCertRetirePool \\
    \RegKey{c} \in \DCert &\iff& c \in \DCertRegKey \\
    \DeregKey{c} \in \DCert &\iff& c \in \DCertDeRegKey \\
    \Delegate{c} \in \DCert &\iff& c \in \DCertDeleg \\
    \RegPool{c} \in \DCert &\iff& c \in \DCertRegPool\\
    \RetirePool{c} \in \DCert &\iff& c \in \DCertRetirePool \\
  \end{array}
  \end{equation*}
  %
  \emph{Abstract functions}
  %
  \begin{equation*}
  \begin{array}{r@{~\in~}lr}
  \fun{hash} & \VKey \to \Hash
  & \text{hashing a key}
  \\
  \fun{addr_{rwd}} & \Hash \to \AddrRWD
  & \text{address of a hashkey}
  \\
  \fun{author} & \DCert \to \Hash
  & \text{certificate author}
  \\
  \fun{pool} & \DCertDeleg \to \Hash
  & \text{pool being delegated to}
  \\
  \fun{retire} & \DCertRetirePool \to \Epoch
  & \text{epoch of pool retirement}
  \end{array}
  \end{equation*}
  %

  \caption{Delegation Definitions}
  \label{fig:delegation-definitons}
\end{figure}


In \cref{fig:delegation-definitons} we give the delegation primitives.
The type $\DCert$ is a generic certificate type, which can be a registration,
deregistration or delegation certificate for a key, or a registration/retirement
 certificate for a stake pool. It is denoted as disjoint union in the figure,
one should, however, think of a term of this type as a term of a specific
one of these five subtypes.

The terms $\RegKey$, $\DeregKey$, $\Delegate$, $\RegPool$, $\RetirePool$ are
all predicates on the type $\DCert$. Each of these predicates is true
when applied to a certificate $c \in \DCert$ of the corresponding type.
Using these predicates in defining inference rules ensures $c$ is the correct
type of certificate for the transition
that a rule describes.

The maps $\fun{hash}$, $\fun{addr_{rwd}}$, $\fun{author}$, $\fun{pool}$,
and $\fun{retire}$ are all used to
retrieve specific information about the origin type. The
constant $\emax$ gives the number of epochs a stake pool will take to retire.

Note that the reason for combining the different types of
certificates into a common type is that we may now use that type to define
a single type for all
ledger state transitions having to do with delegation (i.e. $\DState$
transitions),
and, in a very similarly
way, a type for transitions describing stake pool-related ledger updates
(i.e. $\PState$ transitions).

\subsection{Delegation Transitions}

%%
%% Figure - Delegation Transitions
%%
\begin{figure}
  \emph{Delegation States}
  %
  \begin{equation*}
    \begin{array}{l}
    \DState =
    \left(\begin{array}{r@{~\in~}lr}
      \var{stkeys} & \powerset (\Hash) & \text{registered stake keys}\\
      \var{rewards} & \AddrRWD \mapsto \Coin & \text{rewards}\\
      \var{delegations} & \Hash \mapsto \Hash & \text{delegations}\\
    \end{array}\right)
    \\
    \\
    \PState =
    \left(\begin{array}{r@{~\in~}lr}
      \var{stpools} & \Hash \mapsto \DCertRegPool & \text{registered stake pools}\\
      \var{retiring} & \Hash \mapsto \Epoch & \text{retiring stake pools}\\
    \end{array}\right)
    \end{array}
  \end{equation*}
  %
  \emph{Delegation Transitions}
  \begin{equation*}
    \_ \trans{deleg}{\_} \_ \in
      \powerset (\DState \times \DCert \times \DState)
  \end{equation*}
  %
  \begin{equation*}
    \_ \vdash \_ \trans{pool}{\_} \_ \in
      \powerset (\Epoch \times \PState \times \DCert \times \PState)
  \end{equation*}
  %
  \caption{Delegation Transitions}
  \label{fig:delegation-transitions}
\end{figure}


In \cref{fig:delegation-transitions} we give the delegation and stake pool
state transition types. These transitions can be thought of as collections
 of maps between states indexed by certificates (as well the epoch
context, in the case of stake pools).
The one notable
difference between the types of these transitions is the presence of
$cepoch$ in the context of the stake pool transition.

The part of the ledger state keeping track of current delegations, $\DState$,
consists of a set of registered stake keys (the hash keys of those addresses
which delegete to some stake pool), rewards, which are expressed as a finite
map that matches addresses with the rewards belonging to them, and delegations.
Delegations are also expressed by a finite map which associates the stake key
with the hash key of the pool to which it delegates.

The ledger additionally keeps track of the stake pools in a separate state variable
$\PState$.
This state contains a list of registered stake pools indexed by the hash key
of the author they are registered to ($stpools$). It also keeps track of
stake pools in the process of retiring via the variable $retiring$,
which associates
a stake pool hash key with the epoch in which it is supposed to retire.

\subsection{Delegation Rules}

%%
%% Figure - Delegation Rules
%%
\begin{figure}
  \centering
  \begin{equation}\label{eq:deleg-reg}
    \inference[Deleg-Reg]
    {
      \RegKey{c} & \cauthor{c} = hk & hk \notin \var{stkeys}
    }
    {
      \left(
      \begin{array}{r}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations}
      \end{array}
      \right)
      \trans{deleg}{\var{c}}
      \left(
      \begin{array}{rcl}
        \var{stkeys} & \union & \{\var{hk}\}\\
        \var{rewards} & \unionoverride & \{\addrRw \var{hk} \mapsto 0\}\\
        \var{delegations}
      \end{array}
      \right)
    }
  \end{equation}

  \begin{equation}\label{eq:deleg-dereg}
    \inference[Deleg-Dereg]
    {
      \DeregKey{c} & \cauthor{c} = hk & hk \in \var{stkeys}
    }
    {
      \left(
      \begin{array}{r}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations}
      \end{array}
      \right)
      \trans{deleg}{\var{c}}
      \left(
      \begin{array}{rcl}
        \var{stkeys} & \setminus & \{\var{hk}\}\\
        \{\addrRw \var{hk}\} & \subtractdom & \var{rewards} \\
        \{\var{hk}\} & \subtractdom & \var{delegations}
      \end{array}
      \right)
    }
  \end{equation}

  \begin{equation}\label{eq:deleg-deleg}
    \inference[Deleg-Deleg]
    {
      \Delegate{c} & \cauthor{c} = hk & hk \in \var{stkeys}
    }
    {
      \left(
      \begin{array}{r}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations}
      \end{array}
      \right)
      \trans{deleg}{c}
      \left(
      \begin{array}{rcl}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations} & \unionoverride & \{\var{hk} \mapsto \pool c\}
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Delegation Inference Rules}
  \label{fig:delegation-rules}
\end{figure}


The rules for registering and delegating stake keys are given in
\cref{fig:delegation-rules}. The preconditions for the registration of a stake
key ensure that a given certificate $c$ is of the correct type
(i.e. $\DCertRegKey$),
and that the hash key associated with the author of the certificate is not
already found in the current list of stake keys.

In order to delegate to a stake pool, a stake key must first be registered.
When registering a new stake key (the \cref{eq:deleg-reg} inference rule),
the key must be
added to the set of stake keys ($\var{stkeys}$), the rewards for the address
corresponding to that key set to 0, and no new delegations added. Note that
since the hash key corresponding to the address must not have been previously
registered,
it should not have any rewards in its associated address. Thus, it is safe
to set the rewards to 0 using union override (i.e. replace any value previously
associated with this address with 0).

Here we would add the rules for managing rewards beyond assigning
the initial 0 value upon registration.

When deregistering a key (the \cref{eq:deleg-dereg} rule), we again
require that the certificate is of the correct type. If so,
the key must be removed from the $\var{stkeys}$ list,
and all the rewards and delegations associated with this key must be removed
from the $\var{rewards}$ and $\var{delegations}$ parameters also.

Finally, for creating a delegation (the \cref{eq:deleg-deleg} rule),
given that the certificate $c$ is of the correct type, we add to the
$\var{delegations}$ finite map the pair of
the author's hash key and hash key of the pool being delegated to.
The $\var{stkeys}$ and $\var{rewards}$ parameters are kept constant by
this rule. The use of union override here allows us to use the same rule
to perform an update on an existing delegation while keeping the rewards
associated with the key accounted for.

\subsection{Stake Pool Rules}


%%
%% Figure - Pool Rules
%%
\begin{figure}
  \begin{equation}\label{eq:pool-reg}
    \inference[Pool-Reg]
    {
      \RegPool{c} & \cauthor{c} = hk
    }
    {
      \var{cepoch} \vdash
      \left(
      \begin{array}{r}
        \var{stpools} \\
        \var{retiring}
      \end{array}
      \right)
      \trans{pool}{c}
      \left(
      \begin{array}{rcl}
        \var{stpools} & \unionoverride & \{\var{hk} \mapsto c\} \\
        \{\var{hk}\} & \subtractdom & \var{retiring} \\
      \end{array}
      \right)
    }
  \end{equation}


  \begin{equation}\label{eq:pool-ret}
    \inference[Pool-Retire]
    {
    \RetirePool{c} & \cauthor{c} = hk & \var{hk} \in \dom \var{stpools} \\
    \var{e} = \retire{c} & \var{cepoch} < \var{e} < \var{cepoch} + \emax
  }
  {
    \var{cepoch} \vdash
    \left(
      \begin{array}{r}
        \var{stpools} \\
        \var{retiring}
      \end{array}
    \right)
    \trans{pool}{c}
    \left(
      \begin{array}{rcl}
        \var{stpools} \\
        \var{retiring} & \unionoverride & \{\var{hk} \mapsto \var{e}\} \\
      \end{array}
    \right)
  }
  \end{equation}

  \begin{equation}\label{eq:pool-reap}
    \inference[Pool-Reap]
    {
      \var{retired} = \var{retiring}^{-1}~\var{cepoch}
      & \var{retired} \neq \emptyset
    }
    {
      \var{cepoch} \vdash
      \left(
      \begin{array}{r}
        \var{stpools} \\
        \var{retiring}
      \end{array}
      \right)
      \trans{pool}{c}
      \left(
      \begin{array}{rcl}
        \var{retired} & \subtractdom & \var{stpools} \\
        \var{retired} & \subtractdom & \var{retiring} \\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Pool Inference Rule}
  \label{fig:pool-rules}

\end{figure}


The rules for updating the part of the ledger state defining the current stake
pools are given in \cref{fig:pool-rules}. Note
that in all three rules, the current epoch is part of the context. It is not
necessary to include $cepoch$ in the context for \cref{eq:pool-reg}. However,
we decided to include it for consistency and composability of stake pool rules.

For each rule, again, we first check that a given certificate $c$ is of
the correct type using the
corresponding $\RegPool$ and $\RetirePool$ predicates.

The first rule, \cref{eq:pool-reg}, can be used to register a new stake pool, register a
stake pool under a different author ($\fun{author} c$), or stop the retirement
process for that key (the hash key and associated planned retirement epoch
 will be removed from the $retiring$ parameter).

The second rule, \cref{eq:pool-ret}, starts the pool retirement process. Given an
epoch $e$, the application of this rule requires that this epoch is in
the future (after $cepoch$), as well as that it is
and less than $\emax$ epochs after the current one, and also that
the certificate author's key is in the list of registered pools.
This rule simply adds the pair of the key of the
certificate author and the planned retirement epoch $e$ to the $retiring$
parameter.

The third rule, \cref{eq:pool-reap}, is used when the planned retirement epoch $e$ for
a given stake pool in the $\var{retiring}$ set is reached. In this case, all the
pairs associated with hash keys of pools which are scheduled to retire in this
epoch are removed
from both $\var{stpools}$ and $\var{retiring}$.

\begin{note}
$\var{retired}$ and $\var{retiring}$ are both finite maps. For domain exclusion,
we only need the hashes of $\var{retired}$?
\end{note}


\subsection{Witnesses}
\label{sec:delegation-witnesses}

The new definitions needed for updating the ledger state with a given
certificate witnessed by some key-signature pair
are given in Figure~\ref{fig:defs:delegationw}. The $\fun{dwit}$ returns
the witness of a given certificate. The type of the delegation witness
transition in this figure is meant to describe a complete ledger state
transition, including an update of both the delegations and the stake pools
(i.e. $\DState$ as well as the $\PState$).

We include $\var{cepoch}$ in the context because it is needed to update
$\PState$, as well as the transaction $\var{tx}$ which is being witnessed.
Now, such a transition is
composable with any other witnessed ledger state transition.

The rule for certificate witnesses is given in
Figure~\ref{fig:rules:delegationw}. The actual update of the ledger state is
consistent with the rules given in Figures~\ref{fig:delegation-rules}
and~\ref{fig:pool-rules}. However, we now add the following precondition for the
application of these rules:

\begin{itemize}
\item The signature of the transaction must be verified by the
  verification key with which the certificate is associated (i.e. witnessed).
\end{itemize}

\begin{figure}
  \emph{Abstract functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    %  \fun{dbody} & \DCert \mapsto \VKey
    %  & \text{body of the delegation certificate}\\
      \fun{dwit} & \DCert \mapsto (\VKey \times \Sig)
      & \text{witness for the delegation certificate}
    \end{array}
  \end{equation*}
  %
  \emph{Delegation Witnesses Transition}
  \begin{equation*}
    \_ \vdash \_ \trans{delegw}{\_} \_ \in
      \powerset (
        (\Tx \times \Epoch) \times \DState \times \PState
          \times \DCert \times \DState \times \PState)
  \end{equation*}
  \caption{Delegation witnesses definitions}
  \label{fig:defs:delegationw}
\end{figure}

\begin{figure}
  \emph{Delegation with witness rule}
  \begin{equation}
    \label{eq:deleg-witnesses}
    \inference[Deleg-wit]
    { \dwit{c} = (\var{vk_s}, \sigma)
      & \var{dstate} \trans{deleg}{c} \var{dstate'}
      & \var{cepoch} \vdash \var{pstate}
      \trans{pool}{c} \var{pstate'}
      \\ ~ \\
      \mathcal{V}_{\var{vk_s}}{\serialised{tx}}_{\sigma}
      %\verify{vk_s}{\serialised{(\dbody{c},~\var{tx})}}{\sigma}
    }
    { \left(
      \begin{array}{r}
        \var{tx} \\
        \var{cepoch}
      \end{array}
      \right)
      \vdash
      \left(
      \begin{array}{r}
        \var{dstate} \\
        \var{pstate}
      \end{array}
      \right)
      \trans{delegw}{c}
      \left(
      \begin{array}{rcl}
        \var{dstate'} \\
        \var{pstate'}
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Delegation witnesses inference rules}
  \label{fig:rules:delegationw}
\end{figure}
