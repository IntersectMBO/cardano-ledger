\documentclass[11pt,a4paper,dvipsnames]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage[local]{gitinfo2}
\usepackage{iohk}
\usepackage{microtype}
\usepackage{mathpazo} % nice fonts
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{extarrows}
\usepackage{slashed}
\usepackage[colon]{natbib}
\usepackage[unicode=true,pdftex,pdfa,colorlinks=true]{hyperref}
\usepackage{xcolor}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{enumerate}


%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
%% Setup for the semantic package
\setpremisesspace{20pt}

%%
%% Types
%%
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Npos}{\ensuremath{\mathbb{N}^{+}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\Rnn}{\ensuremath{\mathbb{R}^{\geq 0}}}
\newcommand{\Tx}{\type{Tx}}
\newcommand{\TxBody}{\type{TxBody}}
\newcommand{\Ix}{\type{Ix}}
\newcommand{\TxId}{\type{TxId}}
\newcommand{\Addr}{\type{Addr}}
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\Wdrl}{\type{Wdrl}}
\newcommand{\Value}{\type{Value}}
\newcommand{\Coin}{\type{Coin}}
\newcommand{\PParams}{\type{PParams}}
\newcommand{\Slot}{\type{Slot}}
\newcommand{\SlotsPerEpoch}{\mathsf{SlotsPerEpoch}}
\newcommand{\Duration}{\type{Duration}}
\newcommand{\StakePools}{\type{StakePools}}
\newcommand{\StakeKeys}{\type{StakeKeys}}

\newcommand{\DCert}{\type{DCert}}
\newcommand{\DCertRegKey}{\type{DCert_{regkey}}}
\newcommand{\DCertDeRegKey}{\type{DCert_{deregkey}}}
\newcommand{\DCertDeleg}{\type{DCert_{delegate}}}
\newcommand{\DCertRegPool}{\type{DCert_{regpool}}}
\newcommand{\DCertRetirePool}{\type{DCert_{retirepool}}}
\newcommand{\PoolParam}{\type{PoolParam}}
\newcommand{\UTxOState}{\ensuremath{\type{UTxOState}}}
\newcommand{\ledgerState}{\ensuremath{\type{ledgerState}}}

\newcommand{\AddrRWD}{\type{Addr_{rwd}}}
\newcommand{\AddrB}{\type{Addr_{base}}}
\newcommand{\AddrP}{\type{Addr_{ptr}}}
\newcommand{\AddrE}{\type{Addr_{enterprise}}}
\newcommand{\Ptr}{\type{Ptr}}
\newcommand{\DState}{\type{DState}}
\newcommand{\DWEnv}{\type{DWEnv}}
\newcommand{\DPSEnv}{\type{DPSEnv}}
\newcommand{\DPEnv}{\type{DPEnv}}
\newcommand{\DEnv}{\type{DEnv}}
\newcommand{\PEnv}{\type{PEnv}}
\newcommand{\DPState}{\type{DPState}}
\newcommand{\PState}{\type{PState}}
\newcommand{\DCertBody}{\type{DCertBody}}
\newcommand{\TData}{\type{TData}}
\newcommand{\DPoolReap}{\ensuremath{\type{poolreap}}}

%% Adding witnesses
\newcommand{\TxIn}{\type{TxIn}}
\newcommand{\TxOut}{\type{TxOut}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\SKey}{\type{SKey}}
\newcommand{\HashKey}{\type{HashKey}}
\newcommand{\KeyPair}{\type{KeyPair}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
%% Adding delegation
\newcommand{\Epoch}{\type{Epoch}}
\newcommand{\VKeyGen}{\type{VKeyGen}}
%% Blockchain
\newcommand{\Gkeys}{\var{G_{keys}}}
\newcommand{\Block}{\type{Block}}
\newcommand{\SlotId}{\type{SlotId}}
\newcommand{\UTxOEnv}{\type{UTxOEnv}}
\newcommand{\CEEnv}{\type{CEEnv}}
\newcommand{\CEState}{\type{CEState}}
\newcommand{\BDEnv}{\type{BDEnv}}
\newcommand{\BDState}{\type{BDState}}
\newcommand{\LEnv}{\type{LEnv}}
\newcommand{\LState}{\type{LState}}

%%
%% Functions
%%
\newcommand{\txins}[1]{\fun{txins}~ \var{#1}}
\newcommand{\txouts}[1]{\fun{txouts}~ \var{#1}}
\newcommand{\txcerts}[1]{\fun{txcerts}~ \var{#1}}
\newcommand{\txid}[1]{\fun{txid}~ \var{#1}}
\newcommand{\outs}[1]{\fun{outs}~ \var{#1}}
\newcommand{\values}[1]{\fun{values}~ #1}
\newcommand{\ubalance}[1]{\fun{ubalance}~ \var{#1}}
\newcommand{\txttl}[1]{\fun{txttl}~ \var{#1}}
\newcommand{\firstSlot}[1]{\fun{firstSlot}~ \var{#1}}
\newcommand{\deposits}[2]{\fun{deposits}~ \var{#1} ~ \var{#2}}
\newcommand{\decayedKey}[4]{\fun{decayedKey}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\decayedTx}[3]{\fun{decayedTx}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\keyRefund}[6]{\fun{keyRefund}~ {#1}~{#2}~{#3}~\var{#4}~\var{#5}~\var{#6}}
\newcommand{\refund}[4]{\fun{refund}~ \var{#1}~ \var{#2}~ {#3}~ {#4}}
\newcommand{\keyRefunds}[3]{\fun{keyRefunds}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\consumed}[4]{\fun{consumed}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\produced}[2]{\fun{produced}~ \var{#1}~ \var{#2}}
\newcommand{\applyFun}[2]{\fun{#1}~\var{#2}}

\newcommand{\RegKey}[1]{\textsc{RegKey}(#1)}
\newcommand{\DeregKey}[1]{\textsc{DeregKey}(#1)}
\newcommand{\Delegate}[1]{\textsc{Delegate}(#1)}
\newcommand{\RegPool}[1]{\textsc{RegPool}(#1)}
\newcommand{\RetirePool}[1]{\textsc{RetirePool}(#1)}
\newcommand{\cwitness}[1]{\fun{cwitness}~ \var{#1}}
\newcommand{\dpool}[1]{\fun{dpool}~ \var{#1}}
\newcommand{\poolParam}[1]{\fun{poolParam}~ \var{#1}}
\newcommand{\retire}[1]{\fun{retire}~ \var{#1}}
\newcommand{\addrRw}[1]{\fun{addr_{rwd}}~ \var{#1}}
\newcommand{\epoch}[1]{\fun{epoch}~ \var{#1}}
\newcommand{\dcerts}[1]{\fun{dcerts}~ \var{#1}}

%% UTxO witnesses
\newcommand{\inputs}[1]{\fun{inputs}~ \var{#1}}
\newcommand{\txwits}[1]{\fun{txwits}~ \var{#1}}
\newcommand{\verify}[3]{\fun{verify} ~ #1 ~ #2 ~ #3}
\newcommand{\sign}[2]{\fun{sign} ~ #1 ~ #2}
\newcommand{\serialised}[1]{\llbracket \var{#1} \rrbracket}
\newcommand{\hashKey}[1]{\fun{hashKey}~ \var{#1}}
\newcommand{\txbody}[1]{\fun{txbody}~ \var{#1}}
\newcommand{\txfee}[1]{\fun{txfee}~ \var{#1}}
\newcommand{\txwdrls}[1]{\fun{txwdrls}~ \var{#1}}
\newcommand{\minfee}[2]{\fun{minfee}~ \var{#1}~ \var{#2}}
\newcommand{\slotminus}[2]{\var{#1}~-_{s}~\var{#2}}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
% wildcard parameter
\newcommand{\wcard}[0]{\underline{\phantom{a}}}
%% Adding ledgers...
\newcommand{\utxo}[1]{\fun{utxo}~ #1}
%% Delegation
\newcommand{\delegatesName}{\fun{delegates}}
\newcommand{\delegates}[3]{\delegatesName~#1~#2~#3}
\newcommand{\dwho}[1]{\fun{dwho}~\var{#1}}
\newcommand{\depoch}[1]{\fun{depoch}~\var{#1}}
\newcommand{\dval}{\ensuremath{d_{\mathsf{val}}}}
%% Delegation witnesses
\newcommand{\dbody}[1]{\fun{dbody}~\var{#1}}
\newcommand{\dwit}[1]{\fun{dwit}~\var{#1}}
%% Blockchain
\newcommand{\bwit}[1]{\fun{bwit}~\var{#1}}
\newcommand{\bslot}[1]{\fun{bslot}~\var{#1}}
\newcommand{\bbody}[1]{\fun{bbody}~\var{#1}}
\newcommand{\bdlgs}[1]{\fun{bdlgs}~\var{#1}}
%% ledgerstate constants
\newcommand{\genesisId}{\ensuremath{Genesis_{Id}}}
\newcommand{\genesisTxOut}{\ensuremath{Genesis_{Out}}}
\newcommand{\genesisUTxO}{\ensuremath{Genesis_{UTxO}}}
\newcommand{\emax}{\ensuremath{\mathsf{E_{max}}}}

\newcommand{\unitInterval}{\ensuremath{[0,~1]}}
\newcommand{\unitIntervalNonNull}{\ensuremath{(0,~1]}}
\newcommand{\nonnegReals}{\ensuremath{[0,~\infty)}}
\newcommand{\posReals}{\ensuremath{(0,~\infty)}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\theoremstyle{definition}
\newtheorem{property}{Property}[section]

\begin{document}

\input{frontmatter.tex}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}
\input{intro.tex}

\section{Notation}\label{sec:notation}

The transition system is explained in \cite{small_step_semantics}.

\begin{description}
  \item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
    the subsets of $X$.
  \item[Sequences] Given a set $\type{X}$, $\seqof{\type{X}}$ is the set of
    sequences having elements taken from $\type{X}$. The empty sequence is
    denoted by $\epsilon$, and given a sequence $\Lambda$, $\Lambda; \type{x}$ is
    the sequence that results from appending $\type{x} \in \type{X}$ to
    $\Lambda$.
  \item[Functions] $A \to B$ denotes a \textbf{total function} from $A$ to $B$.
    Given a function $f$ we write $f~a$ for the application of $f$ to argument
    $a$.
  \item[Inverse Image] Given a function $f: A \to B$ and $b\in B$, we write
    $f^{-1}~b$ for the \textbf{inverse image} of $f$ at $b$, which is defined by
    $\{a \mid\ f a =  b\}$.
  \item[Maps and partial functions] $A \mapsto B$ denotes a \textbf{partial
    function} from $A$ to $B$, which can be seen as a map (dictionary) with
    keys in $A$ and values in $B$. Given a map $m \in A \mapsto B$, notation
    $a \mapsto b \in m$ is equivalent to $m~ a = b$.
  \item[Map Operations] Figure~\ref{fig:notation:nonstandard}
    describes some non-standard map operations.

\end{description}

In Figure~\ref{fig:notation:nonstandard}, we specify the notation we use in
the rest of the document.

\begin{figure}[htb]
  \begin{align*}
    \var{set} \restrictdom \var{map}
    & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ k \in \var{set} \}
    & \text{domain restriction}
    \\
    \var{set} \subtractdom \var{map}
    & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ k \notin \var{set} \}
    & \text{domain exclusion}
    \\
    \var{map} \restrictrange \var{set}
    & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ v \in \var{set} \}
    & \text{range restriction}
    \\
    \var{map} \subtractrange \var{set}
    & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ v \notin \var{set} \}
    & \text{range exclusion}
    \\
    A \triangle B
    & = (A \setminus B) \cup (B \setminus A)
    & \text{symmetric difference}
    \\
    M \unionoverrideRight N
    & = (\dom N \subtractdom M)\cup N
    & \text{union override right}
    \\
    M \unionoverrideLeft N
    & = M \cup (\dom M \subtractdom N)
    & \text{union override left}
    \\
    M \unionoverridePlus N
    & = (M \triangle N)
    \cup \{k\mapsto v_1+v_2\mid {k\mapsto v_1}\in M \land {k\mapsto v_2}\in N \}
    & \text{union override plus} \\
    & & \text{(for monoidal values)}\\
  \end{align*}
  \caption{Non-standard map operators}
  \label{fig:notation:nonstandard}
\end{figure}

\clearpage

\section{Cryptographic primitives}
\label{sec:crypto-primitives}


Figure~\ref{fig:crypto-defs} introduces the cryptographic abstractions used in
this document. We begin by listing the abstract types, which are meant to
represent the corresponding concepts in cryptography. Only the functionality
explicitly stated in the figures below is assumed within the scope of this paper.
That is, their exact
implementation remains open to interpretation, and we do not rely on
any additional properties derived from the study or implementation of public key
cryptography outside this work. The types and rules we give here are needed in
order to guarantee certain security properties of the delegation process, which
we discuss later.

The cryptographic concepts required for the formal definition
of witnessing include public-private key pairs, one-way functions
and signatures. The constraint we introduce states that a signature of
some data signed with a (private) key is only correct whenever we can verify
it using the corresponding public key.

Besides basic cryptographic abstractions, we also make use of some abstract
data storage properties in this document in order to build necessary definitions
and make judgement calls about them.

Abstract data types in this paper are essentially placeholders with names
indicating the data types they are meant to represent in an implementation.
Derived types are made up of data structures (i.e.~products, lists, finite
maps, etc.) built from abstract types. The underlying structure of a data type
is implementation-dependent, and furthermore, the way the data is stored on
physical storage can vary as well.

Serialization is a physical manifestation of data on a given storage device.
In this document, the properties and rules we state involving serialization are
assumed to hold true independently of the storage medium and style of data
organization chosen for an implementation.

\begin{figure}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{sk} & \SKey & \text{private signing key}\\
      \var{vk} & \VKey & \text{public verifying key}\\
      \var{hk} & \HashKey & \text{hash of a key}\\
      \sigma & \Sig  & \text{signature}\\
      \var{d} & \Data  & \text{data}\\
    \end{array}
  \end{equation*}
  \emph{Derived types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      (sk, vk) & \KeyPair & \text{signing-verifying key pairs}
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \hashKey{} & \VKey \to \HashKey
                 & \text{hashKey function} \\
                 %
      \fun{verify} & \powerset{\left(\VKey \times \Data \times \Sig\right)}
                   & \text{verification relation}\\
                   %
      \fun{sign} & \SKey \to \Data \to \Sig
                 & \text{signing function}\\
    \end{array}
  \end{equation*}
  \emph{Constraints}
  \begin{align*}
    & \forall (sk, vk) \in \KeyPair,~ d \in \Data,~ \sigma \in \Sig \cdot
    \sign{sk}{d} = \sigma \implies \verify{vk}{d}{\sigma}
  \end{align*}
  \emph{Notation for serialized and verified data}
  \begin{align*}
    & \serialised{x} & \text{serialised representation of } x\\
    & \mathcal{V}_{\var{vk}}{\serialised{d}}_{\sigma} = \verify{vk}{d}{\sigma}
    & \text{shorthand notation for } \fun{verify}
  \end{align*}
  \caption{Cryptographic definitions}
  \label{fig:crypto-defs}
\end{figure}

\clearpage

\section{Addresses}
\label{sec:addresses}
Addresses are described in section 4.2 of the delegation design document \cite{delegation_design}.
The types needed for the addresses are defined in Figure~\ref{fig:defs:addresses}.
There are three types of UTxO addresses:
\begin{itemize}
  \item Base addresses, $\AddrB$,
        containing the hash of a payment key and the hash of a staking key,
  \item Pointer addresses, $\AddrP$,
        containing the hash of a payment key and a pointer to a stake key registration certificate,
  \item Enterprise addresses, $\AddrE$,
        containing only the hash of a payment key (and which have no staking rights).
\end{itemize}
Together, these three address types make up the $\Addr$ type, which will be used
in transaction outputs in Section~\ref{sec:ledger}.

Note that for security, privacy, and usability reasons, the staking (delegating)
key pair associated with an address should be different from its payment key pair.
Before the stake key is registered and delegated to an existing stake pool,
the payment key can be used for transactions, though it will not receive rewards from staking.
Once a stake key is registered, the shorter pointer addresses can generated.

Finally, there is an account style address $\AddrRWD$ which contains the hash of a staking key.
These account addresses will only be used for receiving rewards from the proof of
stake leader election.  Apendix A of \cite{delegation_design} explains this design choice.
The mechanism for transferring rewards from these accounts will be explained in
Section~\ref{sec:ledger}, and follows \cite{chimeric}.

\begin{figure*}[hbt]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      slot & \Slot & \text{absolute slot}\\
      ix & \Ix & \text{index}\\
    \end{array}
  \end{equation*}
  %
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{(s,t,c)}
      & \Ptr
      & \Slot\times\Ix\times\Ix
      & \text{certificate pointer}
      \\
      \var{addr}
      & \AddrB
      & \HashKey_{pay}\times\HashKey_{stake}
      & \text{base address}
      \\
      \var{addr}
      & \AddrP
      & \HashKey_{pay}\times\Ptr
      & \text{pointer address}
      \\
      \var{addr}
      & \AddrE
      & \HashKey_{pay}
      & \text{enterprise address}
      \\
      \var{addr}
      & \Addr
      & \AddrB \uniondistinct \AddrP \uniondistinct \AddrE
      & \text{output address}
      \\
      \var{acct}
      & \AddrRWD
      & \HashKey_{stake}
      & \text{reward account}
      \\
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{paymentHK} & \Addr \to \HashKey_{pay}
                      & \text{hash of payment key from addr}\\
      \fun{stakeHK_b} & \AddrB \to \HashKey_{stake}
                      & \text{hash of stake key from base addr}\\
      \fun{stakeHK_r} & \AddrRWD \to \HashKey_{stake}
                      & \text{hash of stake key from reward account}\\
      \fun{addrPtr} & \AddrP \to \Ptr
                    & \text{pointer from pointer addr}\\
    \end{array}
  \end{equation*}
  %
  \emph{Constructor Functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{addr_{rwd}}
        & \HashKey_{stake} \to \AddrRWD
        & \text{construct a reward account}
    \end{array}
  \end{equation*}
  \caption{Definitions used in Addresses}
  \label{fig:defs:addresses}
\end{figure*}

\clearpage

\section{Protocol Parameters}
\label{sec:protocol-parameters}

The rules for the ledger depend on several parameters and are contained in the $\PParams$ type
defined in Figure~\ref{fig:defs:protocol-parameters}.

The type $\Coin$ is defined as an alias for the integers.
Negative values will not be allowed in UTxO outputs or reward accounts,
and $\Z$ is only chosen over $\N$ for its additive inverses.

The $\fun{minfee}$ function calculates the minimum fee that must be paid by a transaction.
This value depends on the protocol parameters and the size of the transaction.

Two time related types are introduced, $\Epoch$ and $\type{Duration}$.
A $\type{Duration}$ is the difference between two slots, as given by $\slotminus{}{}$.

One global constant is defined, $\SlotsPerEpoch$, representing the number of slots
in an epoch. As a global constant, this value can only be changed by updating the software.

Lastly, there are two functions, $\fun{epoch}$ and $\fun{firstSlot}$ for converting
between epochs and slots.

\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{fparams} & \type{FeeParams} & \text{min fee parameters}\\
      \var{dur} & \Duration & \text{difference between slots}\\
      \var{epoch} & \Epoch & \text{epoch} \\
    \end{array}
  \end{equation*}
  %
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{coin}
      & \Coin
      & \Z
      & \text{unit of value}
      \\
    \end{array}
  \end{equation*}
  %
  \emph{Protocol Parameters}
  %
  \begin{equation*}
    \PParams =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{fparams} & \type{FeeParams} & \text{min fee parameters}\\
        \var{keyDeposit} & \Coin & \text{stake key deposit}\\
        \var{keyMinRefund} & \unitInterval & \text{stake key min refund}\\
        \var{keyDecayRate} & \nonnegReals & \text{stake key decay rate}\\
        \var{poolDeposit} & \Coin & \text{stake pool deposit}\\
        \var{poolMinRefund} & \unitInterval & \text{stake pool min refund}\\
        \var{poolDecayRate} & \nonnegReals & \text{stake pool decay rate}\\
        \var{movingAvgWeight} & \unitInterval & \text{moving average weight}\\
        \var{movingAvgExp} & \posReals & \text{moving average exponent}\\
        \var{E_{max}} & \Epoch & \text{epoch bound on pool retirement}\\
        \var{n_{opt}} & \Npos & \text{desired number of pools}\\
        \var{a_0} & \posReals & \text{pool influence}\\
        \tau & \unitInterval & \text{treasury expansion}\\
        \rho & \unitInterval & \text{monetary expansion}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Accessor Functions}
  %
  \begin{center}
    \fun{fparams},
    \fun{keyDeposit},
    \fun{keyMinRefund},
    \fun{keyDecayRate},
    \fun{poolDeposit},
    \fun{poolMinRefund},
    \fun{poolDecayRate},
    \fun{movingAvgWeight},
    \fun{movingAvgExp},
    \fun{emax},
    \fun{nopt},
  \fun{influence},
  \fun{tau},
  \fun{rho}
  \end{center}
  %
  \emph{Abstract Functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{minfee} & \PParams \to \Tx \to \Coin
                   & \text{minimum fee calculation}
      \\
      (\slotminus{}{}) & \Slot \to \Slot \to \Duration
                       & \text{duration between slots}
    \end{array}
  \end{equation*}
  %
  \emph{Global Constants}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \SlotsPerEpoch & \N & \text{slots per epoch} \\
    \end{array}
  \end{equation*}
  %
  \emph{Derived Functions}
  %
  \begin{align*}
    \fun{epoch} & \in ~ \Slot \to \Epoch & \text{epoch of a slot}
    \\
    \fun{epoch} & ~\var{slot} = \var{slot}~\mathsf{div}~\SlotsPerEpoch
    \\
    \\
    \fun{firstSlot} & \in ~ \Epoch \to \Slot
               & \text{first slot of an epoch}
    \\
    \fun{firstSlot} & ~\var{e} = \var{e}~\cdot~\SlotsPerEpoch
  \end{align*}
  %
  \caption{Definitions used in Protocol Parameters}
  \label{fig:defs:protocol-parameters}
\end{figure*}

\clearpage

\section{Transactions}

Transactions are defined in Figure~\ref{fig:defs:utxo}.
A transaction body, $\TxBody$, is made up of six pieces:

\begin{itemize}
  \item A set of transaction inputs.
    The $\TxIn$ derived type identifies an output from a previous transaction.
    It consists of a transaction id and an index to uniquely identify the output.
  \item An indexed collection of transaction outputs.
    The $\TxOut$ type is an address paired with a coin value.
  \item A list of certificates, which will be explained in detail in Section~\ref{sec:delegation}.
  \item A transaction fee. This value will be added to the fee pot and eventually handed out
    as stake rewards.
  \item A time to live. A transaction will be deemed invalid if processed after this slot.
  \item A mapping of reward account withdrawals.  The type $\Wdrl$ is a finite map that maps
    a reward address to the coin value to be withdrawn. The coin value must be equal
    to the full value contained in the account. Explicitly stating these values ensures
    that error messages can be precise about why a transaction is invalid.
\end{itemize}
A transaction, $\Tx$, is a transaction body together with:

\begin{itemize}
  \item A collection of witnesses, represented as a finite map from payment verification keys
    to signatures.
\end{itemize}

Additionally, the $\UTxO$ type will be used by the ledger state to store all the
unspent transaction outputs. It is a finite map from transaction inputs
to transaction outputs that are available to be spent.

Finally, $\fun{txid}$ computes the transaction id of a given transaction.
This function must produce a unique id for each unique transaction.

\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{txid} & \TxId & \text{transaction id}\\
    \end{array}
  \end{equation*}
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      (\var{txid}, \var{ix})
      & \TxIn
      & \TxId \times \Ix
      & \text{transaction input}
      \\
      (\var{addr}, c)
      & \type{TxOut}
      & \Addr \times \Coin
      & \text{transaction output}
      \\
      \var{utxo}
      & \UTxO
      & \TxIn \mapsto \TxOut
      & \text{unspent tx outputs}
      \\
      \var{wdrl}
      & \Wdrl
      & \AddrRWD \mapsto \Coin
      & \text{reward withdrawal}
    \end{array}
  \end{equation*}
  %
  \emph{Transaction Types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{txbody}
      & \TxBody
      & \powerset{\TxIn} \times (\Ix \mapsto \TxOut) \times \seqof{\DCert}
        \times \Coin \times \Slot \times \Wdrl
      \\
      \var{tx}
      & \Tx
      & \TxBody \times (\VKey \mapsto \Sig)
      \\
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{txins} & \Tx \to \powerset{\TxIn} & \text{transaction inputs} \\
      \fun{txouts} & \Tx \to (\Ix \mapsto \TxOut) & \text{transaction outputs} \\
      \fun{txcerts} & \Tx \to \seqof{\DCert} & \text{delegation certificates} \\
      \fun{txfee} & \Tx \to \Coin & \text{transaction fee} \\
      \fun{txttl} & \Tx \to \Slot & \text{time to live} \\
      \fun{txwdrls} & \Tx \to \Wdrl & \text{withdrawals} \\
      \fun{txbody} & \Tx \to \TxBody & \text{transaction body}\\
      \fun{txwits} & \Tx \to (\VKey \mapsto \Sig) & \text{witnesses} \\
    \end{array}
  \end{equation*}
  %
  \emph{Abstract Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \txid{} & \Tx \to \TxId & \text{compute transaction id}\\
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system}
  \label{fig:defs:utxo}
\end{figure*}

\clearpage

\section{Ledger State Transitions}
\label{sec:ledger}

A key constraint that must always be satisfied as a result and precondition of
a valid ledger state transition is called the \textit{general accounting
property}, or the \textit{preservation of value} condition. Every piece of
software that is a part of the implementation of the
Cardano cryptocurrency must function in such a way as to not result in
a violation of this rule.
If this condition is not satisfied, it is an indicator of
incorrect accounting, potentially due to
malicious disruption or a bug.

The preservation of value is expressed as an equality that uses values in
the ledger state and the environment, as well as the values in the body of
the signal transaction.
We have defined the rules of the delegation protocol in a way that should
consistently satisfy the preservation of value. In the future, we hope to
give a formally-verified proof that every \textit{valid} ledger state satisfies
this property.

In this section, we discuss the relevant accounting that needs to be done
as a result of processing a transaction, i.e.~the deposits for all certificates,
transaction fees, transaction withdrawals, and refunds for individual
deregistration, so that we may keep track of whether the preservation of
value is satisfied. Stake pool retirement refunds are not triggered by a
transaction (but rather, happen at the epoch boundary), and are therefore
not considered in our state change rules invoked due to a signal transaction.

Note, that when a transaction is issued by a wallet to be applied to the ledger
state (i.e.~processed),
we define the rules in this section in such a way that it is impossible to
apply only some parts of a transaction (e.g.~only certain certificates).
Every part of the transaction must be valid and it must be live, otherwise
it is ignored entirely. It is the wallet's responsibility to inform the user
that a transaction failed to be processed.

\subsection{UTxO Transitions}
\label{sec:utxo-trans}

Figure~\ref{fig:functions:utxo} defines functions needed for the UTxO transition system.

\begin{itemize}

  \item
    The function $\fun{outs}$ creates unspent outputs generated by a transaction, so that
    they can be added to the ledger state.  For each output in the transaction,
    $\fun{outs}$ maps the transaction id and output index to the output.

  \item
    The $\fun{ubalance}$ function calculates sum total of all the coin in a given UTxO.
  \item
    The $\fun{wbalance}$ function calculates sum total of all the withdrawals in a transaction.

  \item The calculation $\fun{consumed}$ gives the value consumed by the transaction $\var{tx}$
    in the context of the protocol parameters, the current UTxO on the ledger, and the registered
    stake keys.  This calculation is a sum of all coin in the inputs of $\var{tx}$,
    reward withdrawals, and stake key deposit refunds.
    Some of the definitions used in this function will be defined in
    Section~\ref{sec:deps-refunds}.
    In particular, $\fun{keyRefunds}$ is defined in Figure~\ref{fig:functions:deposits-refunds}
    and $\StakeKeys$ is defined in Figure~\ref{fig:delegation-defs}.

  \item The calculation $\fun{produced}$ gives the value produced by the transaction $\var{tx}$
    in the context of the protocol parameters and the registered stake pools.
    This calculation is a sum of all coin in the outputs of $\var{tx}$,
    the transaction fee, and all needed deposits.
    Some of the definitions used in this function will be defined in
    Section~\ref{sec:deps-refunds}.
    In particular, $\fun{deposits}$ is defined in Figure~\ref{fig:functions:deposits-refunds}
    and $\StakePools$ is defined in Figure~\ref{fig:delegation-defs}.
\end{itemize}

The preservation of value property holds for a transaction, for a given ledger state,
exactly when the results of $\fun{consumed}$ equal the results of $\fun{produced}$.
Moreover, when the property holds, value is only moved between transaction outputs,
the reward accounts, the fee pot, and the deposit pot.

Note that the $\fun{consumed}$ function takes the registered stake pools ($\var{stpools}$)
as a parameter only in order to determine which pool registration certificates are
new (and thus require a deposit) and which ones are updates.
Registration will be discussed more in Section~\ref{sec:delegation}.

\begin{figure}[htb]
  \begin{align*}
    & \fun{outs} \in \Tx \to \UTxO
    & \text{tx outputs as UTxO} \\
    & \fun{outs} ~ \var{tx} =
        \left\{
          (\fun{txid} ~ \var{tx}, \var{ix}) \mapsto \var{txout} ~
          \middle|
          \var{ix} \mapsto \var{txout} \in \txouts{tx}
        \right\}
    \nextdef
    & \fun{ubalance} \in \UTxO \to \Coin
    & \text{UTxO balance} \\
    & \fun{ubalance} ~ utxo = \sum_{(~\wcard ~ \mapsto (\wcard, ~c)) \in \var{utxo}} c
    \nextdef
    & \fun{wbalance} \in \Wdrl \to \Coin
    & \text{withdrawal balance} \\
    & \fun{wbalance} ~ ws = \sum_{\wcard\mapsto c\in\var{ws}} c
    \nextdef
    & \fun{consumed} \in \PParams \to \UTxO \to \StakeKeys \to \Wdrl \to \Tx \to \Coin
    & \text{value consumed} \\
    & \consumed{pp}{utxo}{stkeys}{rewards}~{tx} = \\
    & ~~\ubalance{(\txins{tx} \restrictdom \var{utxo})} +
        \fun{wbalance}~(\fun{txwdrls}~{tx}) \\
    & ~~~~ + \keyRefunds{pp}{stkeys}{tx} \\
    \nextdef
    & \fun{produced} \in \PParams \to \StakePools \to \Tx \to \Coin
    & \text{value produced} \\
    & \fun{produced}~\var{pp}~\var{stpools}~\var{tx} = \\
    &~~\ubalance{(\outs{tx})}
    + \txfee{tx} + \deposits{pp}{stpools}~{(\dcerts{tx})}\\
  \end{align*}

  \caption{Functions used in UTxO rules}
  \label{fig:functions:utxo}
\end{figure}

\clearpage
The types for the UTxO transition are given in Figure~\ref{fig:ts-types:utxo}.
The environment, $\UTxOEnv$, consists of:

\begin{itemize}
  \item The current slot.
  \item The protocol parameters.
  \item The registered stake keys
    (which will be explained in Section~\ref{sec:delegation}, Figure~\ref{fig:delegation-defs}).
  \item The registered stake pools
    (also explained in Section~\ref{sec:delegation}, Figure~\ref{fig:delegation-defs}).
\end{itemize}
The current slot and the registrations are need for the refund calculations
described in Section~\ref{sec:deps-refunds}.

The state needed for the UTxO transition, $\UTxOState$, consists of:

\begin{itemize}
  \item The current UTxO.
  \item The deposit pot.
  \item The fee pot.
\end{itemize}
The signal for the UTxO transition is a transaction.

\begin{figure}[htb]
  \emph{UTxO environment}
  \begin{equation*}
    \UTxOEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pp} & \PParams & \text{protocol parameters}\\
        \var{stkeys} & \StakeKeys & \text{stake key}\\
        \var{stpools} & \StakePools & \text{stake pool}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{UTxO States}
  \begin{equation*}
    \UTxOState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{utxo} & \UTxO & \text{UTxO}\\
        \var{deposits} & \Coin & \text{deposits pot}\\
        \var{fees} & \Coin & \text{fee pot}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{UTxO transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{utxo}{\_} \var{\_}
    \subseteq \powerset (\UTxOEnv \times \UTxOState \times \Tx \times \UTxOState)
  \end{equation*}
  %
  \caption{UTxO transition-system types}
  \label{fig:ts-types:utxo}
\end{figure}

The UTxO transition system is given in Figure~\ref{fig:rules:utxo}.
Rule~\ref{eq:utxo-inductive} specifies the conditions under which a transaction can
be applied to a particular $\UTxOState$ in environment $\UTxOEnv$:

The transition contains the following predicates:

\begin{itemize}
  \item
    The transaction is live (the current slot is less than its time to live).
  \item
    The transaction has at least one input.
    The global uniqueness of transaction inputs prevents replay attacks.
    By requiring that all transactions spend at least one input,
    the entire transaction is safe from such attacks.
    A delegation certificate by itself, for example, does not have this property.
  \item
    The fee paid by the transaction has to be greater than or equal to the minimum fee,
    which is based on the size of the transaction.
    A user or wallet might choose to create a fee larger than necessary
    in exchange for a faster processing time.
  \item
    Each input spent in the transaction must be in the set of unspent
    outputs.
  \item
    The \textit{preservation of value} property must hold.
    In other words, the amount of value produced by the transaction must be the same as
    the amount consumed.
  \item
    The coin value of each new output must be non-negative.
\end{itemize}
If all the predicates are satisfied, the state is updated as follows:

\begin{itemize}
  \item Update the UTxO:
    \begin{itemize}
      \item Remove from the UTxO all the $(\var{txin}, \var{txout})$ pairs
        associated with the $\var{txins}$'s in the $\var{inputs}$ list of $\var{tx}$.
      \item Add all the $\var{outputs}$ of $\var{tx}$ to the
        UTxO, associated with the $\fun{txid}~\var{tx}$
    \end{itemize}
  \item Add all new deposits to the deposit pot and subtract all refunds.
  \item Add the transaction fee to the fee pot. Additionally, for any refund
    returned by this transaction, add the amount of the original deposit
    which has decayed to the fee pot.
    The amount decayed will depend on the time to live of the transaction
    and will be explained further in Section~\ref{sec:deps-refunds}.
\end{itemize}

The accounting for the reward withdrawals is not done in this transition system.
The rewards are tracked with the delegation state and will
be removed in the final delegation transition, see ~\ref{eq:delegs-base}.

Note here that output entries for both the deposit refunds and the rewards
withdrawals must be included in the body of the transaction
carrying the deregistration certificates (requesting these refunds) and the
reward requests. It is the job
of the wallet to calculate the value of these refunds and withdrawals, and
generate the correct outputs to include in the outputs list of $\var{tx}$ such
that applying this transaction results in a
valid ledger update adding correct amounts of coin to the right addresses.

The majority of funds moved by a transaction usually come from unspent outputs
(i.e.~the $(txid, ix)$ pairs in the inputs of a transaction). The claiming of
refunds and rewards works slightly differently. These get included in the outputs list
only. That is, they do not have any index-matched inputs in the $inputs$ list.
For each requested refund (or withdrawal), the
wallet generates a brand-new index $ix$, then indicates the $(addr,coin)$ value
pairing the address to which the refund is going and the refund amount.
So, this output $(ix \mapsto (addr,coin))$ gets added to $outputs$ of $tx$,
and it follows that $\fun{outs}~{tx}$ is a UTxO that contains the entry
$(\fun{txid}~{tx}, ix) \mapsto (addr,coin)$.

The approach of including refunds and rewards directly in the $outputs$ gives
great flexibility to the management of the coin value obtained from these
accounts, i.e.~it can be directed to any address. However, it means there is no
direct link between the $wdrls$ requests (similarly, the key deregistration
certificate addresses and refund amounts) and the $outputs$. We verify that
the included outputs are correct and authorized through the preservation of value condition
and witnessing the transaction. The combination of the
preservation of value and witnessing, described in Section~\ref{sec:witnesses},
assures that the ledger state is updated correctly.

The main difference, however, in how rewards and refunds work is that refunds
come from a $\var{deposits}$ pool, which is a single coin value indicating
the total decayed amount of all the deposits ever made, while rewards come from individual
accounts where a reward is accumulated to a specific address.

Note that the $\var{refunded}$ and $\var{decayed}$ values added together give what the
full, non-decayed refund for all the key deregistration certificates in $\var{tx}$
would be, and this total value is always removed from the $\var{deposits}$
amount on the ledger. The $\var{refunded}$ amount is returned to the certificate
author, and the $\var{decayed}$ amount is transferred over to $\var{fees}$
(this allows the ledger to adhere to the preservation of value).

Note also that the reason only the decayed value of requested refunds
from \textit{this epoch} is transferred to fees is that at the epoch
boundary, the total decayed value for the whole epoch for both the individual
and pool deposits is transferred into the fees (independent of refund
requests).

\begin{figure}[htb]
  \begin{equation}\label{eq:utxo-inductive}
    \inference[UTxO-inductive]
    { \txttl tx \geq \var{slot}
      & \txins{tx} \neq \emptyset
      & \minfee{pp}{tx} \leq \txfee{tx}
      & \txins{tx} \subseteq \dom \var{utxo}
      \\
      \consumed{pp}{utxo}{stkeys}{rewards}~{tx} = \produced{pp}{stpools}~{tx}
      \\
      ~
      \\
      \forall (\_\mapsto (\_, c)) \in \txouts{tx}, c \geq 0
      \\
      ~
      \\
      \var{refunded} = \keyRefunds{pp}{stkeys}~{tx}
      \\
      \var{decayed} = \decayedTx{pp}{stkeys}~{tx}
      \\
      \var{depositChange} =
        (\deposits{pp}~{stpools}~{\fun{dcerts}~tx}) - (\var{refunded} + \var{decayed})
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{stkeys}\\
        \var{stpools}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
      \end{array}
      \right)
      \trans{utxo}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{(\txins{tx} \subtractdom \var{utxo}) \cup \outs{tx}}  \\
        \varUpdate{\var{deposits} + \var{depositChange}} \\
        \varUpdate{\var{fees} + \txfee{tx} + \var{decayed}} \\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:rules:utxo}
\end{figure}

\clearpage

\subsection{Deposits and Refunds}
\label{sec:deps-refunds}

Deposits are described in appendix B.2 of the delegation design document \cite{delegation_design}.
These deposit functions were used above in the UTxO transition,~\ref{sec:utxo-trans}.
Deposits are used for stake key registration certificate and pool
registration certificates, which will be explained in Section~\ref{sec:delegation}.
In particular, the function $\cwitness{}$, which gets the certificate witness
from a certificate, will be defined later.
Figure~\ref{fig:functions:deposits-refunds} defines the deposit and refund functions.
\begin{itemize}
  \item The function $\fun{deposits}$ returns the total deposits that have to be made
    by a transaction.  This calculation is based on the protocol parameters.
    Specifically, for a given transaction, it sums up the values of the stake key deposits
    and the stake pool deposits.  Those certificates which are
    updates of stake pool parameters of already registered pool keys should not
    (and are, in fact, not allowed to) make a deposit.
  \item The function $\fun{refund}$ calculates the deposit refund with an exponential decay.
  \item The function $\fun{keyRefund}$, calculates the refund for an individual
    stake key registration deposit, based on the slot when it was created and
    the slot passed to the function. The creation slot should always exist in the map
    $\var{stkeys}$ passed to the function, and this would be a good property
    to prove about the transition system.
  \item The function $\fun{keyRefunds}$, in turn, uses $\fun{keyRefund}$ to calculate
    the total value to be refunded to all individual key deregistration certificate authors
    in a transaction.

    It is important to note here that instead of the \textit{current} slot number,
    the time to live of $\var{tx}$ is passed to the $\fun{certRefunds}$ function
    within the summation in $\fun{keyRefunds}$. The reason for this is that the
    refunds for any key deregistration certificates are, in fact, included in
    the $\var{tx}$ itself --- meaning that the coin value of the refund must be
    explicitly specified in the outputs of the transaction. So,
    the value of the included refund must be calculated before this transaction
    is ever processed, and be the same \textit{no matter when} the $\var{tx}$
    \textit{is actually processed} in order to allow the system to continue to
    satisfy the general accounting property.

    It is impossible to predict the exact slot number in which $\var{tx}$ will be processed,
    but it will be some time before slot number $\fun{txttl}~\var{tx}$. So, this is the slot
    number value used in both the calculation to generate the refund coin value in the outputs
    of $\var{tx}$ and in the general accounting property equation.

    Note also that
    $\fun{keyRefunds}$ calculates the total individual refunds for a transaction
    based on \textit{current} protocol parameters. This means that any deposits
    made prior to a change will be different from their corresponding
    (decayed) refunds in the case of key deregistration after a change in
    protocol parameters. Constants may only change at the epoch boundary, and
    ensuring there are always sufficient funds for all
    refunds in the $\var{deposits}$ pool is part of the protocol constant
    change transition, described in Section~\ref{sec:epoch}.

    The protocol parameters are not
    expected to change often, and using the current ones for the calculation
    is a deliberate simplification choice, which does not introduce any inconsistencies
    into the system rules or properties. In particular, the general accounting
    property is not violated.
\end{itemize}
Figure~\ref{fig:functions:deposits-decay} defines the decays functions.
\begin{itemize}

  \item The function $\fun{decayedKey}$ calculates how much of a stake key deposit
    has decayed since the last epoch. Again, this is done using the time to live of
    the transaction (and not the current slot, as explained above).
    At the epoch boundaries, decayed portions of deposits are moved to the reward pot,
    so between epochs we need only account for what has decayed since the last epoch.
    The value is calculated by subtracting the refund calculation based at the epoch boundary
    from the refund calculation based at the time to live of the transaction.
  \item The function $\fun{decayedTx}$ calculates the total decayed deposits associated
    with all the refunds in a given transaction.  This function was used earlier in the
    UTxO transition in Figure~\ref{fig:rules:utxo}.

\end{itemize}

Recall that the stake pool retirement refunds are issued not when a certificate
scheduling the retirement is processed, but at the epoch boundary for which
the retirement is scheduled. The decayed value over the full previous epoch is
also accounted for at the boundary change. For details of this accounting, see
Section~\cref{sec:epoch}.

\begin{figure}[htb]
  \begin{align*}
    & \fun{deposits} \in \PParams \to \StakePools \to \seqof{\DCert} \to \Coin
    & \text{total deposits for transaction} \\
    & \fun{deposits}~{pp}~{stpools}~{certs} = \\
    &  \sum\limits_{c\in\var{certs} \cap \DCertRegKey}(\fun{keyDeposit}~pp)
    +  \sum\limits_{\substack{
         c\in\var{certs}\cap\DCertRegPool \\ (\cwitness{c})\notin \var{stpools}}}
         (\fun{poolDeposit}~pp)
      \nextdef
      & \fun{refund} \in \Coin \to \unitInterval \to \posReals \to \Duration \to \Coin
      & \text{refund calculation} \\
      & \refund{\dval}{d_{\min}}{\lambda}{\delta} =
            \floor*{
              \dval \cdot
            \left(d_{\min}+(1-d_{\min})\cdot e^{-\lambda\cdot\delta}\right)}
      \nextdef
      & \fun{keyRefund} \in \Coin \to \unitInterval \to \posReals \to \\
      & ~~~~~\StakeKeys \to \Slot \to \DCertDeRegKey \to \Coin
      & \text{key refund for a certificate} \\
      & \keyRefund{\dval}{d_{\min}}{\lambda}{stkeys}{slot}{c} =\\
      & ~~~~~\begin{cases}
            0 & \text{if}~\cwitness c \notin \dom stkeys\\
            \refund{\dval}{d_{\min}}{\lambda}{\delta}
            & \text{otherwise}
        \end{cases}\\
      &
      \begin{array}{lr@{~=~}l}
        \where
        &\delta & \slotminus{slot}{(stkeys~(\cwitness c))}\\
      \end{array}\\
      \nextdef
      & \fun{keyRefunds} \in \PParams \to \StakeKeys \to \Tx \to \Coin
      & \text{key refunds for a transaction} \\
      & \keyRefunds{pp}{stkeys}{tx} =\\
      & ~~~~~ \sum\limits_{\substack{c \in \fun{dcerts}~tx \\ c\in\DCertDeRegKey}}
              \keyRefund{\dval}{d_{\min}}{\lambda}{stkeys}{(\txttl{tx})}{c}\\
      &
      \begin{array}{lr@{~=~}l}
        \where \\
        & \dval & \fun{keyDeposit}~\var{pp}\\
        & d_{\min} & \fun{keyMinRefund}~\var{pp}\\
        & \lambda & \fun{keyDecayRate}~\var{pp}\\
      \end{array}\\
  \end{align*}
  \caption{Functions used in Deposits - Refunds}
  \label{fig:functions:deposits-refunds}
\end{figure}

\begin{figure}[htb]
  \begin{align*}
      & \fun{decayedKey} \in
      \PParams \to \StakeKeys \to \Slot \to \DCertDeRegKey \to \Coin
      & \text{decayed since epoch} \\
      & \decayedKey{pp}{stkeys}{cslot}{c} =\\
      & \begin{cases}
            0 & \text{if}~\cwitness c \notin \dom stkeys\\
            \var{epochRefund} - \var{currentRefund}
            & \text{otherwise}
        \end{cases}\\
      &
      \begin{array}{lr@{~=~}l}
        \where
          & \var{created} & \var{stkeys}~(\cwitness~\var{c}) \\
          & \var{start} & \mathsf{max}~(\firstSlot{\epoch{cslot}})~created \\
          & \var{epochRefund} & \keyRefund{\dval}{d_{\min}}{\lambda}{stkeys}{start}{c} \\
          & \var{currentRefund} & \keyRefund{\dval}{d_{\min}}{\lambda}{stkeys}{cslot}{c} \\
          & \dval & \fun{keyDeposit}~\var{pp}\\
          & d_{\min} & \fun{keyMinRefund}~\var{pp}\\
          & \lambda & \fun{keyDecayRate}~\var{pp}\\
      \end{array}\\
      \nextdef
      & \fun{decayedTx} \in \PParams \to \StakeKeys \to \Tx \to \Coin
      & \text{decayed deposit portions} \\
      & \decayedTx{pp}{stkeys}{tx} =\\
      &   \sum\limits_{\substack{c \in \fun{dcerts}~tx \\ c \in\DCertDeRegKey}}
          \decayedKey{pp}{stkeys}{(\txttl{tx})}{c}\\
  \end{align*}
  \caption{Functions used in Deposits - Decay}
  \label{fig:functions:deposits-decay}
\end{figure}

\clearpage

\subsection{Witnesses}
\label{sec:witnesses}

The purpose of witnessing is make sure that the intended action is authorized by
the holder of the signing key, providing replay protection as a consequence.
Replay prevention is an inherent property of UTxO type accounting
since transaction IDs are unique, and we require all transaction to
consume at least one input.

A transaction is witnessed by a signature and a verification key corresponding to this signature.
The witnesses, together with the transaction body, form a full transaction.
Every witness in a transaction signs the transaction body.
Moreover, the witnesses are represented as finite maps from verification keys to signatures,
so that any key that is required to sign a transaction only provides a single witness.
This means that, for example, transaction which includes a delegation certificate and
a reward withdrawal corresponding to the same stake key still only includes one signature.

Figure~\ref{fig:functions-witnesses} defines the function which
gathers all the (hashes of) verification keys needed to witness a given transaction.
This consists of:
\begin{itemize}
  \item payment keys for outputs being spent
  \item stake keys for reward withdrawals
  \item stake keys for delegation certificates
  \item stake keys for the pool owners in a pool registration certificate
\end{itemize}

\begin{figure}[htb]
  \begin{align*}
    & \fun{witsNeeded} \in \UTxO \to \Tx \to \powerset{\HashKey}
    & \text{hashkeys for needed witnesses} \\
    & \fun{witsNeeded}~{utxo}~{tx} = \\
    & ~~\{ \fun{paymentHK}~a \mid i \mapsto (a, \wcard) \in \var{utxo},~i\in\txins{tx} \}~\cup \\
    & ~~\{\fun{stakeHK_r}~a \mid a\mapsto \wcard \in \txwdrls{tx}\}~\cup \\
    & ~~\{\cwitness{c} \mid c \in \txcerts{tx}\}~\cup \\
    & ~~\bigcup_{\substack{c \in \txcerts{tx} \\ ~c \in\DCertRegPool}} \fun{poolOwners}~{c} \\
  \end{align*}
  \caption{Functions used in witness rule}
  \label{fig:functions-witnesses}
\end{figure}

The UTxOW transition system adds witnessing to the previous UTxO transition system.
Figure~\ref{fig:ts-types:utxow} defines the type for this transition.

\begin{figure}
  \emph{UTxO with witness transitions}
  \begin{equation*}
    \var{\_} \vdash
    \var{\_} \trans{utxow}{\_} \var{\_}
    \subseteq \powerset (\UTxOEnv \times \UTxOState \times \Tx \times \UTxOState)
  \end{equation*}
  \caption{UTxO with witness transition-system types}
  \label{fig:ts-types:utxow}
\end{figure}

Figure~\ref{fig:rules:utxow} defines UTxOW transition.
It has two predicates:
\begin{itemize}
  \item Every signature in the transaction is a valid signature of the transaction body.
  \item The set of (hashes of) verification keys given by the transaction is exactly
    the set of needed (hashes of) verification keys.
\end{itemize}
If the predicates are satisfied, the state is transitioned by the UTxO transition rule.

\begin{figure}
  \begin{equation}
    \label{eq:utxo-witness-inductive}
    \inference[UTxO-wit]
    {
      (utxo, \wcard, \wcard) = \var{utxoSt} \\~\\
      \forall \var{vk} \mapsto \sigma \in \txwits{tx},
        \mathcal{V}_{\var{vk}}{\serialised{\txbody{tx}}}_{\sigma} \\
      \fun{witsNeeded}~{utxo}~{tx} = \{ \hashKey \var{vk} \mid \var{vk}\in\dom{(\txwits{tx})} \}\\
      {
        \begin{array}{l}
        \var{utxoEnv}
        \end{array}
      }
      \vdash \var{utxoSt} \trans{utxo}{tx} \var{utxoSt'}\\
    }
    {
      \begin{array}{l}
        \var{utxoEnv}
      \end{array}
      \vdash \var{utxoSt} \trans{utxow}{tx} \varUpdate{\var{utxoSt'}}
    }
  \end{equation}
  \caption{UTxO with witnesses inference rules}
  \label{fig:rules:utxow}
\end{figure}

\clearpage

\section{Delegation}
\label{sec:delegation}
\input{delegation.tex}

\clearpage

\subsection{Ledger State Transition}
\label{sec:ledger-trans}

The entire state transformation of the ledger state caused by a valid transaction
can now be given as the combination of the UTxO transition and the delegation transitions.

Figure~\ref{fig:ts-types:ledger} defines the types for this transition.
The environment for this rule is consists of:
\begin{itemize}
  \item The current slot.
  \item The transaction index within the current block.
  \item The protocol parameters.
\end{itemize}
The ledger state consists of:
\begin{itemize}
  \item The UTxO state.
  \item The delegation and pool states.
\end{itemize}

\begin{figure}[htb]
  \emph{Ledger environment}
  \begin{equation*}
    \LEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{slot} & \Slot & \text{current slot}\\
        \var{txIx} & \Ix & \text{transaction index}\\
        \var{pp} & \PParams & \text{protocol parameters}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Ledger state}
  \begin{equation*}
    \LState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{utxoSt} & \UTxOState & \text{UTxO state}\\
        \var{dpstate} & \DPState & \text{delegation and pool state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Ledger transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{ledger}{\_} \var{\_}
    \subseteq \powerset (\LEnv \times \LState \times \Tx \times \LState)
  \end{equation*}
  \caption{Ledger transition-system types}
  \label{fig:ts-types:ledger}
\end{figure}

Figure~\ref{fig:ts-types:ledger} defines the ledger state transition.
It has a single rule, which first calls the $\mathsf{UTXOW}$ transition,
and then calls the $\mathsf{DELEGS}$ transition.

\begin{figure}
  \begin{equation}
    \label{eq:ledger}
    \inference[ledger]
    {
      (\var{dstate}, \var{pstate}) = \var{dpstate} \\
    (\var{stkeys}, \_, \_, \_) = \var{dstate} \\
    (\_, \_, \var{stpools}, \_) = \var{pstate} \\~\\
      \left({
        \begin{array}{r}
        \var{slot} \\
        \var{pp} \\
        \var{stkeys} \\
        \var{stpools}
        \end{array}
    }\right)
      \vdash \var{utxoSt} \trans{utxow}{tx} \var{utxoSt'}\\~\\~\\
      %
      {
        \left(
        \begin{array}{l}
          \var{slot} \\
          \var{txIx} \\
          \var{pp} \\
        \end{array}
      \right)
      }
      \vdash
      dpstate \trans{delegs}{\var{tx}} dpstate'
    }
    {
      \left(
        \begin{array}{l}
          \var{slot} \\
          \var{txIx} \\
          \var{pp} \\
        \end{array}
      \right)
      \vdash
      \left(
        \begin{array}{ll}
          utxoSt \\
          dpstate \\
        \end{array}
      \right)
      \trans{ledger}{tx}
      \left(
        \begin{array}{ll}
          \varUpdate{utxoSt'} \\
          \varUpdate{dpstate'} \\
        \end{array}
      \right)
    }
  \end{equation}
  \caption{Ledger inference rule}
  \label{fig:rules:ledger}
\end{figure}

\clearpage

\section{Rewards and the Epoch Boundary}
\label{sec:epoch}
\input{epoch.tex}

\clearpage

\section{Properties}
\label{sec:properties}
\input{properties}

\clearpage

\section{Non-Integral Calculations}
\label{sec:non-integr-calc}
\input{non-integral}

\newpage

\begin{appendix}
  \input{appendix}
\end{appendix}


\addcontentsline{toc}{section}{References}
\bibliographystyle{plainnat}
\bibliography{references}

\end{document}
