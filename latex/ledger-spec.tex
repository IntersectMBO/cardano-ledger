\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{iohk}
\usepackage{microtype}
\usepackage{mathpazo} % nice fonts
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{extarrows}
\usepackage{slashed}
\usepackage[colon]{natbib}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage{xcolor}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
%% Setup for the semantic package
\setpremisesspace{20pt}

%%
%% Types
%%
\newcommand{\Tx}{\type{Tx}}
\newcommand{\Ix}{\type{Ix}}
\newcommand{\TxId}{\type{TxId}}
\newcommand{\Addr}{\type{Addr}}
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\Wdrl}{\type{Wdrl}}
\newcommand{\Value}{\type{Value}}
\newcommand{\Coin}{\type{Coin}}
\newcommand{\PrtclConsts}{\type{PrtclConsts}}
\newcommand{\Slot}{\type{Slot}}
\newcommand{\Duration}{\type{Duration}}
\newcommand{\Allocs}{\type{Allocs}}

\newcommand{\DCert}{\type{DCert}}
\newcommand{\DCertRegKey}{\type{DCert_{regkey}}}
\newcommand{\DCertDeRegKey}{\type{DCert_{deregkey}}}
\newcommand{\DCertDeleg}{\type{DCert_{delegate}}}
\newcommand{\DCertRegPool}{\type{DCert_{regpool}}}
\newcommand{\DCertRetirePool}{\type{DCert_{retirepool}}}
\newcommand{\StakePool}{\type{StakePool}}
\newcommand{\UTxOState}{\ensuremath{\type{UTxOState}}}
\newcommand{\ledgerState}{\ensuremath{\type{ledgerState}}}

\newcommand{\AddrRWD}{\type{Addr_{rwd}}}
\newcommand{\DState}{\type{DState}}
\newcommand{\DWState}{\type{DWState}}
\newcommand{\DWEnv}{\type{DWEnv}}
\newcommand{\PState}{\type{PState}}
\newcommand{\DCertBody}{\type{DCertBody}}
\newcommand{\DPoolReap}{\ensuremath{\type{poolreap}}}

%% Adding witnesses
\newcommand{\TxIn}{\type{TxIn}}
\newcommand{\TxOut}{\type{TxOut}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\SKey}{\type{SKey}}
\newcommand{\HashKey}{\type{HashKey}}
\newcommand{\KeyPair}{\type{KeyPair}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
%% Adding delegation
\newcommand{\Epoch}{\type{Epoch}}
\newcommand{\VKeyGen}{\type{VKeyGen}}
%% Blockchain
\newcommand{\Gkeys}{\var{G_{keys}}}
\newcommand{\Block}{\type{Block}}
\newcommand{\SlotId}{\type{SlotId}}
\newcommand{\UTxOEnv}{\type{UTxOEnv}}
\newcommand{\CEEnv}{\type{CEEnv}}
\newcommand{\CEState}{\type{CEState}}
\newcommand{\BDEnv}{\type{BDEnv}}
\newcommand{\BDState}{\type{BDState}}
\newcommand{\LEnv}{\type{LEnv}}
\newcommand{\LState}{\type{LState}}

%%
%% Functions
%%
\newcommand{\txins}[1]{\fun{txins}~ \var{#1}}
\newcommand{\txid}[1]{\fun{txid}~ \var{#1}}
\newcommand{\txouts}[1]{\fun{txouts}~ \var{#1}}
\newcommand{\values}[1]{\fun{values}~ #1}
\newcommand{\balance}[1]{\fun{balance}~ \var{#1}}
\newcommand{\ttl}[1]{\fun{ttl}~ \var{#1}}
\newcommand{\deposits}[2]{\fun{deposits}~ \var{#1} ~ \var{#2}}
\newcommand{\decayedKey}[4]{\fun{decayedKey}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\decayedTx}[3]{\fun{decayedTx}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\certRefund}[6]{\fun{certRefund}~ {#1}~{#2}~{#3}~\var{#4}~\var{#5}~\var{#6}}
\newcommand{\refund}[4]{\fun{refund}~ \var{#1}~ \var{#2}~ {#3}~ {#4}}
\newcommand{\keyRefunds}[3]{\fun{keyRefunds}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\created}[4]{\fun{created}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\destroyed}[2]{\fun{destroyed}~ \var{#1}~ \var{#2}}
\newcommand{\applyFun}[2]{\fun{#1}~\var{#2}}

\newcommand{\RegKey}[1]{\textsc{RegKey}(#1)}
\newcommand{\DeregKey}[1]{\textsc{DeregKey}(#1)}
\newcommand{\Delegate}[1]{\textsc{Delegate}(#1)}
\newcommand{\RegPool}[1]{\textsc{RegPool}(#1)}
\newcommand{\RetirePool}[1]{\textsc{RetirePool}(#1)}
\newcommand{\cauthor}[1]{\fun{author}~ \var{#1}}
\newcommand{\dpool}[1]{\fun{dpool}~ \var{#1}}
\newcommand{\stakepool}[1]{\fun{stakepool}~ \var{#1}}
\newcommand{\retire}[1]{\fun{retire}~ \var{#1}}
\newcommand{\addrRw}[1]{\fun{addr_{rwd}}~ \var{#1}}
\newcommand{\epoch}[1]{\fun{epoch}~ \var{#1}}
\newcommand{\dcerts}[1]{\fun{dcerts}~ \var{#1}}

%% UTxO witnesses
\newcommand{\inputs}[1]{\fun{inputs}~ \var{#1}}
\newcommand{\wits}[1]{\fun{wits}~ \var{#1}}
\newcommand{\verify}[3]{\fun{verify} ~ #1 ~ #2 ~ #3}
\newcommand{\sign}[2]{\fun{sign} ~ #1 ~ #2}
\newcommand{\serialised}[1]{\llbracket \var{#1} \rrbracket}
\newcommand{\addr}[1]{\fun{addr}~ \var{#1}}
\newcommand{\hashKey}[1]{\fun{hashKey}~ \var{#1}}
\newcommand{\txbody}[1]{\fun{txbody}~ \var{#1}}
\newcommand{\txfee}[1]{\fun{txfee}~ \var{#1}}
\newcommand{\txwdrls}[1]{\fun{txwdrls}~ \var{#1}}
\newcommand{\minfee}[2]{\fun{minfee}~ \var{#1}~ \var{#2}}
\newcommand{\slotminus}[2]{\var{#1}~-_{s}~\var{#2}}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
% wildcard parameter
\newcommand{\wcard}[0]{\underline{\phantom{a}}}
%% Adding ledgers...
\newcommand{\utxo}[1]{\fun{utxo}~ #1}
%% Delegation
\newcommand{\delegatesName}{\fun{delegates}}
\newcommand{\delegates}[3]{\delegatesName~#1~#2~#3}
\newcommand{\dwho}[1]{\fun{dwho}~\var{#1}}
\newcommand{\depoch}[1]{\fun{depoch}~\var{#1}}
\newcommand{\dval}{\ensuremath{d_{\mathsf{val}}}}
%% Delegation witnesses
\newcommand{\dbody}[1]{\fun{dbody}~\var{#1}}
\newcommand{\dwit}[1]{\fun{dwit}~\var{#1}}
%% Blockchain
\newcommand{\bwit}[1]{\fun{bwit}~\var{#1}}
\newcommand{\bslot}[1]{\fun{bslot}~\var{#1}}
\newcommand{\bbody}[1]{\fun{bbody}~\var{#1}}
\newcommand{\bdlgs}[1]{\fun{bdlgs}~\var{#1}}
%% ledgerstate constants
\newcommand{\genesisId}{\ensuremath{Genesis_{Id}}}
\newcommand{\genesisTxOut}{\ensuremath{Genesis_{Out}}}
\newcommand{\genesisUTxO}{\ensuremath{Genesis_{UTxO}}}
\newcommand{\emax}{\ensuremath{\mathsf{E_{max}}}}
\newcommand{\slotsPer}{\ensuremath{\mathsf{slotsPerEpoch}}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\theoremstyle{definition}
\newtheorem{property}{Property}[section]

\begin{document}

\input{frontmatter.tex}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}
\input{intro.tex}

\section{Notation}\label{sec:notation}

The transition system is explained in \cite{small_step_semantics}.

\begin{description}
\item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
  the subsets of $X$.
\item[Symmetric Difference] Given two sets $\type{X}$ and $\type{Y}$,
  the symmetric difference of $\type{X}$ and $\type{Y}$,
  denoted $\type{X}\triangle\type{Y}$, is the union of $\type{X}$ and $\type{Y}$
  witout the intersection.
\item[Sequences] Given a set $\type{X}$, $\seqof{\type{X}}$ is the set of
  sequences having elements taken from $\type{X}$. The empty sequence is
  denoted by $\epsilon$, and given a sequence $\Lambda$, $\Lambda; \type{x}$ is
  the sequence that results from appending $\type{x} \in \type{X}$ to
  $\Lambda$.
\item[Functions] $A \to B$ denotes a \textbf{total function} from $A$ to $B$.
  Given a function $f$ we write $f~a$ for the application of $f$ to argument
  $a$.
\item[Fibre] Given a function $f: A \to B$ and $b\in B$, we write
  $f^{-1}~b$ for the \textbf{fibre} of $f$ at $b$, which is defined by
  $\{a \mid\ f a =  b\}$.
\item[Maps and partial functions] $A \mapsto B$ denotes a \textbf{partial
    function} from $A$ to $B$, which can be seen as a map (dictionary) with
  keys in $A$ and values in $B$. Given a map $m \in A \mapsto B$, notation
  $a \mapsto b \in m$ is equivalent to $m~ a = b$.
\item[Map Operations] Figure \ref{fig:notation:nonstandard}
  describes some non-standard map operations.

\end{description}

In Figure~\ref{fig:notation:nonstandard}, we specify the notation we use in
the rest of the document.

\begin{figure}
  \begin{align*}
    \var{set} \restrictdom \var{map}
    & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ k \in \var{set} \}
    & \text{domain restriction}
    \\
    \var{set} \subtractdom \var{map}
    & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ k \notin \var{set} \}
    & \text{domain exclusion}
    \\
    \var{map} \restrictrange \var{set}
    & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ v \in \var{set} \}
    & \text{range restriction}
    \\
    \var{map} \subtractrange \var{set}
    & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ v \notin \var{set} \}
    & \text{range exclusion}
    \\
    M \unionoverrideRight N
    & = (\dom N \subtractdom M)\cup N
    & \text{union override right}
    \\
    M \unionoverrideLeft N
    & = M \cup (\dom M \subtractdom N)
    & \text{union override left}
    \\
    M \unionoverridePlus N
    & = (M \triangle N)
    \cup \{k\mapsto v_1+v_2\mid {k\mapsto v_1}\in M \land {k\mapsto v_2}\in N \}
    & \text{union override plus} \\
    & & \text{(for monoidal values)}\\
    M \unionoverrideZero N
    & = (M \triangle N)
    \cup \{k\mapsto 0\mid {k\mapsto v_1}\in M \land {k\mapsto v_2}\in N \}
    & \text{union override plus} \\
    & & \text{(for monoidal values)}\\
  \end{align*}
  \caption{Non-standard map operators}
  \label{fig:notation:nonstandard}
\end{figure}

\section{Cryptographic primitives}
\label{sec:crypto-primitives}


Figure~\ref{fig:crypto-defs} introduces the cryptographic abstractions used in
this document. We begin by listing the abstract types, which are meant to
represent the corresponding concepts in cryptography. Only the funcitonality
explicitly stated in the figures below is assumed within the scope of this paper.
That is, their exact
implementation remains open to interpretation, and we do not rely on
any additional properties derived from the study or implementation of public key
cryptography outside this work. The types and rules we give here are needed in
order to guarantee certain security properties of the delegation process, which
we discuss later.

The cryptographic concepts required for the formal definition
of delegation with witnesses include public-private key pairs, one-way functions
and signatures. The constraint we introduce states that a signature of
some data signed with a (private) key is only correct whenever we can verify
it using the corresponding public key.

\begin{figure}
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{sk} & \SKey & \text{private signing key}\\
      \var{vk} & \VKey & \text{public verifying key}\\
      \var{hk} & \HashKey & \text{hashKey of a key}\\
      \sigma & \Sig  & \text{signature}\\
      \var{d} & \Data  & \text{data}\\
    \end{array}
  \end{equation*}
  \emph{Derived types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      (sk, vk) & \KeyPair & \text{signing-verifying key pairs}
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \hashKey{} & \VKey \to \HashKey
      & \text{hashKey function} \\
      %
      \fun{verify} & \powerset{\left(\VKey \times \Data \times \Sig\right)}
      & \text{verification relation}\\
    \end{array}
  \end{equation*}
  \emph{Constraints}
  \begin{align*}
    & \forall (sk, vk) \in \KeyPair,~ m \in \Data,~ \sigma \in \Sig \cdot
      \verify{vk}{m}{\sigma} \iff \sign{sk}{m} = \sigma
  \end{align*}
  \emph{Notation for serialized and verified data}
  \begin{align*}
    & \serialised{x} & \text{serialised representation of } x\\
    & \mathcal{V}_{\var{vk}}{\serialised{m}}_{\sigma} = \verify{vk}{m}{\sigma}
      & \text{shorthand notation for } \fun{verify}
  \end{align*}
  \caption{Cryptographic definitions}
  \label{fig:crypto-defs}
\end{figure}

\section{Serialization}
\label{sec:serialization}


Besides basic cryptographic abstractions, we also make use of some abstract
data storage properties in this document in order to build necessary definitions
and make judgement calls about them.

Abstract data types in this paper are essentially placeholders with names
indicating the data types they are meant to represent in an implementation.
Derived types are made up of data structures (i.e. products, lists, finite
maps, etc.) built from abstract types. The underlying structure of a data type
is implementation-dependent, and furthermore, the way the data is stored on
physical storage can vary as well.

Serialization is a physical manipulation of data on a given storage device.
In this document, the properties and rules we state involving serialization are
assumed to hold true independently of the storage medium and style of data
organization chosen for an implementation.


\begin{todo}
  Add serialization reference
\end{todo}

\section{Delegation}
\label{sec:delegation}
\input{delegation.tex}


\section{UTxO}
\label{sec:utxo}

A key constraint that must always be satisfied as a result and precondition of
a valid ledger state transition is called the \textit{general accounting
property}, or the \textit{preservation of value} condition. Every piece of
software that is a part of the implementation of the
Cardano cryptocurrency must function in such a way as to not result in a
a violation of this rule.
condition is not satisfied, this is an indicator of
incorrect accounting, potentially due to
malicious disruption or a bug.

The preservation of value is expressed as an equality that uses values in
the ledger state and the environment, as well as the values in the body of
the signal transaction.
We have defined the rules of the delegation protocol in a way that should
consistently satisfy the presevation of value. In the future, we hope to
give a formally-verified proof that every \textit{valid} ledger state satisfies
this property.

In this section, we discuss the relevant accounting that needs to be done
as a result of processing a transaction, i.e. the deposits for all certificates,
transaction fees, transaction withdrawals, and refunds for individual
deregistration, so that we may keep track of whether the preservation of
value is satisfied. Stake pool retirement refunds are not triggered by a
transaction (but rather, happen at the epoch boundary), and are therefore
not considered in our state change rules invoked due to a signal transaction.

Note that when a transaction is issued by a wallet to be applied to the ledger
state (i.e. processed),
we define the rules in this section in such a way that it is impossible to
apply only some parts of a transaction (e.g. only certain certificates).
Every part of the transaction must be valid and it must be live, otherwise
it is ignored entirely. It is the wallet's responsibility to inform the user
that a transaction failed to be processed.

\subsection{Deposits and Refunds}
\label{sec:deps-refunds}

We present the types of variables and functions needed for deposit and
refund calculations in Figure~\ref{fig:defs:deposits}.

The $\PrtclConsts$ is
an abstract type that will represent an environment variable that contains
values on which the functionality of the blockchain protocol depends, such
as the fees transactions are obligated to pay to be processed. In particular,
we define two maps here that return values stored in the set of protocol
constants. The map $\fun{dvalue}$ returns the amount a certificate must
deposit to claim a specific resource (i.e. for the declaration of a new staking
key or the registration of a stake pool, depending on the type of certificate).

The map $\fun{decay}$
represents the rate of decrease of the value of a unit of $\Coin$.
The constant returned by $\fun{decay}$ consists of two values. The first is
a natural number which determines the minimal proportion of a deposit that will
be refunded on resource release. The second is a positive rational number
used to determine the rate of (exponential) decrease of the value.
Recall that the $\Allocs$ type pairs a hash key with a slot number and is a generic datatype
which we use below to represent both individual and pool allocation
parameters passed to refund calculations.

For a given transaction and protocol constants, the map $\fun{dresource}$
returns all the certificates of that transaction which allocate resources
(i.e. the stake key and stake pool registration certificates). The map
$\fun{dderegister}$ returns the resource release certificates for the
deregistration of a stake key. The map which returns only
the retirement type certificates is $\fun{dretire}$. The function $\fun{ttl}$ gives the
time slot in which the validity of a given transaction will expire. That is,
after slot number $\fun{ttl}~\var{tx}$, the transaction will not be processed.
This value is generated by the wallet.

The functions used in refund calculations are presented in
Figure~\ref{fig:functions:deposits-refunds}.
The function
$\fun{deposits}$ returns the total deposits that have to be made by a transaction.
This calculation is
based on the resource-allocating certificates it carries and the protocol constants.
Specifically, for a given transaction,
it sums up the values of all the deposits made by the resource-allocating
certificates that are \textit{resource allocations to new keys}.  Those
certificates which are
updates of stake pool constants of already registered pool keys should not
(and are, in fact, not allowed to) make a deposit.

The $\fun{releasing}~\var{c}$ is true for deregistration and retirement
certificates. The refund calculation gives the decayed value of a
certificate to be refunded. This fraction is calculated
based on the coin value of the registration deposit $d_{val}$, the minimum
refund $d_{min}$, the
duration between the given slot number and the slot number in
which a given resource was allocated $\delta$, and a decay rate constant $\lambda$.
The larger the duration, the more
the value of the deposit decays, up to a minimum refund value.

The function $\fun{certRefund}$, given a set of protocol constants, resource
allocations, slot number, and certificate, uses the refund calculation to
assign a non-zero refund to a resource releasing certificate if also the key of
the certificate author of which is listed in the provided resource allocations.
The certificate value passed to the $\fun{refund}$ calculation is obtained from
the protocol constants based on the type of certificate (i.e. individual or pool).
The minimum and decay values are also found in the protocol constants, while
the duration is the difference between given slot number and the slot
number associated with the author's key in the resource allocation argument.

The function $\fun{keyRefunds}$, in turn, uses $\fun{certRefund}$ to calculate
the total value to be refunded to all individual key deregistration
certificate authors in a transaction.
Given protocol constants, resource allocations, and a transaction,
this calculation sums up all the refunds for the individual key
deregistration certificates
carried by the given transaction by passing the relevant parameters to the
$\fun{certRefund}$ function.

It is important to note here that instead of the \textit{current} slot number,
the time to live of $\var{tx}$ is passed to the $\fun{certRefunds}$ function
within the summation in $\fun{keyRefunds}$. The reason for this is that the
refunds for any key deregistration certificates are, in fact, included in
the $\var{tx}$ itself - meaning that the coin value of the refund must be
explicitly specified in the outputs of the transaction. So,
the value of the included refund must be calculated before this transaction
is ever processed, and be the same \textit{no matter when} $\var{tx}$
\textit{is actually processed} in order to for the system to continue to
satisfy the general accounting property.

It is impossible to predict the exact slot
number in which $\var{tx}$ will be processed, but it will be some time before
slot number $\fun{ttl}~\var{tx}$. So, this is the slot number value used in both
the calculation to generate the refund coin value in the outputs of $\var{tx}$
and in the general accounting property equation.

Note that since the refund is based
on the original deposit paid (as indicated in the protocol constants that
were valid in the time slot the deposit was made), the accounting or the slot
number do not also need to be updated in any way when updating pool constants with
a certificate.

Note also that
$\fun{keyRefunds}$ calculates the total individual refunds for a transaction
based on \textit{current} protocol constants. This means that any deposits
made prior to a change will be different from their corresponding
(decayed) refunds in the case of key deregistration after a change in
protocol constants.
The protocol constants are not
expected to change often, and using the current ones for the calculation
is a deliberate simplification choice, which does not introduce any inconsistencies
into the system rules or properties. In particular, the general accounting
property is not violated.

Finally, note that that a refund for a resource-releasing certificate in a
transaction can only be issued if the refund is bigger than the minimum
transaction fee. In order to receive a refund in this case, the transaction
body must also contain inputs onto which this refund can be added.

\begin{note}
  We define $\fun{certRefund}$ by cases on whether or not
  the refunding certificate has a corresponding
  resource creating certificate.
  If our rules are correct, then $\fun{certRefund}$
  is only called in the case where such a matching
  certificate exists.
\end{note}


\begin{figure*}
  \emph{Abstract types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      pc & \PrtclConsts & \text{protocol constants}
    \end{array}
  \end{equation*}
  %
  \emph{Abstract Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{dvalue} & \PrtclConsts \to \DCert \to \Coin
        & \text{deposit amount of a certificate}\\

      \fun{decayKey} & \PrtclConsts \to
        \Coin\times\lbrack 0, 1\rbrack\times\mathbb{Q}^{+}
        & \text{decay constants for key certificates}\\
      \fun{decayPool} & \PrtclConsts \to
        \Coin\times\lbrack 0, 1\rbrack\times\mathbb{Q}^{+}
        & \text{decay constants for pool certificates}\\

      \fun{dresource} & \Tx \to \powerset{(\DCertRegKey \uniondistinct \DCertRegPool)}
        & \text{resource allocating certificates}\\

      \fun{dderegister} & \Tx \to \powerset{\DCertDeRegKey}
        & \text{resource releasing certificates}\\

      \fun{dretire} & \Tx \to \powerset{\DCertRetirePool}
        & \text{resource releasing certificates}\\

      \fun{ttl} & \Tx \to \Slot
        & \text{time to live}\\
    \end{array}
  \end{equation*}
  \caption{Definitions used in Deposits}
  \label{fig:defs:deposits}
\end{figure*}

\begin{figure}
  \begin{align*}
    & \fun{deposits} \in \PrtclConsts \to \Allocs \to \Tx \to \Coin
    & \text{total deposits for transaction} \\
    & \fun{deposits}~{stpools}~{pc}~{tx} = \sum\limits_{c \in \fun{dresource}~tx
        \wedge \fun{author}~c \notin \dom~\var{stpools}}(\fun{dvalue}~pc~c)
      \nextdef
      & \fun{releasing} \in \DCert \to \mathsf{Bool}
      & \text{allocates resources} \\
      & \fun{releasing}~c = c \in \DCertDeRegKey \cup \DCertRetirePool\\
      \nextdef
      & \fun{refund} \in \Coin \to [0, 1] \to \mathbb{Q}^{+} \to \Duration \to \Coin
      & \text{refund calculation} \\
      & \refund{\dval}{d_{\min}}{\lambda}{\delta} =
            \floor*{
              \dval \cdot
            \left(d_{\min}+(1-d_{\min})\cdot e^{-\lambda\cdot\delta}\right)}
      \nextdef
      & \fun{certRefund} \in \Coin \to [0, 1] \to \mathbb{Q}^{+} \to \\
      & ~~~\Allocs \to \Slot \to \DCert \to \Coin
      & \text{refund for a certificate} \\
      & \certRefund{\dval}{d_{\min}}{\lambda}{allocs}{slot}{c} =\\
      & \begin{cases}
        0 & \text{if not}~(\fun{releasing}~c)\\
            0 & \text{if}~\cauthor c \notin \dom allocs\\
            \refund{\dval}{d_{\min}}{\delta}{\lambda}
            & \text{otherwise}
        \end{cases}\\
      &
      \begin{array}{lr@{~=~}l}
        \where
        &\delta & \slotminus{slot}{(allocs~(\cauthor c))}\\
      \end{array}\\
      \nextdef
      & \fun{keyRefunds} \in \PrtclConsts \to \Allocs \to \Tx \to \Coin
      & \text{key refunds for transaction} \\
      & \keyRefunds{pc}{stkeys}{tx} =\\
      &   \sum\limits_{c \in \fun{dderegister}~tx} \certRefund{pc}{stkeys}{(\ttl{tx})}{c}{}{}\\
      &
      \begin{array}{lr@{~=~}l}
        \where
        & (\dval,~d_{\min},~\lambda) & \fun{decayKey}~\var{pc}\\
      \end{array}\\
  \end{align*}
  \caption{Functions used in Deposits - Refunds}
  \label{fig:functions:deposits-refunds}
\end{figure}

We define the functions used in calculating deposits in
Figure~\ref{fig:functions:deposits-refunds}.
The $\fun{lastEpoch}$ function
returns the number of the last slot in the previous epoch.

In order to give the full expression of the general accounting property,
we need the value of the total amout of decay for all the resource releasing
certificates of a transaction who's authors key is registered. For each
certificate in this calculation, the value is computed by the map $\fun{decayed}$.
Given a set of protocol constants, resource allocations, and a slot
number, this map outputs the difference between the decayed refund calculated from
the last slot of the previous epoch of the given slot number
(or the certificate creation slot, if it is created in the same epoch as the
given slot number) and the
full-duration decayed refund value ($\fun{currentRefund}$) calculated based on
the given slot number.

The amount
decayed for individual keys is then computed by adding the values of $\fun{decayed}~\var{allocs}~\var{pc}~(\fun{ttl}~\var{tx})~\var{c}$
for each deregistration certificate in a given transaction, and is given by
$\fun{decatedTx}~\var{pc}~\var{stkeys}~\var{cslot}~\var{c}$. Here, again,
we use the $\fun{ttl}~\var{tx}$ value in the calculation instead of the current
slot number in order to match with the one in the $\fun{keyRefunds}$
calculation.

Note that the decayed amout here is only the amount that decayed \textit{within
the epoch until which the signal transaction is live}, i.e. since the end of the
last epoch before $\fun{ttl}~\var{tx}$, or, if the key was
registered in the same epoch as the $\fun{ttl}~\var{tx}$ slot,
since the registration certificate slot number.

Recall that the the stake pool retirement refunds are issued not when a certificate
scheduling the retirement is processed, but at the epoch boundary for which
the retirement is scheduled. The decayed value over the full previous epoch is
also accounted for at the boundary change. For details of this accounting, see
Section~\cref{sec:epoch}.


\begin{figure}
  \begin{align*}
      & \fun{lastEpoch} \in \Slot \to \Epoch
      & \text{(abs.) slot of last epoch} \\
      & \fun{lastEpoch}~{s} =  s - (s~\mathsf{div}~\slotsPer)
      \nextdef
      & \fun{decayedKey} \in
      \PrtclConsts \to \Allocs \to \Slot \to \DCert \to \Coin
      & \text{amount decayed since epoch} \\
      & \decayedKey{pc}{allocs}{cslot}{c} =\\
      & \begin{cases}
        0 & \text{if not}~(\fun{releasing}~c)\\
            0 & \text{if}~\cauthor c \notin \dom allocs\\
            \var{epochRefund} - \var{currentRefund}
            & \text{otherwise}
        \end{cases}\\
      &
      \begin{array}{lr@{~=~}l}
        \where
          & \var{created} & \var{allocs}~(\cauthor~\var{c}) \\
          & \var{start} & \mathsf{max}~(lastEpoch~cslot)~created \\
          & \var{epochRefund} & \certRefund{\dval}{d_{\min}}{\lambda}{allocs}{start}{c} \\
          & \var{currentRefund} & \certRefund{\dval}{d_{\min}}{\lambda}{allocs}{cslot}{c} \\
          & (\dval,~d_{\min},~\lambda) & \fun{decayKey}~\var{pc}\\
      \end{array}\\
      \nextdef
      & \fun{decayedTx} \in \PrtclConsts \to \Allocs \to \Tx \to \Coin
      & \text{decayed key deposit portions} \\
      & \decayedTx{pc}{stkeys}{tx} =\\
      &   \sum\limits_{c \in \fun{dderegister}~tx} \decayedKey{pc}{stkeys}{(\ttl{tx})}{c}\\
  \end{align*}
  \caption{Functions used in Deposits - Decay}
  \label{fig:functions:deposits-decay}
\end{figure}



\subsection{UTxO Transitions}
\label{sec:state-trans-utxo-1}

The types involved in defining a UTxO and its transitions are presented in
Figure~\ref{fig:defs:utxo}. Note that here, among other primitive types,
we introduce $\Addr_{base}$. This is the usual type of address used for
coin transfers by the transactions. We also introduce the derived type $\Addr$,
which is a disjoint union of reward and base-type addresses. Using this type,
it is possible to do rewards accounting (which we discuss later in this chapter)
in the same $\UTxO$ style as the base address coin transfers.
Similar to the certificate structure, each address is either a reward or a base
address.

The $\TxIn$ derived type represents the inputs of a transaction, i.e. a list of
previous transactions identified by $\var{txid}$, paired with an index
$\var{ix}$ to
uniquely identify the input (as there may be several inputs from the same
transaction). The $\TxOut$ type is a pair of an address and a coin value,
which is a record of what address the given coin amount is intended for.

The $\UTxO$ type is the main record type stored on the ledger to keep track of
unspent transaction outputs. It does so by using a finite map which pairs
a transaction ID with \textit{its own outputs} (by using the $\var{ix}$ indeces),
thus indicating that these
can now be spent by another transaction.

The type $\Wdrl$ is a finite map that maps a reward address to a coin value to
be withdrawn from the rewards awarded to that address. We have made the decision
to structure the withdrawals in this way to adhere as closely as possible
to the structure presented in~\cite{chimeric}.

The map $\fun{txid}$ is a one-way function which computes the $\var{txid}$
of a given transaction. A transaction can be uniquely identified
by its $\var{txid}$ in a given context.

The $\fun{txbody}$ map gives the body of the transaction, i.e. the data that is
used to update the UTxO on the ledger. The way this data is stored is in
a pair of a set of terms of type $\TxIn$ representing the inputs of the
transaction, and a finite map $\Ix \mapsto \TxOut$ representing the outputs.
Each term in the input list
corresponds to those $\TxOut$ terms in the outputs list indexed by the same
$\Ix$ as in the second coordinate of the input. This way, a transaction can have
inputs from multiple prior transactions and outputs to multiple addresses
from each of the input transactions.

The transaction fee $\fun{txfee}$ is the
fee a transaction contributes to the system (this value depends only on
the transaction itself). The fee does not need to have an explicit output
specified, and are currently implicitly included in the total input value of
a transaction.

Note that transaction fees, which can be greater than the minimum fee, are
indicated in the transactions themselves. This is different than the
the deposit amounts for registration certificates, which are
indicated explicitly in the protocol constants,
and must be paid as an amount exactly matching the protocol's requirement.
For this reason, a refund calculation for given certificate does not need to look up the deposit
amout in the data of the transaction
that paid the original registration deposit, but instead looks in the protocol
constants for this information.

The $\fun{minfee}$ is the minimum
fee that must be paid by a transaction to be applied to the current UTxO.
This minimum fee
is calculated based on the context of the transaction (i.e. a collection of
values the blockchain protocol keeps track of, $\PrtclConsts$), as well as
the contents of the transaction itself.

The $\fun{txwdrls}$ function returns a list of reward addresses provided by a
given transaction, each paired with the coin value the transaction is requesting
be reaped, i.e. removed from the the total coin accumulated in the rewards
account for this address and added to the UTxO.

We also present the abstract function $\fun{wdrlUTxO}$,
which builds UTxO entries out of withdrawal requests in a given transaction.
These new entries
allow the funds assigned to the rewards addresses to be spent like any
other unspent outputs.


\begin{figure*}
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{txid} & \TxId & \text{transaction id}\\
      %
      ix & \Ix & \text{index}\\
      %
      \var{addr} & \Addr_{base} & \text{base address}\\
      %
      c & \Coin & \text{currency value}\\
      %
      slot & \Slot & \text{slot}
    \end{array}
  \end{equation*}
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}r@{~\in~}lr}
      \var{addr}
      & \Addr
      & \var{addr}
      & \Addr_{base} \uniondistinct \AddrRWD
      & \text{address}\\
      \var{txin}
      & \TxIn
      & (\var{txid}, \var{ix})
      & \TxId \times \Ix
      & \text{transaction input}
      \\
      \var{txout}
      & \type{TxOut}
      & (\var{addr}, c)
      & \Addr \times \Coin
      & \text{transaction output}
      \\
      \var{utxo}
      & \UTxO
      & \var{txin} \mapsto \var{txout}
      & \TxIn \mapsto \TxOut
      & \text{unspent tx outputs}
      \\
      \var{wdrl}
      & \Wdrl
      & (\var{txid},~\var{a})
      & \AddrRWD \mapsto \Coin
      & \text{reward withdrawal}
    \end{array}
  \end{equation*}
  %
  \emph{Abstract Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \txid{} & \Tx \to \TxId & \text{compute transaction id}\\
      %
      \fun{txbody} & \Tx \to \powerset{\TxIn} \times (\Ix \mapsto \TxOut)
                                  & \text{transaction body}\\
      %
      \fun{txfee} & \Tx \to \Coin & \text{transaction fee}\\
      %
      \fun{minfee} & \PrtclConsts \to \Tx \to \Coin & \text{minimum fee}\\
      %
      \fun{txwdrls} & \Tx \to \Wdrl & \text{transaction withdrawals}\\

      \fun{wdrlUTxO} & \Tx \to \UTxO &
             \text{UTxO entries for withdrawals}\\
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system}
  \label{fig:defs:utxo}
\end{figure*}


A set of functions on UTxOs and transactions appearing in this document,
along with their types are defined in Figure~\ref{fig:derived-defs:utxo}.
The map $\fun{txins}$ returns the list of inputs of a given transactions, i.e.
the pairs type $\TxIn$ within that transaction.

The map $\fun{txouts}~ \var{tx}$ builds a UTxO (finite map) by taking the
list of inputs of $\var{tx}$, replacing the original $\var{txid}$ in the pair
with the $\var{txid}$ of $\var{tx}$, and mapping it to the output with the
corresponding index in the list of outputs of $\var{tx}$ (thereby making a list
of the unspent outputs of \textit{this} transaction).

The $\fun{balance}$ map, as expected, gives the sum total of all the coin in
a given UTxO. The calculation $\fun{created}$ gives the value created
by the transaction $\var{tx}$ in the context of the relevant protocol
constants, the current UTxO on the ledger, and the resource allocation for
$\DState$, i.e. $\var{stkeys}$. This calculation is a sum of all coin in the inputs of
$\var{tx}$  and the individual key
deregistration refunds of the $\var{tx}$ in this context.

Next, we define the function $\fun{reapRewards}$. The purpose of this map is
to update all the rewards accounts associated with the addresses for which
reward withdrawals are requested. Since we do only allow withdrawal of reward
amount which is exactly equal to the value in the reward account (we
give details about this below), this update explicitly sets the values
associated to the requested addresses to zero.

It gives the total coin value the given transaction creates on the ledger UTxO.
Note here that more value is added to the UTxO than the computed by this
$\var{created}$ calculation, but this value comes from

The $\fun{destroyed}$ calculation, on the other hand, sums up the
coin in the outputs of $\var{tx}$, then adds it to the fee that the transaction
has paid and the deposits made by the transaction for the certificates
registering individual keys as well as stake pools.
This calculation gives the total coin value that
the transaction removes from the current UTxO (given the necessary protocol
constants).

\begin{todo}
  The created and destroyed values here need to be corrected
\end{todo}

\begin{figure}
  \begin{align*}
    & \fun{txins} \in \Tx \to \powerset{\TxIn}
    & \text{transaction inputs} \\
    & \txins{tx} = \var{inputs} \where \txbody{tx} = (\var{inputs}, ~\wcard)
    \nextdef
    & \fun{txouts} \in \Tx \to \UTxO
    & \text{transaction outputs as UTxO} \\
    & \fun{txouts} ~ \var{tx} =
      \left\{ (\fun{txid} ~ \var{tx}, \var{ix}) \mapsto \var{txout} ~
      \middle| \begin{array}{l@{~}c@{~}l}
                 (\_, \var{outputs}) & = & \txbody{tx} \\
                 \var{ix} \mapsto \var{txout} & \in & \var{outputs}
               \end{array}
      \right\}
    \nextdef
    & \fun{balance} \in \UTxO \to \Coin
    & \text{UTxO balance} \\
    & \fun{balance} ~ utxo = \sum_{(~\wcard ~ \mapsto (\wcard, ~c)) \in \var{utxo}} c
    \nextdef
    & \fun{reapRewards} \in (\AddrRWD \mapsto \Coin) \to \Wdrl \to (\AddrRWD \mapsto \Coin) \\
        & \fun{reapRewards}~\var{rewards}~\var{wdrls} =
         \var{rewards} \unionoverrideZero \var{wdrls} \\
    \nextdef
    & \fun{created} \in \PrtclConsts \to \UTxO \to \Allocs \to \Wdrl \to \Tx \to \Coin
    & \text{value created} \\
    & \created{pc}{utxo}{stkeys}{rewards}~{tx} = \\
    & ~~\balance{(\txins{tx} \restrictdom \var{utxo})} +
        ((\sum_{(a \mapsto c) \in rewards} c) - (\sum_{(a \mapsto c) \in rr} c))  \\
        & + \keyRefunds{pc}{stkeys}{tx} \\
    &\where~rr = \fun{reapRewards}~\var{rewards}~(\fun{txwdrls}~\var{tx})\\
    \nextdef
    & \fun{destroyed} \in \PrtclConsts \to \Allocs \to \Tx \to \Coin
    & \text{value destroyed} \\
    & \fun{destroyed} ~ pc ~ stpools ~ tx = \\
    &~~\balance{(\txouts{tx})} + \balance{(\fun{wdrlUTxO}~\var{tx})} \\
      & + \txfee{tx} + \deposits{pc}{stpools}~{tx}\\
  \end{align*}

  \caption{Functions used in UTxO rules}
  \label{fig:derived-defs:utxo}
\end{figure}



The type of the transition of a UTxO is presented in Figure
~\ref{fig:ts-types:utxo}. A
transition can valid in the context of a given environment, $\UTxOEnv$.
This environment is made up of several variables.
The $\PrtclConsts$ is needed as part of the environment here in order to
keep track of parameters such as the $\fun{minfee}$ value, deposits, etc.
The environment also has variables $\var{stkeys}$ and $\var{stpools}$
to keep track of the current individual and pool resource allocations, and
the current slot number.

The relevant state variables for a UTxO transition include the UTxO itself,
as well as the value in the deposits pool and the fees pool.
The type of UTxO update is a $\UTxOState$ transition signaled by
a transaction $\var{tx}$ in the environment $\UTxOEnv$.


\begin{figure}
  \emph{UTxO environment}
  \begin{equation*}
    \UTxOEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pc} & \PrtclConsts & \text{protocol constants}\\
        \var{stkeys} & \Allocs & \text{stake key allocations}\\
        \var{stpools} & \Allocs & \text{stake pool allocations}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{UTxO States}
  \begin{equation*}
    \UTxOState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{utxo} & \UTxO & \text{UTxO}\\
        \var{deposits} & \Coin & \text{deposits pool}\\
        \var{fees} & \Coin & \text{fee pool}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{UTxO transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{utxo}{\_} \var{\_}
    \subseteq \powerset (\UTxOEnv \times \UTxOState \times \Tx \times \UTxOState)
  \end{equation*}
  %
  \caption{UTxO transition-system types}
  \label{fig:ts-types:utxo}
\end{figure}

The inference rule for unspent outputs are presented in
Figure~\ref{fig:rules:utxo}.
Rule~\ref{eq:utxo-inductive} specifies the conditions under which a transaction can
be applied to a particular $\UTxOState$ in environment $\UTxOEnv$:

\begin{itemize}
\item The trasaction is live (its time to live is less than the current slot)
\item The transaction has at least one input
\item The fee paid by the transaction has to be greater than or equal to the
minimum fee.
\item Each input spent in the transaction must be in the set of unspent
  outputs
\item All the pool retirement certificates in the transaction schedule the
retirement for some time after the lifetime of the transaction is over
\item The amount of coin created by the transaction must be the same as
the amount destroyed (i.e. the \textit{preservation of value} must hold)
\end{itemize}

The condition on the retirement certificates is necessary because without it,
there is nothing stopping the rest of the transaction from being processed except
the retirement certificates scheduling the retirement too soon (i.e. potentially
in a past epoch).

Note that the fee paid by a transaction is required to be greater than or
equal to the minim fee. The reason for allowing it to be greater is to have
the option for the implementation to make processing decisions based on the
size of the fee. Such as, a larger fee would result in faster processing of
a transaction.

The transaction is required to have at least one input to avoid a situation
where the witnessing replay protection may fail. Specifically, when a transaction is
spending only refunds from deregistration or retirement certificates it is
carrying.

Here we again emphasize the importance of the \textit{preservation of value}
condition. No valid UTxO state can be reached without this condition
being satisfied at every step of the transitions leading to a given UTxO state.
Since the total amout of Ada at genesis is known, this property can be
checked for arbitrarily generated valid ledgers.

According to this rule, when a UTxO state update is triggered by a
transaction (signal) $\var{tx}$, and the above conditions are met, the UTxO
changes as follows:

\begin{itemize}
\item remove from the UTxO all the $(\var{txin}, \var{txout})$ pairs
associated with the $\var{txins}$'s in the $\var{inputs}$ list of $\var{tx}$.
\item add all the $\var{outputs}$ of $\var{tx}$ to the
UTxO, now associated with the $\fun{txid}~\var{tx}$ instead (so they can
now be spent by future transactions)
\item add all the entries generated from the rewards addresses, the transaction's
$\var{txid}$, and amounts requested to the current UTxO
\end{itemize}

Note here that newly generated and added to the ledger UTxO reward withdrawal
entries have a list of inputs that is entirely disjoint from the list of
existing UTxO entries due to the way it is generated.
The $\var{deposits}$ is updated by:

\begin{itemize}
\item add all the deposits for individual and key registration certificates
carried by the signal transaction to the current $\var{deposits}$ value on the ledger
\item subtract from the current $\var{deposits}$ value on the ledger
the amount by which the deposits for the individual key allocations
for which $\var{tx}$ carries the deregistration certificates have
decayed \textit{this epoch}
\item subtract any individual key refunds for deregistration certificates
in $\var{tx}$ from the current $\var{deposits}$ value on the ledger
\end{itemize}

Note that the $\var{refunded}$ and $\var{decayed}$ values added together give what the
full, non-decayed refund for all the key deregistration certificates in $\var{tx}$
would be, and this total value is always removed from the $\var{deposits}$
amount on the leger. The $\var{refunded}$ amount is returned to the certificate
author, and the $\var{decayed}$ amount is transferred over to $\var{fees}$
(this allows the ledger to adhere to the preservation of value).

Note also that the reason only the decayed value of requested refunds
from \textit{this epoch} is transferred to fees is that at the epoch
boundary, the total decayed value for the whole epoch for both the individual
and pool deposits is transferred into the fees (independent of refund
requests).

Recall here that the refunds must be included in the body of the transaction
carrying the deregistration certificates (requesting these refunds). It is the job
of the wallet to calculate the value of these refunds, and generate the
correct lists of inputs and outputs of $\var{tx}$ such that it results in a
valid ledger update adding correct amounts of coin to addresses belonging
to the certificate author. This ledger transition rule simply makes sure
via the preservation of value condition that the correct amount in unspent
outputs becomes available on the UTxO due to these refund claims (as well
as all the other accounting).

Now, the fees are updated by:

\begin{itemize}
\item add the transaction fee paid by the signal transaction to the ledger $\var{fees}$
variable
\item add the dacayed value of key refunds in certificates in $\var{tx}$ to $\var{fees}$
\end{itemize}


\begin{figure}
  \begin{equation}\label{eq:utxo-inductive}
    \inference[UTxO-inductive]
    { \ttl tx < \var{slot}
      & \txins{tx} \neq \emptyset
      & \minfee{pc}{tx} \leq \txfee{tx}
      & \txins{tx} \subseteq \dom \var{utxo}
      \\
      \forall \fun{dcerts}~tx,~\var{c}\in\DCertRetirePool \Rightarrow
          ~\fun{ttl}~{tx} < \fun{slot} (\fun{retire}~{c})
      \\
      \created{pc}{utxo}{stkeys}{rewards}~{tx} = \destroyed{pc}{stpools}~{tx}
      \\
      ~
      \\
      \var{refunded} = \keyRefunds{pc}{stkeys}~{tx}
      \\
      \var{decayed} = \decayedTx{pc}{stkeys}~{tx}
      \\
      \var{depositChange} = (\deposits{pc}~{stpools}~{tx}) - (\var{refunded} + \var{decayed})
      \\
      \var{wd} = \fun{wdrlUTxO}~(\fun{txwdrls}~{tx})
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pc}\\
        \var{stkeys}\\
        \var{stpools}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
      \end{array}
      \right)
      \trans{utxo}{tx}
      \left(
      \begin{array}{r}
        (\txins{tx} \subtractdom \var{utxo}) \cup \txouts{tx} \cup \var{wd}  \\
        \var{deposits} + \var{depositChange} \\
        \var{fees} + (\txfee{tx}) + \var{decayed} \\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:rules:utxo}
\end{figure}


\begin{note}
  $\Coin$ is defined as a primitive type, but there is a difference
  between implementing it with $\mathbb{N}$ versus $\mathbb{Z}$.
  Since this is a pure UTxO ledger, $\mathbb{N}$ suffices.
  If, however, $\mathbb{Z}$ is used, then extra validation is required
  to ensure that all $\TxOut$ are non-negative.
  This extra condition would be added to \cref{eq:utxo-inductive}.
\end{note}

%\subsection{Properties}
%\label{sec:utxo-properties}

\subsection{Rewards Ledger Update}
\label{sec:utxo-rewards}

We now describe how key holders can reap the rewards calculated and added to
their rewards accounts. A request to collect rewards from a particular reward
address can be sent at any time as part of the $\Wdrl$ list of a transaction.
We give the transition type for processing this reward request in
Figure~\ref{fig:delegation-rewards-type}. It is a $\DWState$ transition with a
$\var{wdrls}$ list as a signal.

\begin{figure}
\begin{equation*} \label{eq:rewards-upd}
  \_ \vdash \_ \trans{delrwds}{\_} \_ \in
    \powerset (\DWEnv \times \DWState \times \Wdrl \times \DWState)
\end{equation*}
\caption{Delegation Rewards Update Types}
\label{fig:delegation-rewards-type}
\end{figure}

We also give the type of the complete $\DWState$
transition, which combines both the certificates and reward
requests in a single transaction in Figure~\ref{fig:delegation-total-type}.

\begin{figure}
\begin{equation*} \label{eq:dstate-total}
  \_ \vdash \_ \trans{delegt}{\_} \_ \in
    \powerset (\Slot \times \DWState \times \Tx \times \DWState)
\end{equation*}

\caption{Delegation Rewards Update Types}
\label{fig:delegation-total-type}
\end{figure}

In the following Figure~\ref{fig:delegation-rewards}, we present the inference
rule for updating the rewards to reflect the withdrawals a transaction makes
via the DELRWDS transition. We require that the rule can only be applied when
all the withdrawal addresses in the signal variable
are to addresses where rewards accumulated (i.e. in $\dom \var{rewards}$), and
that the request is for the exact amount that is currently in the requested
rewards addresses. Both of these conditions are ensured by the one
precondition we give.

The reason we impose the restriction that it is only possible to withdraw
the exact available amount of rewards in an address is that we do not see
a specific reason of why it would be necessary to withdraw a smaller amount.
Not making it possible to split reward withdrawals into several operations
of partial withdrawals is also likely to cut down on traffic and increas
processing speed.
Additionally, it allows us to avoid any issues pertaining to mathematical
modeling subtraction, managing negative values, and the integers vs. natural
numbers datatype concern.

\begin{figure}
  \centering
  \begin{equation}\label{eq:rewards-rule}
    \inference[Dist-Rew]
    {
    \var{wdrls} \subseteq \var{rewards}
    }
    {
    {
      \begin{array}{l}
        tx \\
        slot
      \end{array}
    }
      \vdash
      \left(
      \begin{array}{r}
        \var{stkeys} \\
        \var{rewards} \\
        \var{delegations} \\
        \var{pstate}
      \end{array}
      \right)
      \trans{delrwds}{\var{wdrls}}
      \left(
      \begin{array}{rcl}
        \var{stkeys} \\
        \fun{reapRewards}~\var{rewards}~\var{wdrls}\\
        \var{delegations} \\
        \var{pstate}
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Delegation Rewards Update Rule}
  \label{fig:delegation-rewards}
  \end{figure}

In Figure~\ref{fig:delegation-total}, we present the inference rule for
the total delegation state transition. This rule is a composition of the
DELRWDS rule above and the DELEGS $\DWState$ transition defined in
Section~\ref{sec:delegation}. Several conditions must be satisfied for this
rule to be applied:

\begin{itemize}
\item A transaction cannot register a key and simultaneously request
rewards to the associated address
\item A transaction is forced to include reward requests for all addresses
associated with any key that is being deregistered
\item A transaction cannot request to deregister an individual key
associated with a stake pool which is scheduled to retire
\end{itemize}

With these checks in place, there are never any unclaimed rewards left over
in the accounts, so we do not need to clean these up. There are also
no orphaned pools left over without associated stake keys.

In the consequent transition of this total rule, the DELRWDS transition is
applied first in the composition
because this allows the signal transaction to collect rewards
and deregister the key of that rewards address in the same transaction. The
complete delegation state transition is triggered by a signal transaction
since multiple parts of the transaction data are required here. The rewards
update is triggered by the withdrawals list part of the transaction, and the
rest of the delegation state update is triggered by the cetificate list.


  \begin{figure}
    \centering
    \begin{equation}\label{eq:dstate-tot-r}
      \inference[Dstate-Tot]
      {
      \Gamma = \dcerts{tx} \\
      \var{wdrls} = \fun{txwdrls}~{tx} \\
      \forall \var{c}\in \Gamma, \var{c}\in\DCertRegKey \Rightarrow
        \addrRw~(\fun{author}~{c}) \notin \dom \var{wdrls} \\
      \forall \var{c}\in \Gamma, \var{c}\in\DCertDeRegKey \Rightarrow
        \addrRw~(\fun{author}~{c}) \in \dom \var{wdrls} \\
      \forall \var{c}\in \Gamma, \var{c}\in\DCertDeRegKey \Rightarrow
        \fun{author}~{c} \notin \dom \var{retiring} \\ ~ \\
      {
        \begin{array}{l}
          tx \\
          slot
        \end{array}
      }
      \vdash
      dwstate \trans{delrwds}{\var{wdrls}} dwstate'
      {
        \begin{array}{l}
          tx \\
          slot
        \end{array}
      }
      \vdash
      dwstate' \trans{delegs}{\Gamma} dwstate'' \\
      }
      {
      {
        \begin{array}{l}
          slot
        \end{array}
      }
        \vdash
        \left(
        \begin{array}{r}
          \var{dwstate}
        \end{array}
        \right)
        \trans{delegt}{\var{tx}}
        \left(
        \begin{array}{rcl}
          \var{dwstate''}
        \end{array}
        \right)
      }
    \end{equation}

\caption{Delegation Complete Update Rule}
\label{fig:delegation-total}
\end{figure}



\subsection{Witnesses}
\label{sec:witnesses}

The definitions needed to add witnessing to the UTxO transitions described above
are presented in Figure~\ref{fig:defs:utxow}. A transaction is witnessed by
a signature and a verification key corresponding to this signature, which can
be obtained from the the transaction by applying the $\fun{wits}$ function. The
$\fun{hashKey_{spend}}$ map associates to an address the hash of the spending key
at this address.

\begin{figure}
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{wits} & \Tx \to \powerset{(\VKey \times \Sig)}
      & \text{witnesses of a transaction}\\
      \fun{hashKey_{spend}} & \Addr \mapsto \HashKey
      & \text{hashKey of a spending key in an address}\\
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system with witnesses}
  \label{fig:defs:utxow}
\end{figure}

In Figure~\ref{fig:derived-defs:utxow}, we give the definitions of two maps
associated with a UTxO. The first, $\fun{addr}$, gives the finite map
which associates to a given $\var{txin}$ in the UTxO the address of the
corresponding $\var{txout}$. The map $\fun{addr_h}$, given a UTxO, returns the
finite map which associates $\var{txin}$ with the hash of a spending key in
the address in the corresponding $\var{txout}$ in the UTxO.

\begin{figure}
  \begin{align*}
    & \addr{}{} \in \UTxO \to \TxIn \mapsto \Addr & \text{address of an input}\\
    & \addr{utxo} = \{ i \mapsto a \mid i \mapsto (a, \wcard) \in \var{utxo} \} \\
    \nextdef
    & \fun{addr_h} \in \UTxO \to \TxIn \mapsto \HashKey & \text{hashKey of an input address}\\
    & \fun{addr_h}~utxo = \{ i \mapsto h \mid i \mapsto (a, \wcard) \in \var{utxo}
      \wedge a \mapsto h \in \fun{hashKey_{spend}} \}
  \end{align*}
  \caption{Functions used in rules witnesses}
  \label{fig:derived-defs:utxow}
\end{figure}


Note that the UTxO transitions with and without witnesses have the same type
(see Figure~\ref{fig:ts-types:utxo} and Figure~\ref{fig:ts-types:utxow}).
The witnessed transition rule, in fact, defines the same UTxO update as the
non-witnessed rule. Essentially, the witnessed rule says we may only apply the
the non-witnessed rule whenever the following
additional preconditions are satisfied
(stated in Rule~\ref{eq:utxo-witness-inductive} in
Figure~\ref{fig:rules:utxow}):

\begin{itemize}
 \item For each input $\var{i}$ of the signal transaction $\var{tx}$,
 there exists a (unique) verifiable witness (there could be more than one valid
 key-signature pair serving as a witness) such that the hash of the spending key
 of the address corresponding to the output of $\var{i}$ in the current UTxO
 is the same as the hash of the verification key of the witness.

 \item For every withdrawal request address of $\var{tx}$,
 there exists a (unique) verifiable witness such the hash of the spending key of the
 withdrawal address is the same as the hash of the verification key of the witness.
\end{itemize}

The purpose of witnessing is make sure that the intended action is authorized by
the holder of the signing key, providing replay protection as a
consequence.
Due to the nature
of UTxO stype accounting, this replay protection is needed only to prevent
the re-application of old certificates. The way this is
achieved by the above precondition is by requiring a valid signature on
the coin transfers made by the transaction (the body of the transaction).

Here, we also enforce the condition that only one witness per input and one
witness per withdrawal address is allowed. We do so to prevent transactions
being unnecessarily large and full of redundant witnessing.

Note that an unauthorized (non-witnessed) reward request would still result in
rewards being given out to the correct address, but here we add the
witnessing feature to make sure only whoever is in
control of the reward address is able to make reward withdrawal requests.

We enforce the condition here that the list of inputs of a transaction can never be empty.
So, since all the inputs of an applied transaction have already been included
in the current UTxO, it may not be replayed with the same inputs. Thus,
it must also have a different signature. This would prevent it from
being applied to the UTxO.

\begin{figure}
  \emph{UTxO with witness transitions}
  \begin{equation*}
    \var{\_} \vdash
    \var{\_} \trans{utxow}{\_} \var{\_}
    \subseteq \powerset (\UTxOEnv \times \UTxOState \times \Tx \times \UTxOState)
  \end{equation*}
  \caption{UTxO with witness transition-system types}
  \label{fig:ts-types:utxow}
\end{figure}


\begin{figure}
  \begin{equation}
    \label{eq:utxo-witness-inductive}
    \inference[UTxO-wit]
    {
      {
        \begin{array}{l}
        \var{utxoEnv}
        \end{array}
      }
      \vdash \var{utxoSt} \trans{utxo}{tx} \var{utxoSt'}\\
      ~ \\
      \forall i \in \txins{tx} \cdot \exists! (\var{vk}, \sigma) \in \wits{\var{tx}}
      \cdot \\
      \mathcal{V}_{\var{vk}}{\serialised{\txbody{tx}}}_{\sigma}
      \wedge  \fun{addr_h}~{utxoSt}~i = \hashKey{vk}\\
      ~ \\
      & \forall (a \mapsto c) \in \txwdrls{tx} \cdot \exists! (\var{vk}, \sigma) \in \wits{\var{tx}}
      \cdot \\
      \mathcal{V}_{\var{vk}}{\serialised{(\txbody{tx}, a)}}_{\sigma}
      \wedge \fun{hashKey_{spend}} \var{a} = \hashKey{vk}\\
    }
    {
      \begin{array}{l}
        \var{utxoEnv}
      \end{array}
      \vdash \var{utxoSt} \trans{utxow}{tx} \var{utxoSt'}
    }
  \end{equation}
  \caption{UTxO with witnesses inference rules}
  \label{fig:rules:utxow}
\end{figure}

\subsection{Ledger State Transition}
\label{sec:ledger}

Having formalized the transitions of state variables above, we can
now combine these into a single a ledger transition type (and inference rule).
The environment for this rule is parametrized by the current slot number and
protocol constants.

The full ledger state consists of a $\UTxOState$ state variable (keeping track of
the UTxO, deposits, fees, etc.), as well as
a $\DWState$ state variable (which keeps track of registered keys and pools).
This state type and the type of the transition rule is given in
(see Figure~\ref{fig:ts-types:ledger}). The ledger state transition is signaled
by a transaction.

\begin{figure}
  \emph{Ledger environment}
  \begin{equation*}
    \LEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pc} & \PrtclConsts & \text{protocol constants}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Ledger state}
  \begin{equation*}
    \LState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{utxoSt} & \UTxOState & \text{UTxO state}\\
        \var{dwstate} & \DWState & \text{delegation witnesess state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Ledger transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{ledger}{\_} \var{\_}
    \subseteq \powerset (\LEnv \times \LState \times \Tx \times \LState)
  \end{equation*}
  \caption{Ledger transition-system types}
  \label{fig:ts-types:ledger}
\end{figure}

The inference rule describing the complete ledger state transition is given in
Figure~\ref{fig:rules:ledger}. The consequent of the rule is triggered by
a transaction $\var{tx}$ such that both the (witnessed) ledger state transition
and the complete delegation state tranition in the antecedent are
triggered by that same transaction.

Note that the context for the consequent transaction is made up of only the
protocol constants and slot number, and so is the delegation state transition in
the antecedent. However, the $\UTxOState$ transition also contains the the
stake keys and stake pools resource allocations in the context. This is not
an issue since all this difference is highlighting is that in a $\UTxOState$
transition, these variables are immutable (but they do change in the full
ledger state and the $\DWState$ transitions).

The full ledger state transition combines the UTxO transition and the
delegation transition into a single transition
in the consequent, presented as a transition of both state variables signaled
by the given transaction.

\begin{figure}
  \begin{equation}
    \label{eq:ledger}
    \inference[ledger]
    {
      {
        \begin{array}{r}
        slot\\
        pc\\
        stkeys\\
        stpools\\
        \end{array}
      }
      \vdash \var{utxoSt} \trans{utxow}{tx} \var{utxoSt'}\\~\\~\\
      %
      {
        \begin{array}{l}
          slot \\
        \end{array}
      }
      \vdash
      dwstate \trans{delegt}{\var{tx}} dwstate'
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pc}\\
      \end{array}
      \vdash
      \left(
        \begin{array}{ll}
          utxoSt \\
          dwstate \\
        \end{array}
      \right)
      \trans{ledger}{tx}
      \left(
        \begin{array}{ll}
          utxoSt' \\
          dwstate' \\
        \end{array}
      \right)
    }
  \end{equation}
  \caption{Ledger inference rule}
  \label{fig:rules:ledger}
\end{figure}

\clearpage

\section{Epoch Boundary}
\label{sec:epoch}
\input{epoch.tex}

\clearpage

\section{Properties}
\label{sec:properties}


\input{properties}

\addcontentsline{toc}{section}{References}
\bibliographystyle{plainnat}
\bibliography{references}

\end{document}
