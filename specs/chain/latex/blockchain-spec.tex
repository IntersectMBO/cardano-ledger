\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage{extarrows}
\usepackage{float}
\usepackage[margin=2.5cm]{geometry}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{listings}
\usepackage{mathpazo} % nice fonts
\usepackage{mathtools}
\usepackage{microtype}
\usepackage[colon]{natbib}
%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
\usepackage{slashed}
\usepackage{stmaryrd}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\hypersetup{
  pdftitle={Specification of the Blockchain Layer},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\floatstyle{boxed}
\restylefloat{figure}

%% Setup for the semantic package
\setpremisesspace{20pt}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

%%
\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand\Set[2]{\left\{\,#1\mid#2\,\right\}}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\size}[1]{\left| #1 \right|}
\newcommand{\trans}[2]{\xlongrightarrow[\textsc{#1}]{#2}}
\newcommand{\seqof}[1]{#1^{*}}
\newcommand{\nextdef}{\\[1em]}
\newcommand{\serialised}[1]{\llbracket \var{#1} \rrbracket}

% Partial and total function aliases
\newcommand{\totalf}{\to}
\newcommand{\partialf}{\mapsto}

%%
%% Types
%%
\newcommand{\Hash}{\type{Hash}}  % hashes of various things, including blocks
\newcommand{\Slot}{\type{Slot}}
\newcommand{\BlockIx}{\type{BlockIx}}
\newcommand{\Block}{\type{Block}}
\newcommand{\DCert}{\type{DCert}}
\newcommand{\Queue}{\type{Q}}

\newcommand{\VKey}{\type{VKey}}
\newcommand{\VKeyGen}{\type{VKey_G}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
\newcommand{\DelegState}{\type{DIState}}

\newcommand{\ProtParams}{\type{PParams}} % protocol parameters

%%
%% Function and relation names
%%
\newcommand{\bsizename}{bSize}
\newcommand{\bhdrsizename}{bHeaderSize}
\newcommand{\verifyname}{verify}
\newcommand{\signmapname}{\mathcal{M}}
\newcommand{\trimixname}{trimIx}
\newcommand{\incixmapname}{incIxMap}

\newcommand{\isebbname}{bIsEBB}
\newcommand{\bcertsname}{bCerts}
\newcommand{\bsigname}{bSig}
\newcommand{\bissuername}{bIssuer}

\newcommand{\qrestrname}{qRestrict}
\newcommand{\qpopname}{qPop}
\newcommand{\qheadname}{qHead}
\newcommand{\qpushname}{qPush}

%%
%% Functions and relations
%%
\newcommand{\verify}[3]{\fun{\verifyname} ~ #1 ~ #2 ~ #3}
\newcommand{\bsize}[1]{\fun{\bsizename} ~ #1}
\newcommand{\bhdrsize}[1]{\fun{\bhdrsizename} ~ #1}
\newcommand{\delegation}[2]{\fun{\delegationname} ~ #1 ~ #2}
\newcommand{\signmap}[1]{\fun{\signmapname} ~ #1}
\newcommand{\qrestr}[2]{\fun{\qrestrname} ~ #1 ~ #2}
\newcommand{\trimix}[2]{\fun{\trimixname} ~ #1 ~ #2}
\newcommand{\incixmap}[3]{\fun{\incixmapname} ~ #1 ~ #2 ~ #3}

\newcommand{\hashofblock}[1]{\fun{\hashofblockname} ~ #1}
\newcommand{\blocksizelimit}[2]{\fun{\blocksizelimitname} ~ #1 ~ #2}
\newcommand{\isebb}[1]{\fun{\isebbname} ~ #1}
\newcommand{\bcerts}[1]{\fun{\bcertsname} ~ #1}
\newcommand{\bsig}[1]{\fun{\bsigname} ~ #1}
\newcommand{\bissuer}[1]{\fun{\bissuername} ~ #1}

\newcommand{\qpop}[1]{\fun{\qpopname} ~ #1}
\newcommand{\qhead}[1]{\fun{\qheadname} ~ #1}
\newcommand{\qpush}[1]{\fun{\qpushname} ~ #1}


% A type alias for a map from a genesis block verification key to a queue of indices
\newcommand{\mapqueue}{\mathcal{Q}}
% comments
\newcommand{\marko}[1]{\todo[size=\small, color=yellow!40, inline]{Marko: #1}}

\begin{document}

\title{Specification of the Blockchain Layer}

\author{Marko DimjaÅ¡eviÄ‡}

\date{December 13, 2018}

\maketitle

\begin{abstract}
  This documents defines inference rules for operations on a blockchain as a
  specification of the blockchain layer of Cardano in the Byron release and in
  a transition to the Shelley release.
  %
  In particular, a block validity definition is given, which is accompanied by
  small-step operational semantics inference rules.
\end{abstract}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}

The idea behind this document is to formalise what it means for a new block to
be added to the blockchain to be valid.
%
The scope of the document is the Byron release and a transition phase to the
Shelley release of the Cardano blockchain platform.


Unless a new block is valid, it cannot be added to the blockchain and thereby
extend it.
%
This is needed for a system that is subscribed to the blockchain and keeps a
copy of it locally.
%
In particular, this document gives a formalisation that should be
straightforward to implement in a programming language, e.g., in Haskell.

This document is intended to be read in conjunction with \cite{byron_ledger_spec},
which covers the payload carried around in the blockchain. Certain of the
underlying systems and types defined will rely on definitions in that document.

\section{Preliminaries}
\label{sec:preliminaries}

\begin{description}
\item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
  the subsets of $X$.
\item[Sequence] Given a set $\type{X}$, $\seqof{\type{X}}$ is a sequence
  having elements taken from $\type{X}$.
  %
  The empty sequence is denoted by $\epsilon$, and given a sequence $\Lambda$,
  $\Lambda; x$ is the sequence that results from appending
  $x \in \type{X}$ to $\Lambda$.
  %
  Furthermore, $\epsilon$ is an identity element for sequence joining:
  $\epsilon; x = x; \epsilon = x$.
\item[Option type] An option type in type $A$ is denoted as $A^? = A + 1$. The
  $A$ case corresponds to a case when there is a value of type $A$ and the $1$
  case corresponds to a case when there is no value.
\item[Union override] The union override operation is defined in
  Figure~\ref{fig:unionoverride}.
  %
  \begin{figure}
    \begin{align*}
      \var{K} \restrictdom \var{M}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ i \in \var{K} \}
      & \text{domain restriction}
      \\
      \var{K} \subtractdom \var{M}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ i \notin \var{K} \}
      & \text{domain exclusion}
      \\
      \var{M} \restrictrange \var{V}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ o \in \var{V} \}
      & \text{range restriction}
      \\
      & \unionoverride \in (A \mapsto B) \to (A \mapsto B) \to (A \mapsto B)
      & \text{union override}\\
      & d_0 \unionoverride d_1 = d_1 \cup (\dom d_1 \subtractdom d_0)
    \end{align*}
    \caption{Definition of the Union Override Operation}
    \label{fig:unionoverride}
  \end{figure}
\end{description}

\subsection{Sets}
\label{sec:sets}

There are several standard sets used in the document:
%
\begin{description}
\item[Booleans] The set of booleans is denoted with $\mathbb{B}$ and has two
  values, $\mathbb{B} = \{\bot, \top\}$.
\item[Natural numbers] The set of natural numbers is denoted with
  $\mathbb{N}$ and defined as $\mathbb{N} = \{0, 1, 2, \dots\}$.
\end{description}

\section{Epoch transitions}

\newcommand{\Epoch}{\type{Epoch}}

This section should cover:
\begin{itemize}
\item How we determine the end of an epoch
\item Epoch-transition bookkeeping
\end{itemize}

The epoch transition rules should compute whether a given slot is at the end of
an epoch

\section{Counting signed blocks}

\newcommand{\BSCEnv}{\type{BSCEnv}}
\newcommand{\BSCState}{\type{BSCState}}

To guard against the compromise of a minority of the genesis keys,
we require that in the rolling window of the last $K$ blocks, the number of
blocks signed by keys that $sk_s$ delegated to is no more than a threshold $K
\cdot t$, where $t$ is a constant\footnote{This is not the same $t$ from the
  Ouroboros BFT paper draft where it denotes the number of Byzantine servers,
  though it should be somehow related to it.} that will be picked in the range
$1/5 \leq t \leq 1/4$.

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{align*}
    q  & \in \Queue_\BlockIx  & \text{block index queue}\\
  \end{align*}
  %
  \emph{Derived types}
  \begin{equation*}
  \begin{array}{r@{~\in~}l@{\qquad=\qquad}r@{~\in~}lr}
    \signmapname & \mapqueue & \signmapname & \VKeyGen \totalf \Queue_\BlockIx & \text{key to block index map}\\
    \var{bIx} & \BlockIx & \var{bIx} & \mathbb{N} & \text{Block index}
  \end{array}
  \end{equation*}
  %
  \emph{Functions and relations}
  %
  \begin{align*}
    \fun{\qheadname} & \in \Queue_\BlockIx \totalf \BlockIx^? & \text{head of queue function} \\
    \fun{\qpushname} & \in \BlockIx \times \Queue_\BlockIx \totalf \Queue_\BlockIx
      & \text{queue push function} \\
    \fun{\qpopname} & \in \Queue_\BlockIx \totalf {\Queue_\BlockIx}^?
      & \text{queue pop function} \\
    \fun{\qrestrname} & \in \BlockIx \times \Queue_\BlockIx \totalf \Queue_\BlockIx
      & \text{restricted queue pop function} \\
    \fun{\incixmapname} & \in \BlockIx \times \powerset \VKeyGen \times \mapqueue \totalf \mapqueue
      & \text{block count increment function}\\
  \end{align*}
  \emph{Protocol parameters}
  \begin{equation*}
    \begin{array}{r@{~\partialf~}l!{~\in~\ProtParams~}r}
    \fun{blockSignatureCountWindow} & \mathbb{N} & \text{Block signature count window size} \\
    \fun{blockSignatureCountThreshold} & \left[\frac{1}{5}, \frac{1}{4}\right] & \text{Block signature count threshold} \\
    \end{array}
  \end{equation*}

  \begin{align}
  \label{eq:trimix}
  \trimix{\signmapname}{\var{ix}} & = \Set{(\var{vk_s} \partialf q)}{\var{vk_s} \in \dom \signmapname.~
  q = \qrestr{\var{ix}}{(\signmap{\var{vk_s}}})} \\
  \qrestr{\var{ix}}{q} & = \
  \begin{cases}
    \qpop{q} & \text{if } \size{q} > 0 \wedge \qhead{q} + K < \var{ix} \\
    q & \text{otherwise}
  \end{cases} \\
  \label{eq:incixmap}
    \incixmap{\var{ix}}{\var{X}}{\signmapname} & = \signmapname \unionoverride
                                                 \Set{\var{vk_s} \partialf \qpush{\var{ix}}(\signmap{\var{vk_s}})}{vk_s \in \var{X}}
  \end{align}
  \caption{Blockchain signature count types and functions}
  \label{fig:defs:sigcnt}
\end{figure}

\begin{figure}[ht]
  \emph{Block signature count environments}
  \begin{equation*}
    \BSCEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pps} & \ProtParams & \text{Protocol parameters} \\
        \var{ds} & \DelegState & \text{Delegation state} \\
        \var{bIx} & \BlockIx & \text{Block index}
      \end{array}
    \right)
  \end{equation*}

  \emph{Block signature count transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{sigcnt}{\_} \var{\_} \subseteq
    \powerset (\BSCEnv \times \signmapname \times \VKey \times \signmapname)
  \end{equation*}
  \caption{Block signature count transition-system types}
  \label{fig:ts-types:sigcnt}
\end{figure}

\begin{figure}[ht]
  \begin{equation*}
    \inference
    {
      \fun{blockSignatureCountWindow} \partialf \var{K} \in pps & \fun{blockSignatureCountThreshold} \partialf \var{t} \in pps \\
      \var{D} = (\fun{dms} ~ \var{ds})^{-1} ~ \var{vk_d} & \forall \var{vk_s} \in \var{D} . \size{\signmap{\var{vk_s}}} \leq K \cdot t \\
      \signmapname' = \incixmap{\var{bIx}}{\var{D}}{(\trimix{\signmapname}{\var{bIx}})}
    }
    {
      \left(
        {\begin{array}{c}
          \var{pps} \\
          \var{ds} \\
          \var{bIx}
        \end{array}}
      \right)
      \vdash
        {\signmapname}
      \trans{sigcnt}{\var{vk_d}}
        {\signmapname'}
    }
    \label{eq:rule:sigcnt}
  \end{equation*}
  \caption{Block signature count rules}
  \label{fig:rules:sigcnt}
\end{figure}

\clearpage

\section{Block validation}
\label{sec:block-validation}

\newcommand{\BHEnv}{\type{BHEnv}}
\newcommand{\BHState}{\type{BHState}}

\newcommand{\BBEnv}{\type{BBEnv}}
\newcommand{\BBState}{\type{BBState}}

\newcommand{\Bhead}{\type{BlockHeader}}
\newcommand{\Bbody}{\type{BlockBody}}
\newcommand{\Bhtosign}{\type{BHToSign}}

\newcommand{\bheadname}{bHead}
\newcommand{\bhead}[1]{\fun{\bheadname}\ #1}
\newcommand{\bbodyname}{bBody}
\newcommand{\bbody}[1]{\fun{\bbodyname}\ #1}
\newcommand{\bhhashname}{bhHash}
\newcommand{\bhhash}[1]{\fun{\bhhashname}\ #1}
\newcommand{\bhprevhashname}{bhPrevHash}
\newcommand{\bhprevhash}[1]{\fun{\bhhashname}\ #1}
\newcommand{\bhtosignname}{bhToSign}
\newcommand{\bhtosign}[1]{\fun{\bhtosignname}\ #1}

\newcommand{\maxblocksize}{\fun{maxBlockSize}}
\newcommand{\maxheadersize}{\fun{maxHeaderSize}}

We delineate here between validating the header and body of a block. It's useful
to make this distinction since we may validate headers ahead of validating the
block body, and we have less context available to validate headers - in
particular, we must be able to validate block headers without the recent history
of block bodies.

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    b & \Block & \text{block} \\
    h & \Hash   & \text{hash} \\
    \end{array}
  \end{equation*}
  %
  %
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    \fun{\bsizename} & \Block \totalf \mathbb{N} & \text{block size in bytes} \\
    \end{array}
  \end{equation*}
  \emph{Protocol parameters}
  \begin{equation*}
    \begin{array}{r@{~\partialf~}l!{~\in~\ProtParams~}r}
    \maxblocksize & \mathbb{N} & \text{maximum block size} \\
    \end{array}
  \end{equation*}
  \caption{Basic Block-related Types and Functions}
  \label{fig:block-defs}
\end{figure}

\subsection{Block header validation}

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    bh & \Bhead & \text{Block header} \\
    bts & \Bhtosign & \text{Part of the block header which must be signed}
    \end{array}
  \end{equation*}
  %
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    \fun{\bheadname} & \Block \totalf \Bhead & \text{Block header} \\
    \fun{\bhprevhashname} & \Bhead \totalf \Hash & \text{Previous header hash} \\
    \fun{\bhhashname} & \Bhead \totalf \Hash & \text{Header hash} \\
    \fun{\bsigname} & \Bhead \totalf \Sig & \text{Block signature} \\
    \fun{\bissuername} & \Bhead \totalf \VKey & \text{Block issuer} \\
    \fun{\bhdrsizename} & \Bhead \totalf \mathbb{N} & \text{Block header size in bytes}\\
    \fun{\bhtosignname} & \Bhead \totalf \Bhtosign & \text{Block header to sign}\\
    \end{array}
  \end{equation*}
  \emph{Protocol parameters}
  \begin{equation*}
    \begin{array}{r@{~\partialf~}l!{~\in~\ProtParams~}r}
    \maxheadersize & \mathbb{N} & \text{maximum block header size} \\
    \end{array}
  \end{equation*}
  \caption{Block header validation types and functions}
  \label{fig:defs:bhead}
\end{figure}

\begin{figure}[ht]
  \emph{Block header validation environments}
  \begin{equation*}
    \BHEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pps} & \ProtParams & \text{Protocol parameters} \\
        \var{ds} & \DelegState & \text{Delegation state} \\
      \end{array}
    \right)
  \end{equation*}

  \emph{Block header validation transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{bhead}{\_} \var{\_} \subseteq
    \powerset (\BHEnv \times \Hash \times \Bhead \times \Hash)
  \end{equation*}
  \caption{Block header validation transition-system types}
  \label{fig:ts-types:bhead}
\end{figure}

\begin{figure}[ht]
  \begin{equation*}
    \inference
    { \sigma = \bsig{bh} & \var{vk_d} = \bissuer{bh} & \var{h'} = \bhhash{bh}
    \\ \maxheadersize \mapsto \var{s_{max}} \in \var{pps} & \bhdrsize{bh} \leq \var{s_{max}}
    \\  (\fun{dms} ~ \var{ds})^{-1} ~ \var{vk_d} \neq \emptyset
    \\ \bhprevhash{bh} = \var{h} & \verify{vk_d}{\serialised{\bhtosign{bh}}}{\sigma}
    }
    {
      \left(
        {\begin{array}{c}
          \var{pps} \\
          \var{ds} \\
        \end{array}}
      \right)
      \vdash
        {\var{h}}
      \trans{bhead}{\var{bh}}
        {\var{h'}}
    }
  \end{equation*}
  \caption{Block header validation rules}
  \label{fig:rules:bhead}
\end{figure}

\clearpage

\subsection{Block body validation}
\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    bb & \Bbody & \text{Block body}
    \end{array}
  \end{equation*}
  %
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    \fun{\bbodyname} & \Block \totalf \Bbody & \text{Block body} \\
    \end{array}
  \end{equation*}
  \emph{Protocol parameters}
  \begin{equation*}
    \begin{array}{r@{~\partialf~}l!{~\in~\ProtParams~}r}
    \maxblocksize & \mathbb{N} & \text{maximum block size} \\
    \end{array}
  \end{equation*}
  \caption{Block body validation types and functions}
  \label{fig:defs:bbody}
\end{figure}

\begin{figure}[ht]
  \emph{Block body validation environments}
  \begin{equation*}
    \BBEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pps} & \ProtParams & \text{Protocol parameters} \\
      \end{array}
    \right)
  \end{equation*}

  \emph{Block body validation transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{bbody}{\_} \var{\_} \subseteq
    \powerset (\BBEnv \times \emptyset \times \Block \times \emptyset)
  \end{equation*}
  \caption{Block body validation transition-system types}
  \label{fig:ts-types:bbody}
\end{figure}

\begin{figure}[ht]
  \begin{equation*}
    \inference
    { \maxblocksize \mapsto \var{b_{max}} \in \var{pps} && \bsize{b} \leq \var{b_{max}} \\
    }
    {
      \left(
        {\begin{array}{c}
          \var{pps} \\
        \end{array}}
      \right)
      \vdash
        {\var{h}}
      \trans{bbody}{\var{vk_d}}
        {\var{h'}}
    }
  \end{equation*}
  \caption{Block body validation rules}
  \label{fig:rules:bbody}
\end{figure}

\clearpage

\section{Blockchain Extension}
\label{sec:chain-extension}

\newcommand{\CEEnv}{\type{CEEnv}}
\newcommand{\CEState}{\type{CEState}}

\newcommand{\butxo}[1]{\fun{bUtxo}\ #1}
\newcommand{\bupdprop}[1]{\fun{bUpdProp}\ #1}
\newcommand{\bupdvotes}[1]{\fun{bUpdVotes}\ #1}
\newcommand{\bprotver}[1]{\fun{bProtVer}\ #1}
\newcommand{\bendorsment}[1]{\fun{bEndorsment}\ #1}

% Imported definitions
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\DIEnv}{\type{DIEnv}}
\newcommand{\DIState}{\type{DIState}}

\newcommand{\UPIEnv}{\type{UPIEnv}}
\newcommand{\UPIState}{\type{UPIState}}
\newcommand{\UProp}{\type{UProp}}
\newcommand{\Vote}{\ensuremath{\type{Vote}}}
\newcommand{\ProtVer}{\ensuremath{\type{ProtVer}}}

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{equation*}
  \begin{array}{r@{~\in~}lr}
    \var{data} & \Data    & \text{data}\\
    \var{ds} & \DelegState & \text{ledger layer delegation state}
  \end{array}
  \end{equation*}
  \emph{Abstract functions}
  %
  \begin{equation*}
  \begin{array}{r@{~\in~}lr}
    \fun{\verifyname} & \VKey \times \Data \times \Sig
      & \text{verification relation} \\
    \fun{bUtxo} & \Block \totalf \UTxO & \text{Block UTxO payload} \\
    \fun{\bcertsname} & \Block \totalf \seqof{\DCert}
      & \text{block certificates} \\
    \fun{bUpdProp} & \Block \totalf \UProp & \text{Block update proposal payload} \\
    \fun{bUpdVotes} & \Block \totalf \seqof{Vote} & \text{Block update votes payload} \\
    \fun{bProtVer} & \Block \totalf \ProtVer & \text{Block protocol version} \\
    \fun{\isebbname} & \Block \totalf \mathbb{B} & \text{epoch boundary block check} \\
  \end{array}
  \end{equation*}
  \emph{Derived functions}
  \begin{equation*}
    \begin{array}{rlr}
      \fun{bEndorsment} & \in \ProtVer \times \VKey & \text{Protocol version endorsment} \\
      \bendorsment{b} & = (\bprotver{b}, \bissuer{b})
    \end{array}
  \end{equation*}

  %
  \caption{Blockchain Extension Types and Functions}
  \label{fig:defs:chain-extension}
\end{figure}

\begin{figure}[ht]
  % \emph{Chain extension environments}
  % \begin{equation*}
  %   \CEEnv =
  %   \left(
  %     \begin{array}{r@{~\in~}lr}
  %       \var{slot} & \Slot & \text{Current slot}
  %     \end{array}
  %   \right)
  % \end{equation*}
  \emph{Chain extension states}
  \begin{equation*}
    \CEState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{bIx} & \BlockIx & \text{Current block index} \\
        \var{e_c} & \Epoch & \text{Current epoch} \\
        \signmapname & \VKeyGen \totalf \Queue_\BlockIx & \text{key to block index map} \\
        \var{h} & \Hash & \text{Current block hash} \\
        \var{utxo} & \UTxO & \text{UTxO} \\
        \var{us} & \UPIState & \text{Update interface state} \\
        \var{ds} & \DIState & \text{Delegation state}
      \end{array}
    \right)
  \end{equation*}

  \emph{Chain extension transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{chain}{\_} \var{\_} \subseteq
    \powerset (\Slot \times \CEState \times \Block \times \CEState)
  \end{equation*}

  \caption{Blockchain extension transition-system types}
  \label{fig:ts-types:chain-extension}
\end{figure}

The central rule that captures blockchain extension is given with
Figure~\ref{fig:defs:chain-extension}.

\begin{figure}
  \begin{equation*}
  \inference
  { \isebb{b} & \bsize{b} \leq 2^{21}
    \\ \var{h'} = \bhhash{(\bhead b)}
  }
  {
    \left(
      {\begin{array}{c}
         \var{slot}
       \end{array}}
    \right)
    \vdash
    \left(
      {\begin{array}{c}
         bIx \\
         \signmapname \\
         \var{h} \\
         \var{utxo} \\
         \var{us} \\
         \var{ds}
       \end{array}}
    \right)
    \trans{chain}{b}
    \left(
      {\begin{array}{c}
         bIx \\
         \signmapname \\
         \var{h'} \\
         \var{utxo} \\
         \var{us} \\
         \var{ds}
       \end{array}}
    \right)
  }
  \end{equation*}
  \vspace{20pt}
  \begin{equation*}
  \inference
  {
    \neg\isebb{b} \\
    \var{slot} \vdash \var{e_c} \trans{epoch}{} \var{e_n}
    \\
    {\left(
        \begin{array}{l}
          \var{slot} \\
          \var{e_n} \\
          \fun{dms} ~ \var{ds}
        \end{array}
      \right)}
    \vdash \var{us} \trans{upireg}{\bupdprop{b}} \var{us'}
    &&
    {\left(
        \begin{array}{l}
          \var{slot} \\
          \var{e_n} \\
          \fun{dms} ~ \var{ds}
        \end{array}
      \right)}
    \vdash \var{us'} \trans{upivotes}{\bupdvotes{b}} \var{us''}
    \\
    {\left(
        \begin{array}{l}
          \var{slot} \\
          \var{e_n} \\
          \fun{dms} ~ \var{ds}
        \end{array}
      \right)}
    \vdash \var{us''} \trans{upiend}{\bendorsment{b}} \var{us'''}
    \\
    {\left(
        \begin{array}{l}
          \fun{pps} ~  us \\
          ds
        \end{array}
      \right)}
    \vdash
    \var{h} \trans{bhead}{\bhead{b}} \var{h'} &
    \fun{pps} ~  us \vdash \var{utxo} \trans{utxow}{\butxo{b}} \var{utxo'} \\
    {\left(
      \begin{array}{l}
        \fun{pps} ~  us \\
        ds \\
        bIx
      \end{array}
    \right)}
    \vdash
    \signmapname \trans{sigcnt}{\var{vk_d}} \signmapname' &&
    \var{diEnv} \vdash \var{ds} \trans{deleg}{\bcerts{b}} \var{ds'}
  }
  {
    \left(
      {\begin{array}{c}
         \var{slot}
       \end{array}}
    \right)
    \vdash
    \left(
      {\begin{array}{c}
         bIx \\
         e_c \\
         \signmapname \\
         \var{h} \\
         \var{utxo} \\
         \var{us} \\
         \var{ds}
       \end{array}}
    \right)
    \trans{chain}{b}
    \left(
      {\begin{array}{c}
         bIx + 1 \\
         e_n \\
         \signmapname' \\
         \var{h'} \\
         \var{utxo}' \\
         \var{us'''} \\
         \var{ds'}
       \end{array}}
    \right)
  }
  \end{equation*}
  \caption{Blockchain extension rules}
  \label{fig:blockchain-extension}
\end{figure}
\clearpage
\bibliographystyle{plainnat}
\bibliography{references}
\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% LaTeX-command: "nix-shell --run make"
%%% End:
