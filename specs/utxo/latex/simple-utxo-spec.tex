\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
%\usepackage[a-1b]{pdfx}
\usepackage{microtype}
\usepackage{mathpazo} % nice fonts
\usepackage{amsmath, amssymb, stmaryrd, latexsym, mathtools}
\usepackage{extarrows}
\usepackage{slashed}
\usepackage[colon]{natbib}
\usepackage{todonotes}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\hypersetup{
  pdftitle={A Simplified Formal Specification of a UTxO Ledger},
  pdfauthor={Duncan Coutts},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={black},
  citecolor={black},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand{\sequencetype}[1]{#1^\star}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\subtractrange}{\mathbin{\slashed{\restrictrange}}}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\serialised}[1]{\llbracket #1 \rrbracket}
\newcommand{\signed}[2]{\llbracket #1 \rrbracket_{#2}}
\newcommand{\verified}[3]{\fun{verify} ~ #1 ~ \llbracket #2 \rrbracket ~ #3}
\newcommand{\size}[1]{\left| #1 \right|}
\newcommand{\transitionarrow}[2]{\xlongrightarrow[\textsc{#1}]{#2}}
\renewcommand{\mod}{\mathbin{\fun{mod}}}

\begin{document}

\title{A Simplified Formal Specification of a \\ UTxO Ledger and Blockchain Protocol \\
       {\small (Version 0.1)} \\
       {\large \sc An internal IOHK technical report}}
\author{Duncan Coutts \\ {\small \texttt{duncan@well-typed.com}} \\
                         {\small \texttt{duncan.coutts@iohk.io}}}
\date{September 3, 2018}

\maketitle

\begin{abstract}
This document is intended as an aid to understanding approaches to formally
specifying key parts of the Cardano system. We look at hopefully-appropriate
styles of formal specification. We look at highly simplified but concrete
examples of key components: a blockchain protocol and a UTxO ledger.
\end{abstract}

\tableofcontents
\listoffigures

\subsection*{Version history}

\begin{description}
\item[Version 0.1, September 3, 2018] Initial draft.
\end{description}

\section{Introduction}

Of course with trying to specify things formally we want to simplify and
separate those things that can be separated. Separation and composition are
key to taming complexity and enabling the correct the construction of complex
systems.

A useful insight is that while blockchain protocols and cryptocurrency ledgers
are clearly related and do interact, they can be described in isolation.
Indeed the original paper on Ouroboros by \citet{ouroboros_classic} describes
only a blockchain protocol and says relatively little about what data might go
onto the blockchain, except what is needed to establish a stake distribution.

So we will look at each part in isolation as far as possible. It turns out
that specifying ledgers is easier since they can be described without
concurrency, whereas blockchain protocols are inherently concurrent, and
concurrency is somewhat more tricky to handle formally.

Another key insight is that a formal specification is an abstraction, meaning
that it deliberately ignores certain details. Part of the art of specification
is knowing what details to ignore. Ignoring certain details lets one
concentrate on what remains. One typically ignores what is easy to allow one
to concentrate on what is hard. Thus it is not surprising to see multiple
specifications of ``the same thing'' which differ by covering more or less
detail or simply different details.

\section{A UTxO Ledger}

There are different ways of formally specifying ledgers, specifically the rules
of a ledger. A key property of a ledger is what is a valid ledger. Another
somewhat more vague concept is the `state' of a ledger and what information we
know or what we can conclude from a ledger.

While ledgers typically sit on top of blockchains, or rather as the data within
a blockchain, they can be described in isolation. Indeed this is an important
simplification since it allows them to be described without covering the
details of how the consensus is arrived at. For example, operationally, an
implementation must deal with switching chain forks and correspondingly must
handle the switch in the tail of the ledger. What a valid ledger \emph{is},
however, can be specified as if it were a completely static entity -- just a
sequence -- without dealing with changes to that sequence.

Another simplification is that we typically don't need to consider a sequence
of blocks of ledger transactions but can instead consider just sequences of
ledger transactions without needing to consider any block structure.

One approach to specifying what makes a valid ledger is to do so as a whole:
that is to specify a property that is true or false of a ledger as a whole. For
example \citet{utxo_accounting} specifies both UTxO and account style ledgers
by stating a logical property of the whole ledger.

A style of specification that is more helpful as a guide for an implementation
is one which constructively describes how to compute if a ledger is valid, and
does so incrementally in the same order that an implementation must process it.
A helpful specification style here is as a \emph{state transition system}. This
is a very operational style that specifies the state that must be maintained
and how that state is updated for each transition -- which in this case is the
ledger entries.

\subsection{Set theory and predicate logic as a specification language}

There are different ways of presenting state transition systems. We will show
two equivalent presentations of the same example: a simple UTxO style ledger.
We start with some common basic definitions in \cref{fig:basic_definitions}.

\begin{figure}

\emph{Primitive types}
%
\begin{equation*}
\begin{array}{r@{~\in~}lr}
  \var{txid}
& \type{TxId}
& \text{transaction id}
\\
  ix
& \type{Ix}
& \text{index}
\\
  \var{addr}
& \type{Addr}
& \text{address}
\\
  c
& \type{Coin}
& \text{currency value}
\end{array}
\end{equation*}
%
\emph{Derived types}
%
\begin{equation*}
\begin{array}{r@{~=~}l@{}r@{~\in~}lr}
  \type{Tx}
& \powerset{\type{TxIn}} \times (\type{Ix} \mapsto \type{TxOut})
& (\var{txins}, \var{txouts})
& \type{Tx}
& \text{transaction}
\\
  \type{TxIn}
& \type{TxId} \times \type{Ix}
& (\var{txid}, \var{ix})
& \type{TxIn}
& \text{transaction input}
\\
  \type{TxOut}
& \type{Addr} \times \type{Coin}
& (\var{addr}, c)
& \type{TxOut}
& \text{transaction output}
\\
  \type{UTxO}
& \type{TxIn} \mapsto \type{TxOut}
& \var{txin} \mapsto \var{txout} \in \var{utxo}
& \type{UTxO}
& \text{unspent outputs}
\\
  \type{Ledger}
& \sequencetype{\type{Tx}}
& \epsilon ; \var{tx}_1 ; \ldots ; \var{tx}_n 
& \type{Ledger}
& \text{transaction ledger}
\end{array}
\end{equation*}
%
\emph{Functions}
%
\begin{equation*}
\begin{array}{lr}
  \fun{txid} \in \type{Tx} \to \type{TxId}
& \text{compute transaction id}
\end{array}
\end{equation*}

\caption{Basic Definitions}
\label{fig:basic_definitions}
\end{figure}

\begin{figure}
\begin{align*}
  \var{xs} \restrictdom \var{m}
& = \{ x \mapsto y \mid x \mapsto y \in \var{m}, ~ x \in \var{xs} \}
& \text{domain restriction}
\\
  \var{xs} \subtractdom \var{m}
& = \{ x \mapsto y \mid x \mapsto y \in \var{m}, ~ x \notin \var{xs} \}
& \text{domain exclusion}
\\
  \var{m} \restrictrange \var{ys}
& = \{ x \mapsto y \mid x \mapsto y \in \var{m}, ~ y \in \var{ys} \}
& \text{range restriction}
\\
  \var{m} \subtractrange \var{ys}
& = \{ x \mapsto y \mid x \mapsto y \in \var{m}, ~ y \notin \var{ys} \}
& \text{range exclusion}
\end{align*}
\caption{Extra non-standard notation on finite mappings}
\label{fig:notation}
\end{figure}

Here we are using set theory and predicate logic as our specification language.
We use sets, relations, functions and make statements using variables and
quantifiers such as `for all' $\forall$ and `exists' $\exists$. This is very
expressive but we try to stick to a convention where it is relatively clear
what will correspond to computable values and what corresponds to the sets that
those values inhabit, i.e. types. This is of course deliberate because we want
to achieve a straightforward correspondence between a set theory specification
and an executable Haskell version.

In \cref{fig:basic_definitions} we define a number of sets that correspond to
types such as $\type{Addr}$ and $\type{Coin}$. We leave most of these abstract
however, not specifying what their elements look like. The interpretation is
that any choice will do provided that the required operations on these sets all
work out.

A few points on notation:
\begin{itemize}
\item We use the notation $\powerset{\type{T}}$ to mean the set of sets of
      $\type{T}$. Obviously the corresponding Haskell type would be
      $\type{Set} ~ \type{T}$.
\item We use the notation $\sequencetype{\type{T}}$ to mean the set of
      sequences of $\type{T}$. Obviously the corresponding Haskell type would
      be $[\type{T}]$.
\item We use $(x,y) \in \type{X} \times \type{Y}$ for tuples as elements of a
      relation.
\item We use $x \mapsto y \in \type{X} \mapsto \type{Y}$ for elements of a
      function.
\end{itemize}
%
It is also worth noting that we use set theoretic functions in two ways: one
that corresponds to the types of computations, and one that corresponds to
finite map data structures. Similarly we use relations sometimes as computable
predicates (like functions returning boolean) and sometimes as data structures.

In \cref{fig:notation} we define some extra operators on relations (including
finite mappings) that are not standard set theory notation, but are easily
definable with set comprehensions. These definitions are really just to give us
a concise notation in later steps. We will end up using them to manipulate
UTxOs which we have defined as a mapping from $\type{TxIn}$ to $\type{TxOut}$.

\subsection{Function style definitions}

\begin{figure}
\begin{align*}
& \fun{txins} \in \type{Tx} \to \powerset{\type{TxIn}}
& \text{transaction inputs} \\
& \fun{txins} ~ (\var{txins}, \_) = \var{txins}
\\[1em]
& \fun{txouts} \in \type{Tx} \to \type{UTxO}
& \text{transaction outputs as UTxO} \\
& \fun{txouts} ~ \var{tx} =
  \left\{ (\fun{txid} ~ \var{tx}, \var{ix}) \mapsto \var{txout} ~
  \middle| \begin{array}{l@{~}c@{~}l}
             (\_, \var{txouts}) & = & \var{tx} \\
             \var{ix} \mapsto \var{txout} & \in & \var{txouts}
           \end{array}
  \right\}
\\[1em]
& \fun{balance} \in \type{UTxO} \to \type{Coin}
& \text{UTxO balance} \\
& \fun{balance} ~ utxo = \sum_{(\_ ~ \mapsto (\_, c)) \in \var{utxo}} c
\end{align*}
\caption{Operations on transactions and UTxOs}
\label{fig:auxiliary_ops}
\end{figure}


Next up, in \cref{fig:auxiliary_ops} we have a number of auxiliary definitions
which will turn out to be very convenient in defining the state transition
rules. The first three $\fun{txins}$, $\fun{txouts}$ and $\fun{balance}$ are
of course functions and of course they correspond to computable Haskell
functions in a straightforward way.

\subsection{State transition notation}

Finally we get towards our first state transition description of the UTxO style
ledger. The first style we use has a general form like the following
%
\begin{equation*}
\frac{
  \text{local definitions} \qquad  \text{side conditions}
}{
  \var{s}
  \transitionarrow{}{\var{x}}
  \var{s}^\prime
}
\textsc{rule name}
\end{equation*}
%
The way to read this is as follows. The system can transition using this rule
(``rule name'') from a starting state $s$ to a new state $s^\prime$ provided
that the side conditions hold. All variables introduced in the transition
itself -- $x$ in the example -- and in local definitions are in scope for
other side conditions or the final state.

More generally this style of presentation comes from proof rules (e.g. typing
judgements) and the general form is that the statement below the line can be
concluded if the statements above the line also hold. Free variables below the
line are implicitly universally quantified while free variables above the line
are implicitly existentially quantified.

It is worth noting that white space above the line is significant as a
separator between multiple statements, and it is sometimes necessary to use
vertical space as well.

Finally it is worth noting that this style can express non-deterministic
state transition systems: any applicable rule can be used. When viewing these
as proof rules the way to think about it is that a sequence of observed state
transitions are valid if any valid proof for them can be constructed.

A good feature of this style of presentation is that it is very dense.
\cref{fig:transaction_transitions} for example presents a lot of information in
a small space. Even an equivalent Haskell version is longer. A downside is that
it is initially somewhat intimidating to many programmers.

An important upside is that it is an intermediate language that is
comprehensible to both mathematicians or cryptographers and also to computer
scientists. This can be very important to ensure that there is a common
understanding of a specification. It is precise and computable, which is good
for the programmers, but it also avoids too many programming concepts which is
good for the mathematicians and cryptographers.

\subsection{State transitions for UTxO transactions}

\cref{fig:transaction_transitions} presents the initial state and state
transition rule for basic UTxO style transactions.

\begin{figure}
\begin{equation*}
  \left(\begin{array}{r}
    \mathcal{G} \\
    \epsilon
  \end{array}\right)
  \in \type{UTxO} \times \type{Ledger}
\qquad\qquad
\text{initial genesis state}
\end{equation*}
%
\\[1em]
%
\begin{equation*}
\frac{
  \fun{txins} ~ \var{tx} \subseteq \dom \var{utxo} \qquad
  \fun{balance}~(\fun{txouts}~\var{tx}) \leq \fun{balance}~(\fun{txins} ~ \var{tx} \restrictdom \var{utxo})
}{
  \left(\begin{array}{r}
    \var{utxo} \\
    \Lambda
  \end{array}\right)
  \transitionarrow{}{\var{tx}}
  \left(\begin{array}{l}
  (\fun{txins} ~ \var{tx} \subtractdom \var{utxo}) \union \fun{txouts}~\var{tx} \\
  \Lambda ; \var{tx}
  \end{array}\right)
}
\textsc{transaction}
\end{equation*}
\caption{State transitions for transactions}
\label{fig:transaction_transitions}
\end{figure}

The way to read the genesis rule is simply that it is valid to start with a
genesis UTxO constant $\mathcal{G}$ and an empty ledger value
$\emptyset$. There is no transition; it is simply a valid state. There are no
side conditions above the line.

The way to read the transaction rule is as follows:
\begin{description}
\item[given] any starting state consisting of a UTxO $\var{utxo}$ and a ledger
             $\Lambda$
\item[transition] via a transaction $tx$ to a corresponding
\item[final state] where the ledger is extended with the transaction to give
     $\Lambda ; \var{tx}$ and the new UTxO value is given by the term
     $(\fun{txins} ~ \var{tx} \subtractdom \var{utxo}) \union \fun{txouts}~\var{tx}$
\item[provided that] it is the case that 
     $\fun{txins} ~ \var{tx} \subseteq \dom \var{utxo}$ and also the case that
     $\fun{balance}~(\fun{txouts}~\var{tx}) \leq \fun{balance}~(\fun{txins} ~ \var{tx})$
\end{description}
%
So this explains how the UTxO is updated, and it states the two conditions:
that all the transaction inputs must be in the current UTxO and the sum total
coin value of the outputs must be no more than that of the inputs. This
description does not include any of the cryptography for checking witnesses.
Of course all of this can be directly translated into Haskell.

\subsection{Signing and verifying}

In \cref{fig:crypto} we present an abstract definition of the cryptographic
primitives that we need for checking transaction witnesses. These are abstract
in the sense that we do not specify any representation for keys nor any
constructive definition of the operations. We simply state the verification
property. This property itself is of course glossing over some details.
Cryptographic such as this are not absolute but conjectured to be true to
very high degrees of probability. Nevertheless, these are details we can gloss
over for our purposes (provided cryptographers reviews everything).

In particular we have a signing function $\fun{sign}$ and a corresponding
verification predicate $\fun{verify}$. Since in reality we do not sign values
but raw bytes that are the serialised representation of values, we introduce
some notation for the serialised representation; for the combination of a
serialised representation with a signature; and for the verification predicate.

It is worth noting that the verification primitives require the whole
verification key as an input, not merely a hash of the verification key. It is
however a common pattern to see that a signature $\sigma$ is presented along
with a verification key $\var{vk}$ but where we know a priori that the
verification key is expected to have a known hash $\fun{hash}~\var{vk} = \var{hk}$.
This is the pattern used with witnesses for UTxO transaction inputs.

\begin{figure}

\emph{Key types}
%
\begin{equation*}
\begin{array}{r@{~\in~}lr}
  sk
& \type{SKey}
& \text{signing key}
\\
  vk
& \type{VKey}
& \text{verification key}
\\
  hk
& \type{Hash}
& \text{hash of a key}
\end{array}
\end{equation*}
%
\emph{Functions and relations}
%
\begin{equation*}
\begin{array}{r@{~\in~}lr}
  \fun{hash} & \type{VKey} \to \type{Hash}
& \text{hashing a key}
\\
  \fun{sign} & \type{SKey} \times \type{Data} \to \type{Sig}
& \text{signature}
\\
  \fun{verify} & \type{VKey} \times \type{Data} \times \type{Sig}
& \text{verification}
\end{array}
\end{equation*}
%
\emph{Verification property}
%
\begin{align*}
\forall ~ \text{key pairs} & ~ (sk, vk), m \in \type{Data}, \sigma \in \type{Sig}. \\
     & \fun{verify} ~ \var{vk} ~ m ~ \sigma \\
\iff & \\
     & \fun{sign} ~ \var{sk} ~ m = \sigma
\end{align*}
%
\emph{Notation for serialised, signed and verified data}
%
\begin{equation*}
\begin{array}{lcl}
  \serialised{x}
& \text{is}
& \text{the serialised representation of } x
\\[0.2em]
  \signed{x}{\sigma}
& \iff
& \exists \var{sk}. ~ \fun{sign} ~ sk ~ \serialised{x} = \sigma
\end{array}
\end{equation*}

\caption{Cryptographic operations for signing and verifying}
\label{fig:crypto}
\end{figure}

\subsection{UTxO transactions with witness checking}

Armed with these cryptographic primitives and notation we can tackle extending
the description of UTxO transactions to cover the checking of witnesses. The
updated definitions and transition are given in \cref{fig:transactions_witnesses}.

We need to redefine the $\type{Addr}$ set: instead of leaving it abstract we
have to define it to be (or contain) the hash of a verification key that owns
the address. This is needed for verifying that the appropriate signature has
been provided.

Where previously we had a transaction $\var{tx} \in \type{Tx}$ as just inputs
and outputs, now the top level construct for a transaction is
$(\var{tx}, \var{wits}) \in \type{Tx} \times \powerset{\type{Wit}}$ consisting
of a transaction body and a set of witnesses.

The two conditions from the previous version remain: that all inputs must be
unspent and the total value of the outputs are no more than those of the inputs.
What we have added is a term that requires the witnesses to be valid with
respect to the inputs being spent.

We can read this condition as follows: for each transaction input there should
be a corresponding witness, consisting of a signature and verification key,
such that we can verify the signature on the transaction body with the given
verification key and furthermore that looking up the input in the utxo yields
and address that is equal to the hash of the verification key in the witness.
More informally this is the requirement that to spend from an address, you
must supply a signature on the transaction signed using the signing key for
that address -- which we can check by verifying the signature with the
supplied verification key and checking that the verification key is the right
one for the address.

Notice that even in this abstract presentation we have the `segregated witness'
feature where the witnesses are not part of the transaction proper and can be
stored separately. Another thing we can see clearly from the data dependencies
in this description is that checking any of the side conditions is not required
simply to compute the change in the UTxO, a fact that may be useful for quickly
recovering UTxO states in cases where we already have a validated ledger.

\begin{figure}
\emph{Primitive types}
%
\begin{equation*}
\begin{array}{r@{~\in~}lr}
  \var{txid}
& \type{TxId}
& \text{transaction id}
\\
  ix
& \type{Ix}
& \text{index}
\\
  c
& \type{Coin}
& \text{currency value}
\end{array}
\end{equation*}
%
\emph{Primitive types (redefined)}
%
\begin{equation*}
\begin{array}{r@{~=~}l@{\qquad}r@{~\in~}l@{\qquad}r}
  \type{Addr}
& \type{Hash}
& \var{hk}
& \type{Addr}
& \text{address as a key hash}
\end{array}
\end{equation*}
%
\emph{Derived types}
%
\begin{equation*}
\begin{array}{r@{~=~}l@{}r@{~\in~}lr}
  \type{TxWits}
& \type{Tx} \times \powerset{\type{Wit}}
& (\var{tx}, \var{wits})
& \type{TxWits}
& \text{`signed' transaction}
\\
  \type{Wit}
& \type{VKey} \times \type{Sig}
& (\var{vk}, \sigma)
& \type{Wit}
& \text{input witness}
\\
  \type{Tx}
& \powerset{\type{TxIn}} \times (\type{Ix} \mapsto \type{TxOut})
& (\var{txins}, \var{txouts})
& \type{Tx}
& \text{raw transaction}
\\
  \type{TxIn}
& \type{TxId} \times \type{Ix}
& (\var{txid}, \var{ix})
& \type{TxIn}
& \text{transaction input}
\\
  \type{TxOut}
& \type{Addr} \times \type{Coin}
& (\var{addr}, c)
& \type{TxOut}
& \text{transaction output}
\\
  \type{UTxO}
& \type{TxIn} \mapsto \type{TxOut}
& \var{txin} \mapsto \var{txout} \in \var{utxo}
& \type{UTxO}
& \text{unspent outputs}
\\
  \type{Ledger}
& \sequencetype{\type{Tx}}
& \epsilon ; \var{tx}_1 ; \ldots ; \var{tx}_n 
& \type{Ledger}
& \text{transaction ledger}
\end{array}
\end{equation*}
%
\emph{Transition}
%
\begin{equation*}
  \left(\begin{array}{r}
    \mathcal{G} \\
    \epsilon
  \end{array}\right)
  \in \type{UTxO} \times \type{Ledger}
\qquad\qquad
\text{initial genesis state}
\end{equation*}

\begin{equation*}
\frac{
  \begin{array}{c}
  \fun{txins} ~ \var{tx} \subseteq \dom \var{utxo} \qquad
  \fun{balance}~(\fun{txouts}~\var{tx}) \leq \fun{balance}~(\fun{txins} ~ \var{tx} \restrictdom \var{utxo})
  \\[0.5em]
    \begin{array}{r@{~}l}
      \forall i \in \fun{txins} ~ \var{tx} \;\;
      \exists (\var{vk}, \sigma) \in \var{wits}. \;\; &
      \verified{\var{vk}}{\var{tx}}{\sigma} \\
    \wedge &
      \exists \var{hk}. \;\; \var{hk} = \fun{hash}~ \var{vk}
    \wedge
      (i \mapsto (\var{hk}, \_)) \in \var{utxo}
    \end{array}
  \end{array}
}{
  \left(\begin{array}{r}
    \var{utxo} \\
    \Lambda
  \end{array}\right)
  \transitionarrow{}{(\var{tx}, \var{wits})}
  \left(\begin{array}{l}
    (\fun{txins} ~ \var{tx} \subtractdom \var{utxo}) \union \fun{txouts}~\var{tx} \\
    \Lambda ; \var{tx}
  \end{array}\right)
}
\textsc{transaction}
\end{equation*}
%
\caption{State transitions for transactions including witnesses}
\label{fig:transactions_witnesses}
\end{figure}


\addcontentsline{toc}{section}{References}
\bibliographystyle{plainnat}
\bibliography{references}

\end{document}
