\section{Blockchain layer}
\label{sec:chain}

\newcommand{\Proof}{\type{Proof}}
\newcommand{\Seedl}{\mathsf{Seed}_\ell}
\newcommand{\Seede}{\mathsf{Seed}_\eta}
\newcommand{\StartRewards}{\ensuremath{\mathsf{StartRewards}}}
\newcommand{\activeSlotCoeff}[1]{\fun{activeSlotCoeff}~ \var{#1}}
\newcommand{\slotToSeed}[1]{\fun{slotToSeed}~ \var{#1}}

\newcommand{\T}{\type{T}}
\newcommand{\vrf}[3]{\fun{vrf}_{#1} ~ #2 ~ #3}
\newcommand{\verifyVrf}[4]{\fun{verifyVrf}_{#1} ~ #2 ~ #3 ~#4}

\newcommand{\HashHeader}{\type{HashHeader}}
\newcommand{\HashBBody}{\type{HashBBody}}
\newcommand{\bhHash}[1]{\fun{bhHash}~ \var{#1}}
\newcommand{\bHeaderSize}[1]{\fun{bHeaderSize}~ \var{#1}}
\newcommand{\bSize}[1]{\fun{bSize}~ \var{#1}}
\newcommand{\bBodySize}[1]{\fun{bBodySize}~ \var{#1}}
\newcommand{\OCert}{\type{OCert}}
\newcommand{\BHeader}{\type{BHeader}}
\newcommand{\BHBody}{\type{BHBody}}

\newcommand{\bheader}[1]{\fun{bheader}~\var{#1}}
\newcommand{\hsig}[1]{\fun{hsig}~\var{#1}}
\newcommand{\bprev}[1]{\fun{bprev}~\var{#1}}
\newcommand{\bhash}[1]{\fun{bhash}~\var{#1}}
\newcommand{\bvkcold}[1]{\fun{bvkcold}~\var{#1}}
\newcommand{\bseedl}[1]{\fun{bseed}_{\ell}~\var{#1}}
\newcommand{\bprfn}[1]{\fun{bprf}_{n}~\var{#1}}
\newcommand{\bseedn}[1]{\fun{bseed}_{n}~\var{#1}}
\newcommand{\bprfl}[1]{\fun{bprf}_{\ell}~\var{#1}}
\newcommand{\bocert}[1]{\fun{bocert}~\var{#1}}
\newcommand{\hBbsize}[1]{\fun{hBbsize}~\var{#1}}
\newcommand{\bbodyhash}[1]{\fun{bbodyhash}~\var{#1}}
\newcommand{\overlaySchedule}[3]{\fun{overlaySchedule}~\var{#1}~{#2}~\var{#3}}

\newcommand{\PrtclState}{\type{PrtclState}}
\newcommand{\PrtclEnv}{\type{PrtclEnv}}
\newcommand{\OverlayEnv}{\type{OverlayEnv}}
\newcommand{\VRFState}{\type{VRFState}}
\newcommand{\NewEpochEnv}{\type{NewEpochEnv}}
\newcommand{\NewEpochState}{\type{NewEpochState}}
\newcommand{\PoolDistr}{\type{PoolDistr}}
\newcommand{\BBodyEnv}{\type{BBodyEnv}}
\newcommand{\BBodyState}{\type{BBodyState}}
\newcommand{\RUpdEnv}{\type{RUpdEnv}}
\newcommand{\ChainEnv}{\type{ChainEnv}}
\newcommand{\ChainState}{\type{ChainState}}
\newcommand{\ChainSig}{\type{ChainSig}}


This chapter introduces the view of the blockchain layer as required for the
ledger. This includes in particular the information required for the epoch
boundary and its rewards calculation as described in Section~\ref{sec:epoch}. It
also covers the transitions that keep track of produced blocks in order to
calculate rewards and penalties for stake pools.

The main transition rule is $\mathsf{CHAIN}$ which calls the subrules
$\mathsf{NEWEPOCH}$ and $\mathsf{UPDN}$, $\mathsf{VRF}$ and $\mathsf{BBODY}$.

\subsection{Verifiable Random Functions (VRF)}
\label{sec:defs-vrf}

\begin{figure}[htb]
  %
  \emph{Abstract types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{seed} & \Seed  & \text{seed for pseudo-random number generator}\\
      \var{prf} & \Proof  & \text{VRF proof}\\
    \end{array}
  \end{equation*}
  %
  \emph{Abstract functions ($T$ an arbitrary type)}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \seedOp & \Seed \to \Seed \to \Seed & \text{binary seed operation} \\
      \vrf{\T}{}{} & \SKey \to \Seed \to \T\times\Proof
                   & \text{verifiable random function} \\
                   %
      \verifyVrf{\T}{}{}{} & \VKey \to \Seed \to \T\times\Proof \to \Bool
                           & \text{verify vrf proof} \\
                           %
    \end{array}
  \end{equation*}
  %
  \emph{Derived Types}
  \begin{align*}
    \PoolDistr = \HashKey \mapsto [0, 1] \text{ \hspace{3cm}stake pool distribution}
  \end{align*}
  %

  \emph{Constraints}
  \begin{align*}
    & \forall (sk, vk) \in \KeyPair,~ seed \in \Seed,~
    \verifyVrf{T}{vk}{seed}{\left(\vrf{T}{sk}{seed}\right)}
  \end{align*}
  %
  \emph{Constants}
  \begin{align*}
    & 0_{seed} \in \Seed & \text{neutral seed element} \\
    & \Seedl \in \Seed & \text{leader seed constant} \\
    & \Seede \in \Seed & \text{nonce seed constant}\\
    & \SlotsPrior \in \Duration & \tau\text{ in \cite{ouroboros_praos}}\\
    & \StartRewards \in \Duration & \text{duration to start reward calculations}\\
  \end{align*}

  \caption{VRF definitions}
  \label{fig:defs-vrf}
\end{figure}

\clearpage

\subsection{Block Definitions}
\label{sec:defs-blocks}

\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{h} & \HashHeader & \text{hash of a block header}\\
      \var{hb} & \HashBBody & \text{hash of a block body}\\
    \end{array}
  \end{equation*}
  %
  \emph{Operational Certificate}
  %
  \begin{equation*}
    \OCert =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{vk_{hot}} & \VKeyEv & \text{operational (hot) key}\\
        \var{vk_{cold}} & \VKey & \text{cold key}\\
        \var{n} & \N & \text{certificate issue number}\\
        c_0 & \KESPeriod & \text{start KES period}\\
        \sigma & \Sig & \text{cold key signature}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Block Header Body}
  %
  \begin{equation*}
    \BHBody =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{prev} & \HashHeader & \text{hash of previous block body}\\
        \var{vk} & \VKey & \text{block issuer}\\
        \var{slot} & \Slot & \text{block slot}\\
        \eta & \Seed & \text{nonce}\\
        \var{prf}_{\eta} & \Proof & \text{nonce proof}\\
        \ell & \unitInterval & \text{leader election value}\\
        \var{prf_{\ell}} & \Proof & \text{leader election proof}\\
        \var{bsize} & \N & \text{size of the block body}\\
        \var{bhash} & \HashBBody & \text{block body hash}\\
        \var{oc} & \OCert & \text{operational certificate}\\
        \var{pv} & \ProtVer & \text{protocol version}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Block Types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{bh}
      & \BHeader
      & \BHBody \times \Sig
      \\
      \var{b}
      & \Block
      & \BHeader \times \seqof{\Tx}
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \bhHash{} & \BHeader \to \HashHeader
                   & \text{hash of a block header} \\
      \bHeaderSize{} & \BHeader \to \N
                   & \text{size of a block header} \\
      \bBodySize{} & \seqof{\Tx} \to \N
                   & \text{size of a block body} \\
      \slotToSeed{} & \Slot \to \Seed
                    & \text{convert a slot to a seed} \\
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{bheader} & \Block \to \BHeader \\
      \fun{bhbody} & \BHeader \to \BHBody \\
      \fun{hsig} & \BHeader \to \Sig\\
      \fun{bbody} & \Block \to \seqof{\Tx} \\
      \fun{bvkcold} & \BHBody \to \VKey\\
      \fun{bprev} & \BHBody \to \HashHeader\\
      \fun{bslot} & \BHBody \to \Slot\\
      \fun{bnonce} & \BHBody \to \Seed\\
      \fun{\bprfn{}} & \BHBody \to \Proof\\
      \fun{bleader} & \BHBody \to \unitInterval\\
      \fun{\bprfl{}} & \BHBody \to \Proof\\
      \fun{hBbsize} & \BHBody \to \N \\
      \fun{bbodyhash} & \seqof{\Tx} \to \HashBBody \\
      \fun{bocert} & \BHBody \to \OCert \\
    \end{array}
  \end{equation*}
  %
  \caption{Block Definitions}
  \label{fig:defs:blocks}
\end{figure*}

\clearpage

\subsection{New Epoch Transition}
\label{sec:new-epoch-trans}

For the transition to a new epoch ($\mathsf{NEWEPOCH}$), the environment is
given in Figure~\ref{fig:ts-types:newepoch}, it consists of

\begin{itemize}
\item The epoch nonce.
\item The current slot.
\item The set of genesis keys.
\end{itemize}
The new epoch state is given in Figure~\ref{fig:ts-types:newepoch}, it consists
of

\begin{itemize}
\item The number of the last epoch.
\item The old epoch nonce.
\item The information about produced blocks for each stake pool during the previous epoch.
\item The information about produced blocks for each stake pool during the current epoch.
\item The old epoch state.
\item An optional rewards update.
\item The stake pool distribution of the epoch.
\item The OBFT overlay schedule.
\end{itemize}

Figure~\ref{fig:ts-types:newepoch} also defines an abstract pseudorandom function
$\fun{overlaySchedule}$ for creating the OBFT overlay schedule for each new epoch,
as explained in section 3.9.2 of~\cite{delegation_design}.
The function takes a set of genesis keys, a seed, and the protocol parameters
(of which the decentralization parameter $d$ and the active slot coeffient $f$ are used).
It must create $(d\cdot\SlotsPerEpoch)$-many OBFT slots, $(f\cdot d\cdot \SlotsPerEpoch)$
of which are active.

\begin{figure}
  \emph{New Epoch environments}
  \begin{equation*}
    \NewEpochEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \eta_1 & \Seed & \text{epoch nonce} \\
        \var{s} & \Slot & \text{current slot} \\
        \var{gkeys} & \powerset{\VKeyGen} & \text{genesis keys} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{New Epoch states}
  \begin{equation*}
    \NewEpochState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{e_\ell} & \Epoch & \text{last epoch} \\
        \eta_0 & \Seed & \text{epoch nonce} \\
        \var{b_{prev}} & \BlocksMade & \text{blocks made last epoch} \\
        \var{b_{cur}} & \BlocksMade & \text{blocks made this epoch} \\
        \var{es} & \EpochState & \text{epoch state} \\
        \var{ru} & \RewardUpdate^? & \text{reward update} \\
        \var{pd} & \PoolDistr & \text{pool stake distribution} \\
        \var{osched} & \Slot\mapsto\VKeyGen^? & \text{OBFT overlay schedule} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Abstract pseudorandom schedule function}
  \begin{align*}
    & \fun{overlaySchedule} \in \powerset{\VKeyGen} \to \Seed \to \PParams
        \to (\Slot\mapsto\VKeyGen^?) \\
  \end{align*}
  %
  \emph{Constraints}
  \begin{align*}
    \text{ given: }~\var{osched}\leteq\overlaySchedule{gkeys}{\eta}{pp} \\
    \range{osched}\subseteq\var{gkeys} \\
    |\var{osched}| = \floor{(\fun{d}~\var{pp})\cdot\SlotsPerEpoch} \\
    |\{s\mapsto k\in\var{osched}~\mid~k\neq\Nothing\}| =
    \floor{(\activeSlotCoeff{pp})\cdot(\fun{d}~\var{pp})\cdot\SlotsPerEpoch} \\
  \end{align*}
  %
  \emph{New Epoch Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{newepoch}{\_} \var{\_} \subseteq
    \powerset (\NewEpochEnv \times \NewEpochState \times \Epoch \times \NewEpochState)
  \end{equation*}
  \caption{NewEpoch transition-system types}
  \label{fig:ts-types:newepoch}
\end{figure}

Figure~\ref{fig:rules:new-epoch} defines the new epoch state transition. It
has two rules: the first one deals with the case when the epoch signal $e$ is before the
current epoch \var{e_\ell}. This rule does not change the state. The second rule
describes the change in the case of $e$ being equal to the next epoch
$e_\ell+ 1$. It also calls the $\mathsf{EPOCH}$ rule.

In the second case, the new epoch state is updated as follows:

\begin{itemize}
\item The epoch is set to the new epoch $e$.
\item The epoch nonce is replaced with the compbination of the new one from the
  environment and any extra entropy present in the UTxO state.
\item The mapping for the blocks produced by each stake pool for the previous epoch
  is set to the current such mapping.
\item The mapping for the blocks produced by each stake pool for the current epoch
  is set to the empty map.
\item The epoch state is updated with: first applying the rewards update \var{ru},
  then calling the $\mathsf{EPOCH}$ transition, updating the update state, and finally
  resetting the extra entropy mapping.
\item The rewards update is set to \Nothing.
\item The new pool distribution \var{pd}' is calculated from the delegation map and
  stake allocation of the previous epoch.
\item A new OBFT overlay schedule is created.
\end{itemize}

\begin{figure}[ht]
  \begin{equation}\label{eq:new-epoch}
    \inference[New-Epoch]
    {
      e = e_\ell + 1
      \\
      {
        \var{b_{prev}} \\
        \vdash
        (\fun{applyRUpd}~\var{ru}~\var{es})
          \trans{\hyperref[fig:rules:epoch]{epoch}}{\var{e}}\var{es'}
      }
      \\~\\~\\
      {\begin{array}{r@{~\leteq~}l}
          (\var{acnt},~\var{ss},~\var{ls}, \var{pp}) & \var{es'} \\
         (\wcard,~\var{pstake_{set}},~\wcard,~\wcard,~\wcard,~\wcard) & \var{ss} \\
         (\var{stake}, \var{delegs}) & \var{pstake_{set}} \\
         total & \sum_{\_ \mapsto c\in\var{stake}} c \\
          \var{pd'} & \fun{aggregate_{+}}~\left(\var{delegs}^{-1}\circ
                     \left\{
                     (\var{hk}, \frac{\var{c}}{\var{total}}) \vert (\var{hk},
                     \var{c}) \in \var{stake}
                 \right\}\right) \\
          \var{osched'} & \overlaySchedule{gkeys}{\eta_1}{pp} \\
          \eta_e & \fun{extraEntropy}~\var{pp} \\
          \var{es''} & (\var{acnt},
                       ~\var{ss},
                       ~\var{ls},
                       ~\var{pp}\unionoverrideRight\{\var{extraEntropy}\mapsto 0_{seed}\}) \\
       \end{array}}
    }
    {
      \left(
        {\begin{array}{c}
            \eta_1 \\
            \var{s} \\
            \var{gkeys} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{e_\ell} \\
            \eta_0 \\
            \var{b_{prev}} \\
            \var{b_{cur}} \\
            \var{es} \\
            \var{ru} \\
            \var{pd} \\
            \var{osched} \\
      \end{array}\right)}
      \trans{newepoch}{\var{e}}
      {\left(\begin{array}{c}
            \varUpdate{\var{e}} \\
            \varUpdate{\eta_1\seedOp\eta_e} \\
            \varUpdate{\var{b_{cur}}} \\
            \varUpdate{\emptyset} \\
            \varUpdate{\var{es}''} \\
            \varUpdate{\Nothing} \\
            \varUpdate{\var{pd}'} \\
            \varUpdate{\var{osched}'} \\
      \end{array}\right)}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:not-new-epoch}
    \inference[Not-New-Epoch]
    {
      e_\ell \neq e + 1
    }
    {
      \left(
        {\begin{array}{c}
            \eta_1 \\
            \var{s} \\
            \var{gkeys} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{e_\ell} \\
            \eta_0 \\
            \var{b_{prev}} \\
            \var{b_{cur}} \\
            \var{es} \\
            \var{ru} \\
            \var{pd} \\
            \var{osched}
      \end{array}\right)}
      \trans{newepoch}{\var{e}}
      {\left(\begin{array}{c}
            \var{e_\ell} \\
            \eta_0 \\
            \var{b_{prev}} \\
            \var{b_{cur}} \\
            \var{es} \\
            \var{ru} \\
            \var{pd} \\
            \var{osched}
      \end{array}\right)}
    }
  \end{equation}
  \caption{New Epoch rules}
  \label{fig:rules:new-epoch}
\end{figure}

\clearpage

\subsection{Update Nonce Transition}
\label{sec:update-nonces-trans}

The Update Nonce Transition updates the nonces until the randomness gets
fixed. The environment is shown in Figure~\ref{fig:ts-types:updnonce} and
consists of the epoch nonce $\eta$. The update nonce state is shown in
Figure~\ref{fig:rules:update-nonce} and consists of the candidate nonce
$\eta_c$ and the evolving nonce $\eta_v$.

\begin{figure}
  \emph{Update Nonce Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{updn}{\_} \var{\_} \subseteq
    \powerset (\Seed \times (\Seed\times\Seed) \times \Slot \times (\Seed\times\Seed))
  \end{equation*}
  \caption{UpdNonce transition-system types}
  \label{fig:ts-types:updnonce}
\end{figure}

The transition rule $\mathsf{UPDN}$ takes the slot \var{s} as signal.
There are two different cases for $\mathsf{UPDN}$, one where \var{s} is not yet
\SlotsPrior{} slots from the beginning of the epoch and one where \var{s} is at least
\SlotsPrior{} slots after the first slot of the epoch.

Note that in \ref{eq:update-both}, the nonce candidate $\eta_c$ transitions to
$\eta_v\star\eta$, not $\eta_c\star\eta$. The reason for this is that even though the nonce
candidate is frozen sometime during the epoch, we want the two nonces to again be equal at the
start of a new epoch (so that the entropy added near the end of the epoch is not discarded).

\begin{figure}[ht]
  \begin{equation}\label{eq:update-both}
    \inference[Update-Both]
    {
      slot < \firstSlot{((\epoch{slot}) + 1) - \SlotsPrior}
    }
    {
      \left(
        {\begin{array}{c}
            \eta \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \eta_v \\
            \eta_c \\
      \end{array}\right)}
      \trans{updn}{\var{s}}
      {\left(\begin{array}{c}
            \varUpdate{\eta_v\seedOp\eta} \\
            \varUpdate{\eta_v\seedOp\eta} \\
      \end{array}\right)}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:only-evolve}
    \inference[Only-Evolve]
    {
      s \geq \firstSlot{((\epoch{s}) + 1) - \SlotsPrior}
    }
    {
      \left(
        {\begin{array}{c}
            \eta \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \eta_v \\
            \eta_c \\
      \end{array}\right)}
      \trans{updn}{\var{s}}
      {\left(\begin{array}{c}
            \varUpdate{\eta_v\seedOp\eta} \\
            \eta_c \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{Update Nonce rules}
  \label{fig:rules:update-nonce}
\end{figure}

\subsection{Reward Update Transition}
\label{sec:reward-update-trans}

The Reward Update Transition calculates a new $\RewardUpdate$ to apply in a
$\mathsf{NEWEPOCH}$ transition. The environment is shown in
Figure~\ref{fig:ts-types:reward-update}, it consists of the produced blocks
mapping \var{b} and the epoch state \var{es}. Its state is an optional reward
update.

\begin{figure}
  \emph{Reward Update environments}
  \begin{equation*}
    \RUpdEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{b} & \BlocksMade & \text{blocks made} \\
        \var{es} & \EpochState & \text{epoch state} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Reward Update Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{rupd}{\_} \var{\_} \subseteq
    \powerset (\RUpdEnv \times \RewardUpdate^? \times \Slot \times \RewardUpdate^?)
  \end{equation*}
  \caption{Reward Update transition-system types}
  \label{fig:ts-types:reward-update}
\end{figure}

The transition rules are shown in Figure~\ref{fig:rules:reward-update}. There
are three cases, one which computes a new reward update, one which leaves the
rewards update unchanged as it has not yet been applied and finally one that
leaves the reward update unchanged as the transition was started too early.

The signal of the transition rule $\mathsf{RUPD}$ is the slot \var{s}. The
execution of the transition role is as follows:

\begin{itemize}
\item If \var{s} is less than or equal to the sum of the first slot of its epoch
  and the duration to start rewards \StartRewards, then the state is not
  updated.
\item If the current reward update \var{ru} is not \Nothing, i.e., a reward
  update has already been calculated but not yet applied, then the state is not
  updated.
\item If the current reward update \var{ru} is empty and \var{s} is greater than
  the sum of the first slot of its epoch and the duration \StartRewards, then a
  new rewards update is calculated and the state is updated.
\end{itemize}

\begin{figure}[ht]
  \begin{equation}\label{eq:reward-update}
    \inference[Reward-Update]
    {
      ru' \leteq \createRUpd{b}{es}
      \\~\\
      s > (\firstSlot{\epoch{s}}) + \StartRewards
      &
      ru = \Nothing
    }
    {
      \left(
        {\begin{array}{c}
            \var{b} \\
            \var{es} \\
        \end{array}}
      \right)
      \vdash
      \var{ru}\trans{rupd}{\var{s}}\varUpdate{\var{ru}'}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:no-reward-update}
    \inference[No-Reward-Update]
    {
      ru \neq \Nothing
    }
    {
      \left(
        {\begin{array}{c}
            \var{b} \\
            \var{es} \\
        \end{array}}
      \right)
      \vdash
      \var{ru}\trans{rupd}{\var{s}}\var{ru}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:reward-too-early}
    \inference[Reward-Too-Early]
    {
      s \leq (\firstSlot{\epoch{s}}) + \StartRewards
    }
    {
      \left(
        {\begin{array}{c}
            \var{b} \\
            \var{es} \\
        \end{array}}
      \right)
      \vdash
      \var{ru}\trans{rupd}{\var{s}}\var{ru}
    }
  \end{equation}

  \caption{Reward Update rules}
  \label{fig:rules:reward-update}
\end{figure}

\subsection{Block Header Transition}
\label{sec:block-header-trans}

The Block Header Transition checks a couple sizes and performs some chain level upkeep.
The environment consists of a candidate nonce and a set of genesis keys, and the state is the
epoch specific state necessary for the $\mathsf{NEWEPOCH}$ transition.

\begin{figure}
  \emph{Block Header Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{bhead}{\_} \var{\_} \subseteq
    \powerset ((\Seed\times\powerset{\VKeyGen}) \times \NewEpochState \times \BHeader \times \NewEpochState)
  \end{equation*}
  \caption{BHeader transition-system types}
  \label{fig:ts-types:bheader}
\end{figure}

The $\mathsf{BHEAD}$ transition rule is shown in Figure~\ref{fig:rules:bhead}.
The signal is a new block header \var{bh}, from which we extract:

\begin{itemize}
\item The block header body \var{bhb}.
\item The slot \var{slot} of the block header.
\end{itemize}

The transition rule is executed, if the following conditions are satisfied:

\begin{itemize}
\item The size of \var{bh} is less than or equal to the maximal size that the
  protocol parameters allow for block headers.
\item The size of the block body, as claimed by the block header, is less than or equal to the
  maximal size that the protocol parameters allow for block bodies.
  It will later be verified that the size of the block body matches the size claimed
  in the header (see Figure~\ref{fig:rules:bbody}).
\end{itemize}

If the size checks pass, then three transitions are done:

\begin{itemize}
  \item The $\mathsf{NEWEPOCH}$ transition performs any state change needed if it is the first
    block of a new epoch.
  \item The $\mathsf{RUPD}$ creates the reward update if it is late enough in the epoch.
    \textbf{Note} that for every block header, either $\mathsf{NEWEPOCH}$ or $\mathsf{RUPD}$
    will be the identity transition, and so, for instance, it does not matter if $\mathsf{RUPD}$
    uses $\var{nes}$ or $\var{nes}'$ to obtain the needed state.
\end{itemize}

\begin{figure}[ht]
  \begin{equation}\label{eq:bheader}
    \inference[BHead]
    {
      \var{bhb} \leteq \bhbody{bh}
      &
      \var{s} \leteq \bslot{bhb}
      \\
      \bHeaderSize{bh} \leq \fun{maxHeaderSize}~\var{pp}
      &
      \hBbsize{bhb} \leq \fun{maxBlockSize}~\var{pp}
      \\
      {
        \left(
          {\begin{array}{c}
              \eta_c \\
              \var{s} \\
              \var{gkeys} \\
          \end{array}}
        \right)
        \vdash
        \var{nes}
        \trans{\hyperref[fig:rules:new-epoch]{newepoch}}{\epoch{s}}
        \var{nes}'
      }
      \\~\\
      (\wcard,~\wcard,~\var{b_{prev}},~\wcard,~\var{es},~\var{ru},~\wcard,~\wcard)\leteq\var{nes}
      \\
      {
        \left(
          {\begin{array}{c}
              \var{b_{prev}} \\
              \var{es} \\
          \end{array}}
        \right)
        \vdash \var{ru}\trans{\hyperref[fig:rules:reward-update]{rupd}}{\var{s}} \var{ru}'
      }
      \\
      \var{nes}''\leteq\var{nes'}\unionoverrideRight\{\var{ru'}\}
    }
    {
      \left(
        {\begin{array}{c}
            \eta_c \\
            \var{gkeys} \\
        \end{array}}
      \right)
      \vdash\var{nes}\trans{bhead}{\var{bh}}\varUpdate{\var{nes''}}
    }
  \end{equation}
  \caption{BHeader rules}
  \label{fig:rules:bhead}
\end{figure}

\clearpage

\subsection{Operational Certificate Transition}
\label{sec:oper-cert-trans}

The Operational Certificate Transition contains no environments, and its state is the mapping of
operation certificate issue numbers.  Its signal is a block header.

\begin{figure}
  \emph{Operational Certificate Transitions}
  \begin{equation*}
    \vdash \var{\_} \trans{ocert}{\_} \var{\_} \subseteq
    \powerset (\HashKey_{pool} \mapsto \N \times \BHeader \times \HashKey_{pool} \mapsto \N)
  \end{equation*}
  \caption{OCert transition-system types}
  \label{fig:ts-types:ocert}
\end{figure}

The transition rule is shown in Figure~\ref{fig:rules:ocert}. From the block
header body \var{bhb} we first extract the following:

\begin{itemize}
  \item The operational certificate, consisting of the hot key \var{vk_{hot}}, the cold key
    \var{vk_{cold}}, the KES period number \var{n}, the KES period start \var{c_0} and the cold key
  signature.
\item The hash \var{hk} of \var{vk_{cold}}.
\item The slot \var{s} for the block.
\item The number of KES periods that have elapsed since the start period on the certificate.
\end{itemize}

Using this we verify the preconditions of the operational certificate state
transition which are the following:

\begin{itemize}
\item The KES period start \var{c_0} is greater than or equal to the KES period of
  the slot of the block header body and less than 90 KES periods after \var{c_0}.
\item \var{hk} exists as key in the mapping of certificate issues numbers to a KES
  period \var{m} and that period is less than or equal to \var{n}.
\item The signature $\sigma$ can be verified with the cold verification key
  \var{vk_{cold}}.
\item The KES signature $\tau$ can be verified with the hot verification key
  \var{vk_{hot}}.
\end{itemize}

After this, the transition system updates the operational certificate state by
updating the mapping of operational certificates where it overwrites the entry
of the key \var{hk} with the KES period \var{n}.

\begin{figure}[ht]
  \begin{equation}\label{eq:ocert}
    \inference[OCert]
    {
      (\var{bhb},~\sigma)\leteq\var{bh}
      &
      (\var{vk_{hot}},~\var{vk_{cold}},~n,~c_{0},~\tau) \leteq \bocert{bhb}
      \\
      \var{hk} \leteq \hashKey{vk_{cold}}
      &
      \var{s}\leteq\bslot{bhb}
      &
      t \leteq \kesPeriod{s} - c_0
      \\~\\
      c_0 \leq \kesPeriod{s} < c_0 + 90
      \\
      \var{hk}\mapsto m\in\var{cs}
      &
      m \leq n
      \\~\\
      \mathcal{V}_{\var{vk_{cold}}}{\serialised{(\var{vk_{hot}},~n,~c_0)}}_{\sigma}
      &
      \mathcal{V}^{\mathsf{KES}}_{vk_{hot}}{\serialised{bhb}}_{\tau}^{t}
      \\
    }
    {
      \vdash\var{cs}
      \trans{ocert}{\var{bh}}\varUpdate{\var{cs}\unionoverrideRight\{\var{hk}\mapsto n\}}
    }
  \end{equation}
  \caption{OCert rules}
  \label{fig:rules:ocert}
\end{figure}

\subsection{Verifiable Random Function}
\label{sec:verif-rand-funct}

In this section we define a function $\fun{vrfChecks}$ which performs all the VRF related checks
on a given block header body.
In addition to the block header body, the function requires the epoch nonce,
the stake distribution (aggregated by pool), and the active slots coefficient from the protocol
parameters. The function checks:

\begin{itemize}
\item The validity of the proofs for the leader value and the new nonce.
\item The verification key is associated to a non-zero relative stake
  $\sigma$ in the stake distribution.
\item The $\fun{bleader}$ value of \var{bhb} indicates a possible leader for
  this slot.
\end{itemize}

\begin{figure}
  \emph{VRF helper funnction}
  \begin{align*}
      & \fun{vrfChecks} \in \Seed \to \PoolDistr \to \unitInterval \to \BHBody \to \Bool \\
      & \fun{vrfChecks}~\eta_0~\var{pd}~\var{f}~\var{bhb} = \\
      & \begin{array}{cl}
        ~~~~ & \var{hk}\mapsto \sigma\in\var{pd} \\
        ~~~~ \land &
             \verifyVrf{\Seed}{vk}{((\eta_0\seedOp ss)\seedOp\Seede)}{(\bprfn{bhb})} \\
        ~~~~ \land &
             \verifyVrf{\unitInterval}{vk}{((\eta_0\seedOp ss)\seedOp\Seedl)}{(\bprfl{bhb})} \\
        ~~~~ \land &
             \fun{bleader}~\var{bhb} < 1 - (1 - f)^{\sigma} \\
      \end{array} \\
      & ~~~~\where \\
      & ~~~~~~~~~~\var{hk} \leteq \hashKey{(\bvkcold bhb)} \\
      & ~~~~~~~~~~\var{ss} \leteq \slotToSeed{(\bslot{bhb})} \\
  \end{align*}
  \label{fig:vrf-checks}
\end{figure}

\clearpage

\subsection{Overlay Schedule}
\label{sec:overlay-schedule}

The transition from the boostrap era to a fully decentralized network is explained in
section 3.9.2 of~\cite{delegation_design}.
Key to this transition is a protocol parameter $d$ which controls how many slots are governed by
the genesis nodes via OBFT, and which slots are open to any registered stake pool.
The transition system introduced in this section, $\type{OVERLAY}$, covers this mechanism.

This transition is responsible for validating the protocol for both the OBFT blocks
and the Praos blocks, depending on the overlay schedule.

The environments for this transition are:
\begin{itemize}
  \item The protocol parameters $\var{pp}$.
  \item A mapping $\var{osched}$ of slots to an optional genesis key.
    In the terminology of \cite{delegation_design},
    the slots in $\var{osched}$ are the ``OBFT slots''.
    A slot in this map with a value of $\Nothing$ is a non-active slots,
    otherwise it is an active slot and its value designates the genesis key
    responsible for producing the block.
  \item The epoch nonce $\eta_0$.
  \item The stake pool stake distribution $\var{pd}$.
  \item The mapping $\var{dms}$ of genesis keys to their cold keys.
\end{itemize}

The states for this transition consist only of the mapping of certificate issue numbers.

\begin{figure}
  \emph{Overlay environments}
  \begin{equation*}
    \OverlayEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pp} & \PParams & \text{protocol parameters} \\
        \var{osched} & \Slot\mapsto\VKeyGen^? & \text{OBFT overlay schedule} \\
        \eta_0 & \Seed & \text{epoch nonce} \\
        \var{pd} & \PoolDistr & \text{pool stake distribution} \\
        \var{dms} & \VKeyGen\mapsto\VKey & \text{genesis key delegations} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Overlay Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{overlay}{\_} \var{\_} \subseteq
    \powerset (\OverlayEnv \times (\HashKey_{pool} \mapsto \N) \times \BHeader \times
    (\HashKey_{pool} \mapsto \N))
  \end{equation*}
  \caption{Overlay transition-system types}
  \label{fig:ts-types:overlay}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:active-pbft}
    \inference[Active-OBFT]
    {
      \var{bhb}\leteq\bheader{bh}
      &
      \var{vk}\leteq\bvkcold{bhb}
      \\
      \bslot bhb \mapsto \var{gkey}\in\var{osched}
      &
      \var{gkey}\mapsto\var{vk}\in\var{dms}
      \\~\\
      {
        \vdash\var{cs}\trans{\hyperref[fig:rules:ocert]{ocert}}{\var{bh}}\var{cs'}
      }
    }
    {
      \left(
        {\begin{array}{c}
            \var{pp} \\
            \var{osched} \\
            \eta_0 \\
            \var{pd} \\
            \var{dms} \\
        \end{array}}
      \right)
      \vdash
      \var{cs}
      \trans{overlay}{\var{bh}}
      \varUpdate{\var{cs}'}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:decentralized}
    \inference[Decentralized]
    {
      \var{bhb}\leteq\bheader{bh}
      \\
      \bslot{bhb} \notin \dom{\var{osched}}
      \\~\\
      {
        \vdash\var{cs}\trans{\hyperref[fig:rules:ocert]{ocert}}{\var{bh}}\var{cs'}
      }
      \\~\\
      \fun{vrfChecks}~\eta_0~\var{pd}~(\activeSlotCoeff{pp})~\var{bhb}
    }
    {
      \left(
        {\begin{array}{c}
            \var{pp} \\
            \var{osched} \\
            \eta_0 \\
            \var{pd} \\
            \var{dms} \\
        \end{array}}
      \right)
      \vdash
      \var{cs}
      \trans{overlay}{\var{bh}}
      \varUpdate{\var{cs}'}
    }
  \end{equation}

  \caption{Overlay rules}
  \label{fig:rules:overlay}
\end{figure}

\clearpage

\subsection{Protocol Transition}
\label{sec:protocol-trans}

The protocol transition covers the common predicates of OBFT and Praos,
and then calls $\mathsf{OVERLAY}$ for the particular transitions,
followed by the transition to update the evolving and candidate nonces.

\begin{figure}
  \emph{Protocol environments}
  \begin{equation*}
    \PrtclEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{oe} & \OverlayEnv & \text{overlay environment} \\
        \var{s_{now}} & \Slot & \text{current slot} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Protocol states}
  \begin{equation*}
    \PrtclState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{cs} & \HashKey_{pool} \mapsto \N & \text{operational certificate issues numbers} \\
        \var{h} & \HashHeader & \text{latest header hash} \\
        \var{s_\ell} & \Slot & \text{last slot} \\
        \eta_v & \Seed & \text{evolving nonce} \\
        \eta_c & \Seed & \text{candidate nonce} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Protocol Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{prtcl}{\_} \var{\_} \subseteq
    \powerset (\powerset{\PrtclEnv} \times \PrtclState \times \BHeader \times \PrtclState)
  \end{equation*}
  \caption{Protocol transition-system types}
  \label{fig:ts-types:prtcl}
\end{figure}

The environments for this transition are:
\begin{itemize}
  \item The overlay environment $\var{oe}$.
  \item The current slot (as determined by wall-clock).
\end{itemize}

The states for this transition consists of:
\begin{itemize}
  \item The operational certificate issue number mapping.
  \item The slot of the last block header.
  \item The hash of last block header.
  \item The evolving nonce.
  \item The canditate nonce for the next epoch.
\end{itemize}

\begin{figure}[ht]
  \begin{equation}\label{eq:prtcl}
    \inference[PRTCL]
    {
      \var{bhb}\leteq\bhbody{bh}
      &
      \var{slot} \leteq \bslot{bhb}
      &
      \eta\leteq\fun{bnonce}~{bhb}
      \\
      \var{s_\ell} < \var{slot} \leq \var{s_{now}}
      &
      \var{h} = \bprev{bhb}
      \\~\\
      {
        \var{oe}\vdash \var{cs}\trans{\hyperref[fig:rules:overlay]{overlay}}{\var{bh}} \var{cs}'
      }\\~\\
      {
        \eta\vdash
        {\left(\begin{array}{c}
        \eta_v \\
        \eta_c \\
        \end{array}\right)}
        \trans{\hyperref[fig:rules:update-nonce]{updn}}{\var{slot}}
        {\left(\begin{array}{c}
        \eta_v' \\
        \eta_c' \\
        \end{array}\right)}
      }
    }
    {
      \left(
        {\begin{array}{c}
            \var{oe} \\
            \var{s_{now}} \\
        \end{array}}
      \right)
      \vdash
      {\left(\begin{array}{c}
            \var{cs} \\
            \var{h} \\
            \var{s_\ell} \\
            \eta_v \\
            \eta_c \\
      \end{array}\right)}
      \trans{prtcl}{\var{bh}}
      {\left(\begin{array}{c}
            \varUpdate{cs'} \\
            \varUpdate{\bhHash{bh}} \\
            \varUpdate{slot} \\
            \varUpdate{\eta_v'} \\
            \varUpdate{\eta_c'} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{Protocol rules}
  \label{fig:rules:prtcl}
\end{figure}

\clearpage

\subsection{Block Body Transition}
\label{sec:block-body-trans}

The Block Body Transition updates the block body state which comprises the ledger state and the
map describing the produced blocks.
The environment of the $\mathsf{BBODY}$ transition are overlay schedule slots and the protocol
parameters.
The environments and states are defined in Figure~\ref{fig:ts-types:bbody}, along with
a helper function $\fun{incrBlocks}$, which counts the number of non-overlay blocks
produced by each stake pool.

\begin{figure}
  \emph{BBody environments}
  \begin{equation*}
    \BBodyEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{oslots} & \powerset{\Slot} & \text{overlay slots} \\
        \var{pp} & \PParams & \text{protocol parameters} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{BBody states}
  \begin{equation*}
    \BBodyState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{ls} & \LState & \text{ledger state} \\
        \var{b} & \BlocksMade & \text{blocks made} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{BBody Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{bbody}{\_} \var{\_} \subseteq
    \powerset (\BBodyEnv \times \BBodyState \times \Block \times \BBodyState)
  \end{equation*}
  \caption{BBody transition-system types}
  \label{fig:ts-types:bbody}
  %
  \emph{BBody helper function}
  \begin{align*}
      & \fun{incrBlocks} \in \Bool \to \HashKey \to
          \BlocksMade \to \BlocksMade \\
      & \fun{incrBlocks}~\var{isOverlay}~\var{hk}~\var{b} =
        \begin{cases}
          b & \text{if }\var{isOverlay} \\
          b\cup\{\var{hk}\mapsto 1\} & \text{if }\var{hk}\notin\dom{b} \\
          b\unionoverrideRight\{\var{hk}\mapsto n+1\} & \text{if }\var{hk}\mapsto n\in b \\
        \end{cases}
  \end{align*}

\end{figure}

The $\mathsf{BBODY}$ transition rule is shown in Figure~\ref{fig:rules:bbody},
its sub-rule is $\mathsf{LEDGERS}$ which does the update of the ledger
state. The signal is a block from which we extract:

\begin{itemize}
\item The sequence of transactions \var{txs} of the block.
\item The block header body \var{bhb}.
\item The verification key \var{vk} of the issuer of the \var{block} and its
  hash \var{hk}.
\end{itemize}

The transition is executed if the following preconditions are met:

\begin{itemize}
\item The size of the block body matches the value given in the block header body.
\item The hash of the block body matches the value given in the block header body.
\item Either \var{hk} to \var{n} is in the mapping of produced blocks, or
  \var{n} is equal to 0.
\item The transactions \var{txs} were correctly signed by \var{vk}, producing
  the signature $\sigma$.
\end{itemize}

After this, the transition system updates the mapping of the hashed stake pool
keys to the incremented value of produced blocks (\var{n} + 1), provided the
current slot is not an overlay slot.

\begin{figure}[ht]
  \begin{equation}\label{eq:bbody}
    \inference[Block-Body]
    {
      \var{txs} \leteq \bbody{block}
      &
      \var{bhb} \leteq \bhbody\bheader{block}
      &
      \var{hk} \leteq \hashKey\bvkcold{bhb}
      \\~\\
      \bBodySize{txs} = \hBbsize{bhb}
      &
      \fun{hash}~{txs} = \bbodyhash{bhb}
      \\~\\
      {
        {\left(\begin{array}{c}
            \bslot{bhb} \\
            \var{pp} \\
        \end{array}\right)}
        \vdash
             \var{ls} \\
        \trans{\hyperref[fig:rules:ledger-sequence]{ledgers}}{\var{txs}}
             \var{ls}' \\
      }
    }
    {
      {\left(\begin{array}{c}
            \var{oslots} \\
            \var{pp} \\
      \end{array}\right)}
      \vdash
      {\left(\begin{array}{c}
            \var{ls} \\
            \var{b} \\
      \end{array}\right)}
      \trans{bbody}{\var{block}}
      {\left(\begin{array}{c}
            \varUpdate{\var{ls}'} \\
            \varUpdate{\fun{incrBlocks}~{(\bslot{bhb}\in\var{oslots})}~{hk}~{b}} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{BBody rules}
  \label{fig:rules:bbody}
\end{figure}

\clearpage

\subsection{Chain Transition}
\label{sec:chain-trans}

The $\mathsf{CHAIN}$ transition rule is the main rule of the blockchain layer
part of the STS. It calls $\mathsf{BHEAD}$, $\mathsf{PRTCL}$, and $\mathsf{BBODY}$ as sub-rules.

The environment for the chain rule is the current slot number \var{s_{now}}.

The chain state is shown in Figure~\ref{fig:ts-types:chain}, it consists of the
following:

\begin{itemize}
  \item The epoch specific state $\var{nes}$.
  \item The evolving nonce $\eta_v$.
  \item The candidate nonce $\eta_c$.
  \item The last header hash \var{h}.
  \item The last slot \var{s_\ell}.
\end{itemize}

\begin{figure}
  \emph{Chain states}
  \begin{equation*}
    \ChainState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{nes} & \NewEpochState & \text{epoch specific state} \\
        ~\eta_v & \Seed & \text{evolving nonce} \\
        ~\eta_c & \Seed & \text{candidate nonce} \\
        \var{h} & \HashHeader & \text{latest header hash} \\
        \var{s_\ell} & \Slot & \text{last slot} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Chain Transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{chain}{\_} \var{\_} \subseteq
    \powerset (\Slot \times \ChainState \times \Block \times \ChainState)
  \end{equation*}
  \caption{Chain transition-system types}
  \label{fig:ts-types:chain}
\end{figure}

The $\mathsf{CHAIN}$ transition rule is shown in
Figure~\ref{fig:rules:chain}. Its signal is a \var{block}, from which
we extract the block header \var{bh}.
The transition rule itself has no preconditions, instead it calls all its subrules.
The transition uses a few helper functions defined in Figure~\ref{fig:funcs:chain-helper}.

%%
%% Figure - Helper Functions for Chain Rules
%%
\begin{figure}[htb]
  \emph{Chain Transition Helper Functions}
  \begin{align*}
      & \fun{getGKeys} \in \NewEpochState \to \powerset{\VKeyGen} \\
      & \fun{getGKeys}~\var{nes} = \dom{dms} \\
      &
      \begin{array}{lr@{~=~}l}
        \where
          & (\wcard,~\wcard,~\wcard,~\wcard,~\var{es},~\wcard,~\wcard,~\wcard)
          & \var{nes}
          \\
          & (\wcard,~\wcard,~\var{ls},~\wcard)
          & \var{es}
          \\
          & (\wcard,~((\wcard,~\wcard,~\wcard,~\wcard,~\var{dms}),~\wcard))
          & \var{ls}
      \end{array}
  \end{align*}
  %
  \begin{align*}
      & \fun{setIssueNumbers} \in \LState \to (\HashKey\to\N) \to \LState \\
      & \fun{setIssueNumbers}~
          (\var{utxoSt},
          ~(\var{dstate},~(\var{stpools},~\var{poolParams},~\var{retiring},~\wcard)))
          ~\var{cs} = \\
      & ~~~~
          (\var{utxoSt},
          ~(\var{dstate},~(\var{stpools},~\var{poolParams},~\var{retiring},~\var{cs})))
  \end{align*}
  %
  \begin{align*}
      & \fun{updateNES} \in \NewEpochState \to \BlocksMade \to \LState \to \NewEpochState \\
      & \fun{updateNES}~
      (\var{e_\ell},~\eta_0,~\var{b_{prev}},~\wcard,~(\var{acnt},~\var{ss},~\wcard,~\var{pp}),
       ~\var{ru},~\var{pd},~\var{osched})
          ~\var{b_{cur}}~\var{ls} = \\
      & ~~~~
      (\var{e_\ell},~\eta_0,~\var{b_{prev}},~\var{b_{cur}},
       ~(\var{acnt},~\var{ss},~\var{ls},~\var{pp}),~\var{ru},~\var{pd},~\var{osched})
  \end{align*}
  %

  \caption{Helper Functions used in Rewards and Epoch Boundary}
  \label{fig:funcs:chain-helper}
\end{figure}

\begin{figure}[ht]
  \begin{equation}\label{eq:chain}
    \inference[Chain]
    {
      \var{bh} \leteq \bheader{block}
      &
      \var{gkeys} \leteq \fun{getGKeys}~\var{nes}
      \\~\\
      {
        \left(
          {\begin{array}{c}
              \eta_c \\
              \var{gkeys} \\
          \end{array}}
        \right)
        \vdash\var{nes}\trans{\hyperref[fig:rules:bhead]{bhead}}{\var{bh}}\var{nes'}
      } \\~\\
      (\wcard,~\eta_0,~\wcard,~\var{b_{cur}},~\var{es},~\wcard,~\var{pd},\var{osched})
        \leteq\var{nes'} \\
        (\wcard,~\wcard,\var{ls},~\var{pp})\leteq\var{es}\\
        ( \wcard,
          ( (\wcard,~\wcard,~\wcard,~\wcard,~\var{dms}),~
            (\wcard,~\wcard,~\wcard,~\var{cs})))\leteq\var{ls}\\
      {
        \left(
          {\begin{array}{c}
              \left(\begin{array}{c}
                 \var{pp} \\
                 \var{osched} \\
                 \var{dms} \\
                 \eta_0 \\
                 \var{pd} \\
              \end{array}\right)\\
              \var{s_{now}} \\
          \end{array}}
        \right)
        \vdash
        {\left(\begin{array}{c}
              \var{cs} \\
              \var{h} \\
              \var{s_\ell} \\
              \eta_v \\
              \eta_c \\
        \end{array}\right)}
        \trans{\hyperref[fig:rules:prtcl]{prtcl}}{\var{bh}}
        {\left(\begin{array}{c}
              \var{cs'} \\
              \var{h'} \\
              \var{s_\ell'} \\
              \eta_v' \\
              \eta_c' \\
        \end{array}\right)}
      } \\~\\~\\
      \var{ls'}\leteq\fun{setIssueNumbers}~\var{ls}~\var{cs} \\
      {
        {\left(\begin{array}{c}
              \dom{osched} \\
              \var{pp} \\
        \end{array}\right)}
        \vdash
        {\left(\begin{array}{c}
              \var{ls}' \\
              \var{b_{cur}} \\
        \end{array}\right)}
        \trans{\hyperref[fig:rules:bbody]{bbody}}{\var{block}}
        {\left(\begin{array}{c}
              \var{ls}'' \\
              \var{b_{cur}'} \\
        \end{array}\right)}
      }\\
      \var{nes''}\leteq\fun{updateNES}~\var{nes'}~\var{b_{cur}'},~\var{ls''} \\
    }
    {
      \var{s_{now}}
      \vdash
      {\left(\begin{array}{c}
            \var{nes} \\
            \eta_v \\
            \eta_c \\
            \var{h} \\
            \var{s_\ell} \\
      \end{array}\right)}
      \trans{chain}{\var{block}}
      {\left(\begin{array}{c}
            \varUpdate{\var{nes}''} \\
            \varUpdate{\eta_v'} \\
            \varUpdate{\eta_c'} \\
            \varUpdate{\var{h}'} \\
            \varUpdate{\var{s_\ell}'} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{Chain rules}
  \label{fig:rules:chain}
\end{figure}

\clearpage

\subsection{Byron to Shelley Transition}
\label{sec:byron-to-shelley}

This section describes how to transition the state held by the Byron ledger to the Shelley ledger.
The Byron ledger state $\CEState$ is defined in \cite{byron_chain_spec}.
Figure~\ref{fig:functions:to-shelley} defines a function $\fun{toShelley}$
which takes the Byron ledger state and creates the Shelley ledger state.

%%
%% Figure - Byron to Shelley State Transition
%%
\begin{figure}[htb]
  \emph{Byron to Shelley Transition}
  %
  \begin{align*}
      & \fun{toShelley} \in \CEState \to \ChainState \\
      & \fun{toShelley}~
      \left(
        \begin{array}{c}
          \var{s_{last}} \\
          \wcard \\
          \var{h} \\
          (\var{utxo},~\var{reserves}) \\
          \var{ds} \\
          \var{us}
        \end{array}
      \right)
      =
      \left(
        \begin{array}{c}
          \left(
            \begin{array}{c}
              \epoch{s_{last}} \\
              \fun{hash}~{h} \\
              \emptyset \\
              \emptyset \\
              \left(
                \begin{array}{c}
                  \left(
                    \begin{array}{c}
                      0 \\
                      \var{reserves} \\
                    \end{array}
                  \right) \\
                  \left(
                    \begin{array}{c}
                      (\emptyset, \emptyset) \\
                      (\emptyset, \emptyset) \\
                      (\emptyset, \emptyset) \\
                      \emptyset \\
                      \emptyset \\
                      0
                    \end{array}
                  \right) \\
                  \left(
                    \begin{array}{c}
                      \left(
                        \begin{array}{c}
                          \var{utxo} \\
                          0 \\
                          0 \\
                          \left(
                            \begin{array}{c}
                              \emptyset \\
                              \emptyset \\
                              \emptyset \\
                              \emptyset \\
                            \end{array}
                          \right) \\
                        \end{array}
                      \right) \\
                      \left(
                        \begin{array}{c}
                        \left(
                          \begin{array}{c}
                            \emptyset \\
                            \emptyset \\
                            \emptyset \\
                            \emptyset \\
                            \fun{dms}~\var{ds} \\
                          \end{array}
                        \right) \\
                        \left(
                          \begin{array}{c}
                            \emptyset \\
                            \emptyset \\
                            \emptyset \\
                            \emptyset \\
                          \end{array}
                        \right) \\
                        \end{array}
                      \right) \\
                    \end{array}
                  \right) \\
                  \pps{us} \\
                \end{array}
              \right) \\
              \\
              \Nothing \\
              \emptyset \\
              \emptyset \\
            \end{array}
          \right) \\
          \fun{hash}~{h} \\
          \fun{hash}~{h} \\
          \var{h} \\
          \var{s_{last}} \\
        \end{array}
      \right)
  \end{align*}

  \caption{Byron to Shelley State Transtition}
  \label{fig:functions:to-shelley}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "ledger-spec"
%%% End:
