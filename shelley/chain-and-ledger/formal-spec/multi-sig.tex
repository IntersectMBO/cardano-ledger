\documentclass[11pt,a4paper,dvipsnames]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{iohk}
\usepackage{microtype}
\usepackage{mathpazo} % nice fonts
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{extarrows}
\usepackage{slashed}
\usepackage[colon]{natbib}
\usepackage[unicode=true,pdftex,pdfa,colorlinks=true]{hyperref}
\usepackage{xcolor}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{enumerate}


%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
%% Setup for the semantic package
\setpremisesspace{20pt}

%%
%% Types
%%
\newcommand{\Nothing}{\ensuremath{\Diamond}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Bool}{\ensuremath{\mathbb{B}}}
\newcommand{\Tx}{\type{Tx}}
\newcommand{\TxBody}{\type{TxBody}}
\newcommand{\Ix}{\type{Ix}}
\newcommand{\TxId}{\type{TxId}}
\newcommand{\Addr}{\type{Addr}}
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\Wdrl}{\type{Wdrl}}
\newcommand{\Coin}{\type{Coin}}
\newcommand{\PParams}{\type{PParams}}

\newcommand{\Slot}{\type{Slot}}
\newcommand{\SlotsPerEpoch}{\mathsf{SlotsPerEpoch}}
\newcommand{\SlotsPerKESPeriod}{\mathsf{SlotsPerKESPeriod}}
\newcommand{\Duration}{\type{Duration}}
\newcommand{\StakePools}{\type{StakePools}}
\newcommand{\StakeKeys}{\type{StakeKeys}}

\newcommand{\DCert}{\type{DCert}}
\newcommand{\DCertRegKey}{\type{DCert_{regkey}}}
\newcommand{\DCertDeRegKey}{\type{DCert_{deregkey}}}
\newcommand{\DCertDeleg}{\type{DCert_{delegate}}}
\newcommand{\DCertRegPool}{\type{DCert_{regpool}}}
\newcommand{\DCertRetirePool}{\type{DCert_{retirepool}}}
\newcommand{\PoolParam}{\type{PoolParam}}
\newcommand{\UTxOState}{\ensuremath{\type{UTxOState}}}
\newcommand{\ledgerState}{\ensuremath{\type{ledgerState}}}

\newcommand{\AddrRWD}{\type{Addr_{rwd}}}
\newcommand{\AddrB}{\type{Addr_{base}}}
\newcommand{\AddrP}{\type{Addr_{ptr}}}
\newcommand{\AddrE}{\type{Addr_{enterprise}}}
\newcommand{\AddrBS}{\type{Addr_{bootstrap}}}
\newcommand{\AddrScr}{\type{Addr_{script}}}
\newcommand{\HashScr}{\type{Hash_{script}}}

\newcommand{\Ptr}{\type{Ptr}}
\newcommand{\DState}{\type{DState}}
\newcommand{\DWEnv}{\type{DWEnv}}
\newcommand{\DPSEnv}{\type{DPSEnv}}
\newcommand{\DPEnv}{\type{DPEnv}}
\newcommand{\DEnv}{\type{DEnv}}
\newcommand{\PEnv}{\type{PEnv}}
\newcommand{\DPState}{\type{DPState}}
\newcommand{\PState}{\type{PState}}
\newcommand{\DCertBody}{\type{DCertBody}}
\newcommand{\TData}{\type{TData}}
\newcommand{\DPoolReap}{\ensuremath{\type{poolreap}}}
\newcommand{\UPIState}{\type{UPIState}}
\newcommand{\UpdatePayload}{\type{UpdatePayload}}

\newcommand{\Script}{\type{Script}}

%% Adding witnesses
\newcommand{\TxIn}{\type{TxIn}}

\newcommand{\TxOut}{\type{TxOut}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\VKeyEv}{\type{VKey_{ev}}}
\newcommand{\VKeyGen}{\type{VKey_G}}
\newcommand{\SKey}{\type{SKey}}
\newcommand{\SKeyEv}{\type{SKey_{ev}}}
\newcommand{\HashKey}{\type{HashKey}}
\newcommand{\KeyPair}{\type{KeyPair}}
\newcommand{\KeyPairEv}{\type{KeyPair_{ev}}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
%% Adding delegation
\newcommand{\Epoch}{\type{Epoch}}
\newcommand{\KESPeriod}{\type{KESPeriod}}
%% Blockchain
\newcommand{\Gkeys}{\var{G_{keys}}}
\newcommand{\Block}{\type{Block}}
\newcommand{\SlotId}{\type{SlotId}}
\newcommand{\UTxOEnv}{\type{UTxOEnv}}
\newcommand{\CEEnv}{\type{CEEnv}}
\newcommand{\CEState}{\type{CEState}}
\newcommand{\BDEnv}{\type{BDEnv}}
\newcommand{\BDState}{\type{BDState}}
\newcommand{\LEnv}{\type{LEnv}}
\newcommand{\LState}{\type{LState}}

%%
%% Functions
%%
\newcommand{\txins}[1]{\fun{txins}~ \var{#1}}
\newcommand{\txouts}[1]{\fun{txouts}~ \var{#1}}
\newcommand{\txcerts}[1]{\fun{txcerts}~ \var{#1}}
\newcommand{\txid}[1]{\fun{txid}~ \var{#1}}
\newcommand{\outs}[1]{\fun{outs}~ \var{#1}}
\newcommand{\values}[1]{\fun{values}~ #1}
\newcommand{\ubalance}[1]{\fun{ubalance}~ \var{#1}}
\newcommand{\txttl}[1]{\fun{txttl}~ \var{#1}}
\newcommand{\firstSlot}[1]{\fun{firstSlot}~ \var{#1}}
\newcommand{\deposits}[2]{\fun{deposits}~ \var{#1} ~ \var{#2}}
\newcommand{\decayedKey}[4]{\fun{decayedKey}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\decayedTx}[3]{\fun{decayedTx}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\keyRefund}[6]{\fun{keyRefund}~ {#1}~{#2}~{#3}~\var{#4}~\var{#5}~\var{#6}}
\newcommand{\refund}[4]{\fun{refund}~ \var{#1}~ \var{#2}~ {#3}~ {#4}}
\newcommand{\keyRefunds}[3]{\fun{keyRefunds}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\consumed}[4]{\fun{consumed}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\produced}[2]{\fun{produced}~ \var{#1}~ \var{#2}}
\newcommand{\applyFun}[2]{\fun{#1}~\var{#2}}

\newcommand{\RegKey}[1]{\textsc{RegKey}(#1)}
\newcommand{\DeregKey}[1]{\textsc{DeregKey}(#1)}
\newcommand{\Delegate}[1]{\textsc{Delegate}(#1)}
\newcommand{\RegPool}[1]{\textsc{RegPool}(#1)}
\newcommand{\RetirePool}[1]{\textsc{RetirePool}(#1)}
\newcommand{\cwitness}[1]{\fun{cwitness}~ \var{#1}}
\newcommand{\dpool}[1]{\fun{dpool}~ \var{#1}}
\newcommand{\poolParam}[1]{\fun{poolParam}~ \var{#1}}
\newcommand{\retire}[1]{\fun{retire}~ \var{#1}}
\newcommand{\addrRw}[1]{\fun{addr_{rwd}}~ \var{#1}}
\newcommand{\epoch}[1]{\fun{epoch}~\var{#1}}
\newcommand{\kesPeriod}[1]{\fun{kesPeriod}~\var{#1}}
\newcommand{\dcerts}[1]{\fun{dcerts}~ \var{#1}}
\newcommand{\pps}[1]{\fun{pps}~ \var{#1}}

%% UTxO witnesses
\newcommand{\inputs}[1]{\fun{inputs}~ \var{#1}}
\newcommand{\txwits}[1]{\fun{txwits}~ \var{#1}}
\newcommand{\verify}[3]{\fun{verify} ~ #1 ~ #2 ~ #3}
\newcommand{\sign}[2]{\fun{sign} ~ #1 ~ #2}
\newcommand{\verifyEv}[4]{\fun{verify_{ev}} ~ #1 ~ #2 ~ #3 ~ #4}
\newcommand{\signEv}[3]{\fun{sign_{ev}} ~ #1 ~ #2 ~ #3}
\newcommand{\serialised}[1]{\llbracket \var{#1} \rrbracket}
\newcommand{\hashKey}[1]{\fun{hashKey}~ \var{#1}}
\newcommand{\txbody}[1]{\fun{txbody}~ \var{#1}}
\newcommand{\txfee}[1]{\fun{txfee}~ \var{#1}}
\newcommand{\txwdrls}[1]{\fun{txwdrls}~ \var{#1}}
\newcommand{\minfee}[2]{\fun{minfee}~ \var{#1}~ \var{#2}}
\newcommand{\slotminus}[2]{\var{#1}~-_{s}~\var{#2}}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
% wildcard parameter
\newcommand{\wcard}[0]{\underline{\phantom{a}}}
%% Adding ledgers...
\newcommand{\utxo}[1]{\fun{utxo}~ #1}
%% Delegation
\newcommand{\delegatesName}{\fun{delegates}}
\newcommand{\delegates}[3]{\delegatesName~#1~#2~#3}
\newcommand{\dwho}[1]{\fun{dwho}~\var{#1}}
\newcommand{\depoch}[1]{\fun{depoch}~\var{#1}}
\newcommand{\dval}{\ensuremath{d_{\mathsf{val}}}}
%% Delegation witnesses
\newcommand{\dbody}[1]{\fun{dbody}~\var{#1}}
\newcommand{\dwit}[1]{\fun{dwit}~\var{#1}}
%% Blockchain
\newcommand{\bwit}[1]{\fun{bwit}~\var{#1}}
\newcommand{\bslot}[1]{\fun{bslot}~\var{#1}}
\newcommand{\bbody}[1]{\fun{bbody}~\var{#1}}
\newcommand{\bhbody}[1]{\fun{bhbody}~\var{#1}}
\newcommand{\bdlgs}[1]{\fun{bdlgs}~\var{#1}}
%% ledgerstate constants
\newcommand{\genesisId}{\ensuremath{Genesis_{Id}}}
\newcommand{\genesisTxOut}{\ensuremath{Genesis_{Out}}}
\newcommand{\genesisUTxO}{\ensuremath{Genesis_{UTxO}}}
\newcommand{\emax}{\ensuremath{\mathsf{E_{max}}}}

\newcommand{\unitInterval}{\ensuremath{[0,~1]}}
\newcommand{\unitIntervalNonNull}{\ensuremath{(0,~1]}}
\newcommand{\nonnegReals}{\ensuremath{[0,~\infty)}}
\newcommand{\posReals}{\ensuremath{(0,~\infty)}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{property}{Property}[section]

\newcommand{\leteq}{\ensuremath{\mathrel{\mathop:}=}}

\begin{document}

\hypersetup{
  pdftitle={A Formal Specification of a Multi-Signature Scheme using Scripts},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}

\title{A Formal Specification of a Multi-Signature Scheme using Scripts}

\author{Jared Corduan  \\ {\small \texttt{jared.corduan@iohk.io}} \\
   \and Matthias G\"udemann  \\ {\small \texttt{matthias.gudemann@iohk.io}}}

%\date{}

\maketitle

\begin{abstract}
  This documents specifies a simple way to support multi-signature
  transactions. It is based on a simple script model which uses only single step
  script execution and does not require data scripts.

  A multi-signature scheme allows an unspent transaction output to be used as an
  input to a new transaction if a pre-defined combination of signatures is
  provided, e.g., two persons have to sign simultaneously, two out of three
  keys have to be provided, etc.

  For an output that is locked with a multi-signature, the set of all keys that
  signed the transaction is given to the script for validation. In this way, the
  script can decide in a single step whether is has the correct key combination
  to spend the output.
\end{abstract}

% \section*{List of Contributors}
% \label{acknowledgements}

% \tableofcontents
% \listoffigures

\section{Introduction}
\label{sec:introduction}

This specification for a simple multi-signature scheme is based
on~\cite{shelley_formal_spec} which formally specifies the Shelley Cardano
ledger. The main changes are the following:

\begin{itemize}
\item Add a new address type that for outputs locked by scripts.
\item Change the type of transaction inputs of a transaction to optionally
  include a validator script.
\item Adapt the transaction validation in such a way that funds locked by a
  multi-signature script can be spent.
\item Adapt the functions used in the validation for the extended types of
  addresses and transaction inputs with scripts.
\end{itemize}

In this approach for multi-signature, the scripts receive a set of hashed keys
where each corresponding key was used to correctly sign the transaction. The
script can then simply check the hashes against its own representation of which
keys in which combination can unlock the unspent output.

This means that the scripts are completely stateless and no data needs to be
supplied to the script apart from the hashed keys used to sign the transaction.
It allows for any type of $n$ out of $m$ required signatures for a specific
unspent transaction output.

\section{Types}
\label{sec:types}

\begin{figure*}[hbt]
  \emph{Abstract types}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      script & \Script & \text{script type}
    \end{array}
  \end{equation*}

  \emph{Derived types}

  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{addr} & \AddrScr & \HashScr & \text{Script address} \\
      \var{addr} & \Addr & \begin{array}{l@{~\uniondistinct}l}
                             \AddrB & \AddrP \uniondistinct \AddrE \\
                                    & \AddrBS \uniondistinct \AddrScr
                           \end{array}
                            & \text{output address}
    \end{array}
  \end{equation*}

  \emph{Accessor Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{paymentHK} & \Addr \to \HashKey_{pay}^{?}
      & \text{hash of payment key from addr}\\
      \fun{validatorHash} & \Addr \to \HashScr^{?} & \text{hash of validator script}
    \end{array}
  \end{equation*}

  \emph{Abstract Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{hashScript} & \Script \to \HashScr & \text{hash a script}
    \end{array}
  \end{equation*}

  \caption{Types for Scripts and Script Addresses}
  \label{fig:types-scripts}
\end{figure*}

In Figure~\ref{fig:types-scripts} the $\Addr$ type of~\cite{shelley_formal_spec}
is extended to also include script addresses. This new script address comprises
the hash of the validator script.

An transaction output that is locked by a script carries the hash of the
validator script. The output can only be spent if the matching script is
presented and validates its input. The $\AddrScr$
(Figure~\ref{fig:types-scripts}) sub-type of $\Addr$ carries those two pieces of
information and can therefore be part of a transaction output that consists of a
pair of $\Addr\times\Coin$.

The $\fun{hashScript}$ function calculates the hash of a script. The accessor
function $\fun{paymentHK}$ is changed to return an optional hash key now, as
script addresses do not carry hash keys. The accessor function
$\fun{validatorHash}$ returns the hash of a script of a script address, or
$\Nothing$ in case of a non-script address.

\begin{figure*}[hbt]
  \emph{Transaction Type}

  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{txbody}
      & \TxBody
      & \powerset{(\TxIn \times \Script^{?})} \times (\Ix \mapsto \TxOut) \times \seqof{\DCert}
        \times \Coin \times \Slot \times \Wdrl
      \\
    \end{array}
  \end{equation*}

  \emph{Accessor Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{txins} & \Tx \to \powerset{(\TxIn \times \Script^{?})} & \text{transaction inputs}
    \end{array}
  \end{equation*}

  \emph{Abstract Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{validateMultiSig} & \Script \to \powerset\HashKey \to \Bool &
                                                                         \text{validate
                                                                         multi-sig}
    \end{array}
  \end{equation*}
  \caption{Types for Transaction Inputs with Scripts}
  \label{fig:types_defs_multi}
\end{figure*}

In Figure~\ref{fig:types_defs_multi} the type for the transaction body
from~\cite{shelley_formal_spec} is extended to optionally carry a validator
script for an unspent output that is locked by a script and should be spent in
the transaction.

To validate a transaction that spends funds that are locked by a multi-signature
script, the $\fun{validateMultiSig}$ function takes the validator script and a
set of verification hash keys. The requirement for the hash keys passed to the
validator script is that the transaction has been correctly signed with each
key. Therefore the script only needs to check whether the set of keys is
sufficient to validate the multi-signature.

\section{Ledger Transition for Multi-Signature}
\label{sec:ledg-trans-multi}

The main change for the ledger transitions when using multi-signature based on
scripts is the validation of the UTxOW and UTxO transitions
of~\cite{shelley_formal_spec}.

The extended transition system for UTxOW is shown in
Figure~\ref{fig:rules:utxow-multi-sig}, in the format described
in~\cite{small_step_semantics}. The constraint on the set of required witnesses
is relaxed in such a way that ``redundant'' signatures can be supplied in the
transaction. The complete set of verification keys is then passed to
$\fun{validateMultiSig}$ when validating all supplied scripts.

\begin{figure}[htb]
  \begin{equation*}
    \inference[UTxO-wit]
    {
      (utxo, \wcard, \wcard) \leteq \var{utxoSt} \\~\\
      \forall \var{s}\mapsto\var{a} \in
      \left\{
        \var{s}\mapsto\var{a}\vert
        (\var{inp}, \var{s})\in\fun{txins}~tx,
        \var{inp}\mapsto(\var{a},\wcard) \in \var{utxo},
        \var{s}\neq\Nothing
      \right\},\\
      \fun{validatorHash}~\var{a}
      = \fun{hashScript}~s \wedge
      \fun{validateMultiSig}~{s}~{(\dom{(\txwits{tx})})}\\~\\
      \forall \var{vk} \mapsto \sigma \in \txwits{tx},
      \mathcal{V}_{\var{vk}}{\serialised{\txbody{tx}}}_{\sigma} \\
      \fun{witsNeeded}~{utxo}~{tx} \subseteq \{ \hashKey \var{vk} \mid \var{vk}\in\dom{(\txwits{tx})} \}\\
      {
        \begin{array}{l}
        \var{utxoEnv}
        \end{array}
      }
      \vdash \var{utxoSt} \trans{utxo}{tx} \var{utxoSt'}\\
    }
    {
      \begin{array}{l}
        \var{utxoEnv}
      \end{array}
      \vdash \var{utxoSt} \trans{utxow}{tx} \varUpdate{\var{utxoSt'}}
    }
  \end{equation*}
  \caption{UTxO with Witnesses and Multi-Sig}
  \label{fig:rules:utxow-multi-sig}
\end{figure}

In the UTxO transition rule, the transaction inputs are used to restrict the
domain of the $\var{utxo}$. As the return type of the function $\fun{txins}$ has
been changed, we define the local variable $\var{txInps}$ as the projection of
the returned triples of $\fun{txins}$ onto the first two values which correspond
to the domain of the mapping in the UTxO.

\begin{figure}[htb]
  \begin{equation}\label{eq:utxo-inductive-shelley}
    \inference[UTxO-inductive]
    { \var{txInps} \leteq \{(\var{txid},\var{ix}) \vert (\var{txid}, \var{ix},
      \wcard)\in\txins{tx}\} \\~\\
      \txttl tx \geq \var{slot}
      & \txins{tx} \neq \emptyset
      & \minfee{pp}{tx} \leq \txfee{tx}
      & \var{txInps}\subseteq \dom \var{utxo}
      \\
      \consumed{pp}{utxo}{stkeys}{rewards}~{tx} = \produced{pp}{stpools}~{tx}
      \\
      ~
      \\
      \forall (\_\mapsto (\_, c)) \in \txouts{tx}, c \geq 0
      \\
      ~
      \\
      \var{refunded} \leteq \keyRefunds{pp}{stkeys}~{tx}
      \\
      \var{decayed} \leteq \decayedTx{pp}{stkeys}~{tx}
      \\
      \var{depositChange} \leteq
        (\deposits{pp}~{stpools}~{\fun{dcerts}~tx}) - (\var{refunded} + \var{decayed})
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{stkeys}\\
        \var{stpools}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
      \end{array}
      \right)
      \trans{utxo}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{(\var{txInps}\subtractdom \var{utxo}) \cup \outs{tx}}  \\
        \varUpdate{\var{deposits} + \var{depositChange}} \\
        \varUpdate{\var{fees} + \txfee{tx} + \var{decayed}} \\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:rules:utxo-mulit-sig}
\end{figure}

In order to work with the new types, some function definitions
of~\cite{shelley_formal_spec} have to be extended. Those functions are listed in
Figure~\ref{fig:functions-witnesses-multi-sig}. The function $\fun{witsNeeded}$
only collects the payment keys for non-script addresses.

The function $\fun{consumed}$ computes the sum of all coin values spent by a
transaction. As the return value of the function $\fun{txins}$ has been changed,
the parameter passed to $\fun{ubalance}$ has to be adapted, too, by projecting
the returned triple onto the first two entries.

\begin{figure}[htb]
  \begin{align*}
    & \fun{witsNeeded} \in \UTxO \to \Tx \to \powerset{\HashKey}
    & \begin{array}{r}
        \text{hashkeys of} \\
        \text{required witnesses}
      \end{array} \\
    & \fun{witsNeeded}~{utxo}~{tx} = \\
    & ~~\{ \fun{paymentHK}~a \mid i \mapsto (a, \wcard) \in
      \var{utxo},~(i,\Nothing)\in\txins{tx}\}~\cup \\
    & ~~\{\fun{stakeHK_r}~a \mid a\mapsto \wcard \in \txwdrls{tx}\}~\cup \\
    & ~~\{\cwitness{c} \mid c \in \txcerts{tx}\}~\cup \\
    & ~~\bigcup_{\substack{c \in \txcerts{tx} \\ ~c \in\DCertRegPool}}
    \fun{poolOwners}~{c}
    \nextdef
    & \fun{consumed} \in \PParams \to \UTxO \to \StakeKeys \to \Wdrl \to \Tx \to \Coin
    & \text{value consumed} \\
    & \consumed{pp}{utxo}{stkeys}{rewards}~{tx} = \\
    & ~~\ubalance{(\{(\var{txid},\var{ix}) \vert (\var{txid}, \var{ix},
      \wcard)\in\txins{tx}\}
      \restrictdom \var{utxo})} + \\
    & \;\;\fun{wbalance}~(\fun{txwdrls}~{tx}) + \keyRefunds{pp}{stkeys}{tx}
  \end{align*}
  \caption{Functions used in Witness Rule with Multi-Sig}
  \label{fig:functions-witnesses-multi-sig}
\end{figure}

\section{Summary}
\label{sec:summary}

The presented simple multi-signature scheme does not require the scripts to use
any cryptographic primitives. It requires only the ability to compare hashed
keys. Gas cost can be calculated statically in advance. The scripts could be
realized as smart contracts with only limited requirements on functionality on
the script language.

The necessary extensions to the data types in the Shelley
specification~\cite{shelley_formal_spec} are relatively simple. They consist
mainly of the introduction of additional optional data for scripts or hashed
scripts.

The relaxation on accepting a superset of the strictly required signatures
allows the creation of transactions with an arbitrary number of signatures. This
potentially is a risk for an attack. The number of signatures should be taken
into account in some way in the calculation of the transaction fee.

\addcontentsline{toc}{section}{References} \bibliographystyle{plainnat}
\bibliography{references}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
