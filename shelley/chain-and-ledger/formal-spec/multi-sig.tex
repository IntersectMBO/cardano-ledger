\documentclass[11pt,a4paper,dvipsnames]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{iohk}
\usepackage{microtype}
\usepackage{mathpazo} % nice fonts
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{extarrows}
\usepackage{slashed}
\usepackage[colon]{natbib}
\usepackage[unicode=true,pdftex,pdfa,colorlinks=true]{hyperref}
\usepackage{xcolor}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{enumerate}


%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
%% Setup for the semantic package
\setpremisesspace{20pt}

%%
%% Types
%%
\newcommand{\Nothing}{\ensuremath{\Diamond}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Bool}{\ensuremath{\mathbb{B}}}
\newcommand{\Tx}{\type{Tx}}
\newcommand{\TxBody}{\type{TxBody}}
\newcommand{\Ix}{\type{Ix}}
\newcommand{\TxId}{\type{TxId}}
\newcommand{\Addr}{\type{Addr}}
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\Wdrl}{\type{Wdrl}}
\newcommand{\Coin}{\type{Coin}}
\newcommand{\PParams}{\type{PParams}}

\newcommand{\Slot}{\type{Slot}}
\newcommand{\SlotsPerEpoch}{\mathsf{SlotsPerEpoch}}
\newcommand{\SlotsPerKESPeriod}{\mathsf{SlotsPerKESPeriod}}
\newcommand{\Duration}{\type{Duration}}
\newcommand{\StakePools}{\type{StakePools}}
\newcommand{\StakeKeys}{\type{StakeKeys}}

\newcommand{\DCert}{\type{DCert}}
\newcommand{\DCertRegKey}{\type{DCert_{regkey}}}
\newcommand{\DCertDeRegKey}{\type{DCert_{deregkey}}}
\newcommand{\DCertDeleg}{\type{DCert_{delegate}}}
\newcommand{\DCertRegPool}{\type{DCert_{regpool}}}
\newcommand{\DCertRetirePool}{\type{DCert_{retirepool}}}
\newcommand{\PoolParam}{\type{PoolParam}}
\newcommand{\UTxOState}{\ensuremath{\type{UTxOState}}}
\newcommand{\ledgerState}{\ensuremath{\type{ledgerState}}}

\newcommand{\AddrRWD}{\type{Addr_{rwd}}}
\newcommand{\AddrB}{\type{Addr_{base}}}
\newcommand{\AddrP}{\type{Addr_{ptr}}}
\newcommand{\AddrE}{\type{Addr_{enterprise}}}
\newcommand{\AddrBS}{\type{Addr_{bootstrap}}}
\newcommand{\AddrScr}{\type{Addr_{script}}}
\newcommand{\AddrScrBase}{\type{Addr_{base}^{script}}}
\newcommand{\AddrScrEnterprise}{\type{Addr_{enterprise}^{script}}}
\newcommand{\AddrScrPtr}{\type{Addr_{ptr}^{script}}}
\newcommand{\HashScr}{\type{Hash_{script}}}

\newcommand{\Ptr}{\type{Ptr}}
\newcommand{\DState}{\type{DState}}
\newcommand{\DWEnv}{\type{DWEnv}}
\newcommand{\DPSEnv}{\type{DPSEnv}}
\newcommand{\DPEnv}{\type{DPEnv}}
\newcommand{\DEnv}{\type{DEnv}}
\newcommand{\PEnv}{\type{PEnv}}
\newcommand{\DPState}{\type{DPState}}
\newcommand{\PState}{\type{PState}}
\newcommand{\DCertBody}{\type{DCertBody}}
\newcommand{\TData}{\type{TData}}
\newcommand{\DPoolReap}{\ensuremath{\type{poolreap}}}
\newcommand{\UPIState}{\type{UPIState}}
\newcommand{\UpdatePayload}{\type{UpdatePayload}}

\newcommand{\Script}{\type{Script}}
\newcommand{\PendingTx}{\type{PendingTx}}

%% Adding witnesses
\newcommand{\TxIn}{\type{TxIn}}

\newcommand{\TxOut}{\type{TxOut}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\VKeyEv}{\type{VKey_{ev}}}
\newcommand{\VKeyGen}{\type{VKey_G}}
\newcommand{\SKey}{\type{SKey}}
\newcommand{\SKeyEv}{\type{SKey_{ev}}}
\newcommand{\HashKey}{\type{HashKey}}
\newcommand{\KeyPair}{\type{KeyPair}}
\newcommand{\KeyPairEv}{\type{KeyPair_{ev}}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
%% Adding delegation
\newcommand{\Epoch}{\type{Epoch}}
\newcommand{\KESPeriod}{\type{KESPeriod}}
%% Blockchain
\newcommand{\Gkeys}{\var{G_{keys}}}
\newcommand{\Block}{\type{Block}}
\newcommand{\SlotId}{\type{SlotId}}
\newcommand{\UTxOEnv}{\type{UTxOEnv}}
\newcommand{\CEEnv}{\type{CEEnv}}
\newcommand{\CEState}{\type{CEState}}
\newcommand{\BDEnv}{\type{BDEnv}}
\newcommand{\BDState}{\type{BDState}}
\newcommand{\LEnv}{\type{LEnv}}
\newcommand{\LState}{\type{LState}}

%%
%% Functions
%%
\newcommand{\txins}[1]{\fun{txins}~ \var{#1}}
\newcommand{\txouts}[1]{\fun{txouts}~ \var{#1}}
\newcommand{\txcerts}[1]{\fun{txcerts}~ \var{#1}}
\newcommand{\txid}[1]{\fun{txid}~ \var{#1}}
\newcommand{\outs}[1]{\fun{outs}~ \var{#1}}
\newcommand{\values}[1]{\fun{values}~ #1}
\newcommand{\ubalance}[1]{\fun{ubalance}~ \var{#1}}
\newcommand{\txttl}[1]{\fun{txttl}~ \var{#1}}
\newcommand{\firstSlot}[1]{\fun{firstSlot}~ \var{#1}}
\newcommand{\deposits}[2]{\fun{deposits}~ \var{#1} ~ \var{#2}}
\newcommand{\decayedKey}[4]{\fun{decayedKey}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\decayedTx}[3]{\fun{decayedTx}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\keyRefund}[6]{\fun{keyRefund}~ {#1}~{#2}~{#3}~\var{#4}~\var{#5}~\var{#6}}
\newcommand{\refund}[4]{\fun{refund}~ \var{#1}~ \var{#2}~ {#3}~ {#4}}
\newcommand{\keyRefunds}[3]{\fun{keyRefunds}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\consumed}[4]{\fun{consumed}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\produced}[2]{\fun{produced}~ \var{#1}~ \var{#2}}
\newcommand{\applyFun}[2]{\fun{#1}~\var{#2}}

\newcommand{\RegKey}[1]{\textsc{RegKey}(#1)}
\newcommand{\DeregKey}[1]{\textsc{DeregKey}(#1)}
\newcommand{\Delegate}[1]{\textsc{Delegate}(#1)}
\newcommand{\RegPool}[1]{\textsc{RegPool}(#1)}
\newcommand{\RetirePool}[1]{\textsc{RetirePool}(#1)}
\newcommand{\cwitness}[1]{\fun{cwitness}~ \var{#1}}
\newcommand{\dpool}[1]{\fun{dpool}~ \var{#1}}
\newcommand{\poolParam}[1]{\fun{poolParam}~ \var{#1}}
\newcommand{\retire}[1]{\fun{retire}~ \var{#1}}
\newcommand{\addrRw}[1]{\fun{addr_{rwd}}~ \var{#1}}
\newcommand{\epoch}[1]{\fun{epoch}~\var{#1}}
\newcommand{\kesPeriod}[1]{\fun{kesPeriod}~\var{#1}}
\newcommand{\dcerts}[1]{\fun{dcerts}~ \var{#1}}
\newcommand{\pps}[1]{\fun{pps}~ \var{#1}}

%% UTxO witnesses
\newcommand{\inputs}[1]{\fun{inputs}~ \var{#1}}
\newcommand{\txwitsVKey}[1]{\fun{txwitsVKey}~\var{#1}}
\newcommand{\txwitsScript}[1]{\fun{txwitsScript}~\var{#1}}
\newcommand{\verify}[3]{\fun{verify} ~ #1 ~ #2 ~ #3}
\newcommand{\sign}[2]{\fun{sign} ~ #1 ~ #2}
\newcommand{\verifyEv}[4]{\fun{verify_{ev}} ~ #1 ~ #2 ~ #3 ~ #4}
\newcommand{\signEv}[3]{\fun{sign_{ev}} ~ #1 ~ #2 ~ #3}
\newcommand{\serialised}[1]{\llbracket \var{#1} \rrbracket}
\newcommand{\hashKey}[1]{\fun{hashKey}~ \var{#1}}
\newcommand{\txbody}[1]{\fun{txbody}~ \var{#1}}
\newcommand{\txfee}[1]{\fun{txfee}~ \var{#1}}
\newcommand{\txwdrls}[1]{\fun{txwdrls}~ \var{#1}}
\newcommand{\minfee}[2]{\fun{minfee}~ \var{#1}~ \var{#2}}
\newcommand{\slotminus}[2]{\var{#1}~-_{s}~\var{#2}}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
% wildcard parameter
\newcommand{\wcard}[0]{\underline{\phantom{a}}}
%% Adding ledgers...
\newcommand{\utxo}[1]{\fun{utxo}~ #1}
%% Delegation
\newcommand{\delegatesName}{\fun{delegates}}
\newcommand{\delegates}[3]{\delegatesName~#1~#2~#3}
\newcommand{\dwho}[1]{\fun{dwho}~\var{#1}}
\newcommand{\depoch}[1]{\fun{depoch}~\var{#1}}
\newcommand{\dval}{\ensuremath{d_{\mathsf{val}}}}
%% Delegation witnesses
\newcommand{\dbody}[1]{\fun{dbody}~\var{#1}}
\newcommand{\dwit}[1]{\fun{dwit}~\var{#1}}
%% Blockchain
\newcommand{\bwit}[1]{\fun{bwit}~\var{#1}}
\newcommand{\bslot}[1]{\fun{bslot}~\var{#1}}
\newcommand{\bbody}[1]{\fun{bbody}~\var{#1}}
\newcommand{\bhbody}[1]{\fun{bhbody}~\var{#1}}
\newcommand{\bdlgs}[1]{\fun{bdlgs}~\var{#1}}
%% ledgerstate constants
\newcommand{\genesisId}{\ensuremath{Genesis_{Id}}}
\newcommand{\genesisTxOut}{\ensuremath{Genesis_{Out}}}
\newcommand{\genesisUTxO}{\ensuremath{Genesis_{UTxO}}}
\newcommand{\emax}{\ensuremath{\mathsf{E_{max}}}}

\newcommand{\unitInterval}{\ensuremath{[0,~1]}}
\newcommand{\unitIntervalNonNull}{\ensuremath{(0,~1]}}
\newcommand{\nonnegReals}{\ensuremath{[0,~\infty)}}
\newcommand{\posReals}{\ensuremath{(0,~\infty)}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{property}{Property}[section]

\newcommand{\leteq}{\ensuremath{\mathrel{\mathop:}=}}

\begin{document}

\hypersetup{
  pdftitle={A Formal Specification of a Multi-Signature Scheme using Scripts},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}

\title{A Formal Specification of a Multi-Signature Scheme using Scripts}

\author{Jared Corduan  \\ {\small \texttt{jared.corduan@iohk.io}} \\
   \and Matthias G\"udemann  \\ {\small \texttt{matthias.gudemann@iohk.io}}}

%\date{}

\maketitle

\begin{abstract}
  This documents specifies a way to support multi-signature transactions. It is
  based on a simple script model which uses only single step script execution
  and does not require data scripts.

  A multi-signature scheme allows an unspent transaction output to be used as an
  input to a new transaction if a pre-defined combination of signatures is
  provided, e.g., two persons have to sign simultaneously, two out of three
  keys have to be provided, etc.

  For an output that is locked with a multi-signature, the set of all keys that
  signed the transaction is given to the script for validation. In this way, the
  script can decide in a single step whether is has the correct key combination
  to spend the output.
\end{abstract}

% \section*{List of Contributors}
% \label{acknowledgements}

% \tableofcontents
% \listoffigures

\section{Introduction}
\label{sec:introduction}

This specification for a simple multi-signature scheme is based
on~\cite{shelley_formal_spec} which formally specifies the Shelley Cardano
ledger. The main changes are the following:

\begin{itemize}
\item Add a new address type that for outputs locked by scripts.
\item Pair transaction inputs in a transaction with an optional validator
  script for outputs locked by a script.
\item Adapt the transaction validation in such a way that funds locked by a
  multi-signature script can be spent.
\item Adapt the functions used in the validation for the extended types of
  addresses and transaction inputs with scripts.
\end{itemize}

In this approach for multi-signature, the scripts receive the set of keys which
were used to sign the transaction. The script can then check those against its
own representation of which keys in which combination can unlock the unspent
output.

This means that the scripts are completely stateless and no data needs to be
supplied to the script apart from the information about which keys and in which
combination can sign the transaction. It allows for any type of $n$ out of $m$
required signatures for a specific unspent transaction output.

\section{Types}
\label{sec:types}

\begin{figure*}[hbt]
  \emph{Abstract types}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      script & \Script & \text{script type}
    \end{array}
  \end{equation*}

  \emph{Derived types}

  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{addr} & \AddrScr & \AddrScrBase \uniondistinct \AddrScrEnterprise
                              \uniondistinct \AddrScrPtr & \text{Script address} \\
      \var{addr} & \Addr & \begin{array}{l@{~\uniondistinct}l}
                             \AddrB & \AddrP \uniondistinct \AddrE \\
                                    & \AddrBS \uniondistinct \AddrScr
                           \end{array}
                            & \text{output address}
    \end{array}
  \end{equation*}

  \emph{Accessor Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{paymentHK} & \Addr \to \HashKey_{pay}^{?}
      & \text{hash of payment key from addr}\\
      \fun{validatorHash} & \Addr \to \HashScr^{?} & \text{hash of validator
                                                     script} \\
      \fun{stakeHK_{b}} & (\AddrB \uniondistinct \AddrScrBase) \to
                          \HashKey_{stake} & \text{hash of stake key for base
                                             addresses}\\
      \fun{addrPtr} & (\AddrP \uniondistinct \AddrScrPtr) \to \Ptr &
                                                                     \text{pointer
                                                                     from
                                                                     pointer addresses}
    \end{array}
  \end{equation*}

  \emph{Abstract Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{hashScript} & \Script \to \HashScr & \text{hash a script}
    \end{array}
  \end{equation*}

  \caption{Types for Scripts and Script Addresses}
  \label{fig:types-scripts}
\end{figure*}

In Figure~\ref{fig:types-scripts} the $\Addr$ type of~\cite{shelley_formal_spec}
is extended to also include script addresses. This new script address contains
the hash of the validator script. In accordance with the extended UTxO
specification of Plutus~\cite{plutus_eutxo}, the producer signs the script when
creating and the consumer provides it later when spending the output.

A transaction output that is locked by a script carries the hash of the
validator script. The output can only be spent if the matching script is
presented and validates its input. The $\AddrScr$
(Figure~\ref{fig:types-scripts}) sub-type of $\Addr$ carries the necessary
information and can therefore be part of a transaction output that consists of a
pair of $\Addr\times\Coin$. Analogously to $\Addr$, $\AddrScr$ also has an
\emph{enterprise} script address sub-type which does not allow for using the
locked funds in staking, as well as \emph{base} and \emph{pointer} script
address sub-types which allow for staking in the same way as $\AddrB$ and
$\AddrP$.

The $\fun{hashScript}$ function calculates the hash of a script. The accessor
function $\fun{validatorHash}$ returns the hash of a script of a script address,
or $\Nothing$ in case of a non-script address. The accessor function
$\fun{paymentHK}$ is changed to return an optional hash key now, as script
addresses do not carry hash keys. The domains of the accessor functions
$\fun{stakeHK_b}$ and $\fun{addrPtr}$ are extended to also include the
respective script address variants.

\begin{figure*}[hbt]
  \emph{Abstract Type}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      pendingTx & \PendingTx & \text{information about pending Tx}
    \end{array}
  \end{equation*}

  \emph{Transaction Type}

  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{txbody}
      & \TxBody
      & \powerset{(\TxIn \times \Script^{?})} \times (\Ix \mapsto \TxOut) \times \seqof{\DCert}
        \times \Coin \times \Slot \times \Wdrl
      \\
    \end{array}
  \end{equation*}

  \emph{Accessor Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{txinsVKey} & \Tx \to \powerset{\TxIn} &\text{VKey locked transaction inputs} \\
      \fun{txinsScript} & \Tx \to \powerset{(\TxIn \times \Script)} &\text{Script locked transaction inputs} \\
      \fun{txwitsVKey} & \Tx \to (\VKey \mapsto \Sig) & \text{VKey witnesses} \\
    \end{array}
  \end{equation*}

  \emph{Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{txwitsScripts} & \Tx \to \powerset{\Script} & \text{script witnesses}
    \end{array}
  \end{equation*}

  \emph{Abstract Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{txPending} & \Tx \to \PendingTx & \text{Get necessary information from Tx} \\
      \fun{validate} & () \to () \to \PendingTx \to () & \text{validate multi-sig}
    \end{array}
  \end{equation*}
  \caption{Types for Transaction Inputs with Scripts}
  \label{fig:types_defs_multi}
\end{figure*}

In Figure~\ref{fig:types_defs_multi} the type for the transaction body
from~\cite{shelley_formal_spec} is extended to optionally carry a validator
script for an unspent output that is locked by a script and should be spent in
the transaction.

The new script addresses also require a new type of witness. The former
$\fun{txwits}$ is renamed to $\fun{txwitsVKey}$. The new function
$\fun{txwitsScript}$ returns the set of all validator scripts of a
transaction. All scripts in this set need to validate the transaction in order
for it to be accepted.

$\PendingTx$ is a representation of the pending transaction. In particular, this
information contains the set of keys that signed the transaction. The function
$\fun{txPending}$ constructs the necessary information about a transaction
which can be passed as value of type $\PendingTx$ to the validator script.

In order to spend funds locked by a multi-signature script, the validator script
need to validate the transaction. The abstract function $\fun{validate}$
corresponds to such a validator script. Its type consists of two parameters of
unit type and one parameter of type $\PendingTx$; its return type is also
unit. The first two input parameters correspond to the redeemer and the data
scripts which are used in the full extended UTxO model for
Plutus~\cite{plutus_eutxo}. As those values are not required for simple
multi-signature, we the unit type for them. The unit return type signifies that
there is no data to return. Plutus uses an ``error'' state to represent a failed
validation. Despite that, we will use the validate function as a predicate where
\emph{False} corresponds to the Plutus error state and \emph{True} to the unit
return result.

The following is a possible Plutus implementation of a simple $n$ out of $m$
multi-signature validation script. The type $\type{MultiSig}$ is a list of keys
and a threshold value.

\begin{verbatim}
   validate :: MultiSig -> () -> () -> PendingTx -> ()
   validate (MultiSig keys num) () () p =
       let
           present = P.length (P.filter (V.txSignedBy p) keys)
       in
           if P.geq present num
           then ()
           else P.error (P.traceH "WRONG!" ())
\end{verbatim}

The above script takes a parameter of type $\type{MultiSig}$ which is a list of
keys and a threshold $num$ which indicates how many of the keys of the list
$keys$ are at least required as signatures. When $\fun{validate}$ it is called,
it computes the list of keys in $keys$ which signed the transaction. If the
length of that list is greater than or equal to $num$, then enough signatures
for the multi-signature are present. Else the script ends in the Plutus
``error'' state. Therefore, calling $validate~hkeys$ will return a validator
script with the correct type according as in Figure~\ref{fig:types_defs_multi}
when $hkeys$ is a value of type $\type{MultiSig}$.

\section{Ledger Transition for Multi-Signature}
\label{sec:ledg-trans-multi}

The main change for the ledger transitions when using script based
multi-signature is the validation of the UTXOW and UTXO transitions
of~\cite{shelley_formal_spec}.

The extended transition system for UTxOW is shown in
Figure~\ref{fig:rules:utxow-multi-sig}, in the format described
in~\cite{small_step_semantics}. The constraint on the set of required witnesses
is relaxed in such a way that ``redundant'' signatures can be supplied in the
transaction. The complete set of verification keys is then passed to
$\fun{validate}$ as part of $pendingTx$ when validating all supplied scripts.
We also check that no input from $\fun{txinsVKey}~tx$ tries to spend an output
locked by a script.

The set of all validator scripts of $\fun{txinsScript~tx}$ is checked for:
\begin{itemize}
\item the script hash being equal to the hash stored in the output to spent and
\item the validator script validating the transaction.
\end{itemize}

\begin{figure}[htb]
  \begin{equation*}
    \inference[UTxO-wit]
    {
      (utxo, \wcard, \wcard) \leteq \var{utxoSt} \\
      validators \leteq \left\{
        \var{s}\mapsto\var{a}\vert
        (\var{inp}, \var{s})\in\fun{txinsScript}~tx,
        \var{inp}\mapsto(\var{a},\wcard) \in \var{utxo}
      \right\}
      \\~\\
      \forall \var{validate}\mapsto\var{a} \in validators, \fun{validatorHash}~\var{a} = \fun{hashScript}~validate \\
      \forall \var{validate} \in \dom~validators, \fun{validate}~()~()~{(\fun{pendingTx}~tx)}\\~\\
      \range(\fun{txinsVKey}~tx \restrictdom \var{utxo}) \cap (\AddrScr\times\Coin) = \emptyset
      \\~\\
      \forall \var{vk} \mapsto \sigma \in \txwitsVKey{tx},
      \mathcal{V}_{\var{vk}}{\serialised{\txbody{tx}}}_{\sigma} \\
      \fun{witsNeeded}~{utxo}~{tx} \subseteq \{ \hashKey \var{vk} \mid \var{vk}\in\dom{(\txwitsVKey{tx})} \}\\
      {
        \begin{array}{l}
        \var{utxoEnv}
        \end{array}
      }
      \vdash \var{utxoSt} \trans{utxo}{tx} \var{utxoSt'}\\
    }
    {
      \begin{array}{l}
        \var{utxoEnv}
      \end{array}
      \vdash \var{utxoSt} \trans{utxow}{tx} \varUpdate{\var{utxoSt'}}
    }
  \end{equation*}
  \caption{UTxO with Witnesses and Multi-Sig}
  \label{fig:rules:utxow-multi-sig}
\end{figure}

In the UTXO transition rule, the transaction inputs are used to restrict the
domain of the $\var{utxo}$. We define the local variable $\var{txInps}$ as the
union of $\fun{txinsVKey}~tx$ and the domain of $\fun{txinsScript}~tx$. This
variable consists of all inputs that the transaction wants to consume. It has to
be a subset of the domain of $utxo$ and cannot be empty.

\begin{figure}[htb]
  \begin{equation}\label{eq:utxo-inductive-shelley}
    \inference[UTxO-inductive]
    { \var{txInps} \leteq \fun{txinsVKey}~tx \cup \dom (\fun{txinsScript}~tx)\\~\\
      \txttl tx \geq \var{slot}
      & txInps \neq \emptyset
      & \minfee{pp}{tx} \leq \txfee{tx}
      & \var{txInps}\subseteq \dom \var{utxo}
      \\
      \consumed{pp}{utxo}{stkeys}{rewards}~{tx} = \produced{pp}{stpools}~{tx}
      \\
      ~
      \\
      \forall (\_\mapsto (\_, c)) \in \txouts{tx}, c \geq 0
      \\
      ~
      \\
      \var{refunded} \leteq \keyRefunds{pp}{stkeys}~{tx}
      \\
      \var{decayed} \leteq \decayedTx{pp}{stkeys}~{tx}
      \\
      \var{depositChange} \leteq
        (\deposits{pp}~{stpools}~{\fun{dcerts}~tx}) - (\var{refunded} + \var{decayed})
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{stkeys}\\
        \var{stpools}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
      \end{array}
      \right)
      \trans{utxo}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{(\var{txInps}\subtractdom \var{utxo}) \cup \outs{tx}}  \\
        \varUpdate{\var{deposits} + \var{depositChange}} \\
        \varUpdate{\var{fees} + \txfee{tx} + \var{decayed}} \\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:rules:utxo-multi-sig}
\end{figure}

In order to work with the new types, some function definitions
of~\cite{shelley_formal_spec} have to be adapted. In particular,
$\fun{witsNeeded}$ will use $\fun{txinsVKey}$ instead of the original
$\fun{txins}$ function. The function $\fun{consumed}$ is adapted as shown in
Figure~\ref{fig:functions:multi-sig-utxo}, restricting the domain of the $utxo$
to the union of the inputs of $\fun{txinsVKey}~tx$ and $\fun{txinsScript}~tx$.

\begin{figure}[htb]
  \begin{align*}
    & \fun{consumed} \in \PParams \to \UTxO \to \StakeKeys \to \Wdrl \to \Tx \to \Coin
    & \text{value consumed} \\
    & \consumed{pp}{utxo}{stkeys}{rewards}~{tx} = \\
    & ~~\ubalance{(\fun{txinsVKey}~{tx} \cup \dom (\fun{txinsScript}~{tx})\restrictdom \var{utxo})} +
      \fun{wbalance}~(\fun{txwdrls}~{tx}) \\
    & ~~~~ + \keyRefunds{pp}{stkeys}{tx} \\
  \end{align*}

  \caption{Functions used in UTxO rules}
  \label{fig:functions:multi-sig-utxo}
\end{figure}

\section{Summary}
\label{sec:summary}

The presented simple multi-signature scheme does not require the scripts to use
any cryptographic primitives. It requires only the ability to compare the
required keys to those that actually signed the transaction. Gas cost can
therefore be calculated statically in advance. The scripts could be realized as
smart contracts with only limited requirements on functionality on the script
language.

The necessary extensions to the data types in the Shelley
specification~\cite{shelley_formal_spec} are relatively simple. They consist
mainly of the introduction of additional optional data for scripts or hashed
scripts.

The relaxation on accepting a superset of the strictly required signatures
allows the creation of transactions with an arbitrary number of signatures. This
potentially is a risk for an attack. The number of signatures should be taken
into account in some way in the calculation of the transaction fee.

\addcontentsline{toc}{section}{References} \bibliographystyle{plainnat}
\bibliography{references}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
