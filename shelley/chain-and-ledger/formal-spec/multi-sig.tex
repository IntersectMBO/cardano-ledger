\documentclass[11pt,a4paper,dvipsnames]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{iohk}
\usepackage{microtype}
\usepackage{mathpazo} % nice fonts
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{extarrows}
\usepackage{slashed}
\usepackage[colon]{natbib}
\usepackage[unicode=true,pdftex,pdfa,colorlinks=true]{hyperref}
\usepackage{xcolor}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{enumerate}


%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
%% Setup for the semantic package
\setpremisesspace{20pt}

%%
%% Types
%%
\newcommand{\Nothing}{\ensuremath{\Diamond}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Bool}{\ensuremath{\mathbb{B}}}
\newcommand{\Tx}{\type{Tx}}
\newcommand{\TxWitness}{\type{TxWitness}}
\newcommand{\TxBody}{\type{TxBody}}
\newcommand{\Ix}{\type{Ix}}
\newcommand{\TxId}{\type{TxId}}
\newcommand{\Addr}{\type{Addr}}
\newcommand{\AddrVKey}{\type{Addr^{vkey}}}
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\Wdrl}{\type{Wdrl}}
\newcommand{\Coin}{\type{Coin}}
\newcommand{\PParams}{\type{PParams}}

\newcommand{\Slot}{\type{Slot}}
\newcommand{\SlotsPerEpoch}{\mathsf{SlotsPerEpoch}}
\newcommand{\SlotsPerKESPeriod}{\mathsf{SlotsPerKESPeriod}}
\newcommand{\Duration}{\type{Duration}}
\newcommand{\StakePools}{\type{StakePools}}
\newcommand{\StakeDelegs}{\type{StakeDelegs}}
\newcommand{\StakeObject}{\type{StakeCredential}}

\newcommand{\DCert}{\type{DCert}}
\newcommand{\DCertRegKey}{\type{DCert_{regkey}}}
\newcommand{\DCertDeRegKey}{\type{DCert_{deregkey}}}
\newcommand{\DCertDeleg}{\type{DCert_{delegate}}}
\newcommand{\DCertRegPool}{\type{DCert_{regpool}}}
\newcommand{\DCertRetirePool}{\type{DCert_{retirepool}}}
\newcommand{\PoolParam}{\type{PoolParam}}
\newcommand{\UTxOState}{\ensuremath{\type{UTxOState}}}
\newcommand{\ledgerState}{\ensuremath{\type{ledgerState}}}

\newcommand{\AddrRWD}{\type{Addr_{rwd}}}
\newcommand{\AddrRWDVKey}{\type{Addr_{rwd}^{vkey}}}
\newcommand{\AddrRWDScr}{\type{Addr_{rwd}^{script}}}
\newcommand{\AddrVKeyB}{\type{Addr^{vkey}_{base}}}
\newcommand{\AddrVKeyP}{\type{Addr^{vkey}_{ptr}}}
\newcommand{\AddrVKeyE}{\type{Addr^{vkey}_{enterprise}}}
\newcommand{\AddrVKeyBS}{\type{Addr^{vkey}_{bootstrap}}}
\newcommand{\AddrScr}{\type{Addr^{script}}}
\newcommand{\AddrScrBase}{\type{Addr_{base}^{script}}}
\newcommand{\AddrScrEnterprise}{\type{Addr_{enterprise}^{script}}}
\newcommand{\AddrScrPtr}{\type{Addr_{ptr}^{script}}}
\newcommand{\HashScr}{\type{ScriptHash}}

\newcommand{\Ptr}{\type{Ptr}}
\newcommand{\DState}{\type{DState}}
\newcommand{\DWEnv}{\type{DWEnv}}
\newcommand{\DPSEnv}{\type{DPSEnv}}
\newcommand{\DPEnv}{\type{DPEnv}}
\newcommand{\DEnv}{\type{DEnv}}
\newcommand{\PEnv}{\type{PEnv}}
\newcommand{\DPState}{\type{DPState}}
\newcommand{\PState}{\type{PState}}
\newcommand{\DCertBody}{\type{DCertBody}}
\newcommand{\TData}{\type{TData}}
\newcommand{\DPoolReap}{\ensuremath{\type{poolreap}}}
\newcommand{\UPIState}{\type{UPIState}}
\newcommand{\UpdatePayload}{\type{UpdatePayload}}

\newcommand{\Script}{\type{Script}}
\newcommand{\ScriptPlutus}{\Script_{plc}}
\newcommand{\ScriptMSig}{\Script_{msig}}
\newcommand{\PendingTx}{\type{PendingTx}}

%% Adding witnesses
\newcommand{\TxIn}{\type{TxIn}}

\newcommand{\TxOut}{\type{TxOut}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\VKeyEv}{\type{VKey_{ev}}}
\newcommand{\VKeyGen}{\type{VKey_G}}
\newcommand{\SKey}{\type{SKey}}
\newcommand{\SKeyEv}{\type{SKey_{ev}}}
\newcommand{\KeyHash}{\type{KeyHash}}
\newcommand{\KeyPair}{\type{KeyPair}}
\newcommand{\KeyPairEv}{\type{KeyPair_{ev}}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
%% Adding delegation
\newcommand{\Epoch}{\type{Epoch}}
\newcommand{\KESPeriod}{\type{KESPeriod}}
%% Blockchain
\newcommand{\Gkeys}{\var{G_{keys}}}
\newcommand{\Block}{\type{Block}}
\newcommand{\SlotId}{\type{SlotId}}
\newcommand{\UTxOEnv}{\type{UTxOEnv}}
\newcommand{\CEEnv}{\type{CEEnv}}
\newcommand{\CEState}{\type{CEState}}
\newcommand{\BDEnv}{\type{BDEnv}}
\newcommand{\BDState}{\type{BDState}}
\newcommand{\LEnv}{\type{LEnv}}
\newcommand{\LState}{\type{LState}}

%%
%% Functions
%%
\newcommand{\txins}[1]{\fun{txins}~ \var{#1}}
\newcommand{\txouts}[1]{\fun{txouts}~ \var{#1}}
\newcommand{\txcerts}[1]{\fun{txcerts}~ \var{#1}}
\newcommand{\txid}[1]{\fun{txid}~ \var{#1}}
\newcommand{\outs}[1]{\fun{outs}~ \var{#1}}
\newcommand{\values}[1]{\fun{values}~ #1}
\newcommand{\ubalance}[1]{\fun{ubalance}~ \var{#1}}
\newcommand{\txttl}[1]{\fun{txttl}~ \var{#1}}
\newcommand{\firstSlot}[1]{\fun{firstSlot}~ \var{#1}}
\newcommand{\deposits}[2]{\fun{deposits}~ \var{#1} ~ \var{#2}}
\newcommand{\decayedKey}[4]{\fun{decayedKey}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\decayedTx}[3]{\fun{decayedTx}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\keyRefund}[6]{\fun{keyRefund}~ {#1}~{#2}~{#3}~\var{#4}~\var{#5}~\var{#6}}
\newcommand{\refund}[4]{\fun{refund}~ \var{#1}~ \var{#2}~ {#3}~ {#4}}
\newcommand{\keyRefunds}[3]{\fun{keyRefunds}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\consumed}[4]{\fun{consumed}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\produced}[2]{\fun{produced}~ \var{#1}~ \var{#2}}
\newcommand{\applyFun}[2]{\fun{#1}~\var{#2}}

\newcommand{\RegKey}[1]{\textsc{RegKey}(#1)}
\newcommand{\DeregKey}[1]{\textsc{DeregKey}(#1)}
\newcommand{\Delegate}[1]{\textsc{Delegate}(#1)}
\newcommand{\RegPool}[1]{\textsc{RegPool}(#1)}
\newcommand{\RetirePool}[1]{\textsc{RetirePool}(#1)}
\newcommand{\cwitness}[1]{\fun{cwitness}~ \var{#1}}
\newcommand{\dpool}[1]{\fun{dpool}~ \var{#1}}
\newcommand{\poolParam}[1]{\fun{poolParam}~ \var{#1}}
\newcommand{\retire}[1]{\fun{retire}~ \var{#1}}
\newcommand{\addrRw}[1]{\fun{addr_{rwd}}~ \var{#1}}
\newcommand{\epoch}[1]{\fun{epoch}~\var{#1}}
\newcommand{\kesPeriod}[1]{\fun{kesPeriod}~\var{#1}}
\newcommand{\dcerts}[1]{\fun{dcerts}~ \var{#1}}
\newcommand{\pps}[1]{\fun{pps}~ \var{#1}}

%% UTxO witnesses
\newcommand{\inputs}[1]{\fun{inputs}~ \var{#1}}
\newcommand{\txwitsVKey}[1]{\fun{txwitsVKey}~\var{#1}}
\newcommand{\txwitsScript}[1]{\fun{txwitsScript}~\var{#1}}
\newcommand{\verify}[3]{\fun{verify} ~ #1 ~ #2 ~ #3}
\newcommand{\sign}[2]{\fun{sign} ~ #1 ~ #2}
\newcommand{\verifyEv}[4]{\fun{verify_{ev}} ~ #1 ~ #2 ~ #3 ~ #4}
\newcommand{\signEv}[3]{\fun{sign_{ev}} ~ #1 ~ #2 ~ #3}
\newcommand{\serialised}[1]{\llbracket \var{#1} \rrbracket}
\newcommand{\hashKey}[1]{\fun{hashKey}~ \var{#1}}
\newcommand{\txbody}[1]{\fun{txbody}~ \var{#1}}
\newcommand{\txfee}[1]{\fun{txfee}~ \var{#1}}
\newcommand{\txwdrls}[1]{\fun{txwdrls}~ \var{#1}}
\newcommand{\minfee}[2]{\fun{minfee}~ \var{#1}~ \var{#2}}
\newcommand{\slotminus}[2]{\var{#1}~-_{s}~\var{#2}}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
% wildcard parameter
\newcommand{\wcard}[0]{\underline{\phantom{a}}}
%% Adding ledgers...
\newcommand{\utxo}[1]{\fun{utxo}~ #1}
%% Delegation
\newcommand{\delegatesName}{\fun{delegates}}
\newcommand{\delegates}[3]{\delegatesName~#1~#2~#3}
\newcommand{\dwho}[1]{\fun{dwho}~\var{#1}}
\newcommand{\depoch}[1]{\fun{depoch}~\var{#1}}
\newcommand{\dval}{\ensuremath{d_{\mathsf{val}}}}
%% Delegation witnesses
\newcommand{\dbody}[1]{\fun{dbody}~\var{#1}}
\newcommand{\dwit}[1]{\fun{dwit}~\var{#1}}
%% Blockchain
\newcommand{\bwit}[1]{\fun{bwit}~\var{#1}}
\newcommand{\bslot}[1]{\fun{bslot}~\var{#1}}
\newcommand{\bbody}[1]{\fun{bbody}~\var{#1}}
\newcommand{\bhbody}[1]{\fun{bhbody}~\var{#1}}
\newcommand{\bdlgs}[1]{\fun{bdlgs}~\var{#1}}
%% ledgerstate constants
\newcommand{\genesisId}{\ensuremath{Genesis_{Id}}}
\newcommand{\genesisTxOut}{\ensuremath{Genesis_{Out}}}
\newcommand{\genesisUTxO}{\ensuremath{Genesis_{UTxO}}}
\newcommand{\emax}{\ensuremath{\mathsf{E_{\max}}}}

\newcommand{\unitInterval}{\ensuremath{[0,~1]}}
\newcommand{\unitIntervalNonNull}{\ensuremath{(0,~1]}}
\newcommand{\nonnegReals}{\ensuremath{[0,~\infty)}}
\newcommand{\posReals}{\ensuremath{(0,~\infty)}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{property}{Property}[section]

\newcommand{\leteq}{\ensuremath{\mathrel{\mathop:}=}}

\begin{document}

\hypersetup{
  pdftitle={A Formal Specification of a Multi-Signature Scheme using Scripts},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}

\title{A Formal Specification of a Multi-Signature Scheme using Scripts}

\author{Jared Corduan  \\ {\small \texttt{jared.corduan@iohk.io}} \\
   \and Matthias G\"udemann  \\ {\small \texttt{matthias.gudemann@iohk.io}}}

%\date{}

\maketitle

\begin{abstract}
  This documents specifies a way to support multi-signature transactions. It is
  based on a simple script model which uses only single step script execution
  and does not require data scripts. We provide two different ways to implement
  such a scheme on top of the Shelley formal ledger specification. One based on
  Plutus script, the other based on a simple script DSL for which a native
  interpreter can be used.

  A multi-signature scheme allows an unspent transaction output to be used as an
  input to a new transaction if a pre-defined combination of signatures is
  provided, e.g., two persons have to sign simultaneously, two out of three
  keys have to be provided, etc.

  For an output that is locked with a multi-signature, the set of all keys that
  signed the transaction is given to the script for validation. In this way, the
  script can decide in a single step whether is has the correct key combination
  to spend the output.
\end{abstract}

% \section*{List of Contributors}
% \label{acknowledgements}

% \tableofcontents
% \listoffigures

\section{Introduction}
\label{sec:introduction}

This specification for a simple multi-signature scheme is based
on~\cite{shelley_formal_spec} which formally specifies the Shelley Cardano
ledger. The main changes are the following:

\begin{itemize}
\item Add a new address type for outputs, stake and rewards locked by scripts.
\item Add a new witness type to the transaction.
\item Adapt the signature validation in such a way that funds locked by a
  multi-signature script can be spent and delegation certificates locked by
  multi-signature scripts can be used.
\item Adapt the functions used in the validation for the extended types of
  addresses, transaction inputs and delegation certificates with scripts.
\end{itemize}

In this approach for multi-signature, the scripts receive as input the set of
keys which were used to sign the transaction. The script can then check those
against its own representation of which keys in which combination can unlock the
unspent output.

This means that the scripts are completely stateless and no data needs to be
supplied to the script apart from the information about which keys and in which
combination can sign the transaction. It allows for any type of $n$ out of $m$
required signatures for a specific unspent transaction output.

\section{Types}
\label{sec:types}

\begin{figure*}[hbt]
  \emph{Abstract types}

  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      script & \Script & \ScriptPlutus\uniondistinct\ScriptMSig\uniondistinct\,\,\cdots  & \text{Representation of a script}
    \end{array}
  \end{equation*}

  \emph{Derived types}

  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{addr_{s}} & \AddrScr & \AddrScrBase \uniondistinct \AddrScrEnterprise
                              \uniondistinct \AddrScrPtr & \text{Script address} \\
      \var{addr_{vk}} & \AddrVKey & \begin{array}{l@{~\uniondistinct}l}
                             \AddrVKeyB & \AddrVKeyP \uniondistinct \AddrVKeyE \\
                                    & \AddrVKeyBS
                           \end{array}
                                & \text{Key address}\\
      \var{addr} & \Addr & \AddrScr \uniondistinct \AddrVKey \\
      \var{addr_{rwd}} & \AddrRWD & (\AddrRWDVKey \uniondistinct \AddrRWDScr)
                                                         & \text{Reward address}
    \end{array}
  \end{equation*}

  \emph{Accessor Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{paymentHK} & \AddrVKey \to \KeyHash_{pay}
      & \text{hash of payment key from addr}\\
      \fun{validatorHash} & \AddrScr \to \HashScr & \text{hash of validator
                                                    script} \\
      \fun{stakeCred_{b}} & (\AddrVKeyB \uniondistinct \AddrScrBase) \to
                          \StakeObject & \text{stake credential from base
                                      addr}\\
      \fun{stakeCred_{r}} & \AddrRWD \to \StakeObject & \text{stake credential
                                                   from reward addr}\\
      \fun{addrPtr} & (\AddrVKeyP \uniondistinct \AddrScrPtr) \to \Ptr &
                                                                         \text{pointer
                                                                         from
                                                                         pointer addr}
    \end{array}
  \end{equation*}

  \emph{Abstract Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{hashScript} & \Script \to \HashScr & \text{hash a serialized script}
    \end{array}
  \end{equation*}

  \caption{Types for Scripts and Script Addresses}
  \label{fig:types-scripts}
\end{figure*}

In Figure~\ref{fig:types-scripts} the $\Addr$ type of~\cite{shelley_formal_spec}
is changed to include both public key and script addresses, split into the
sub-types $\AddrVKey$ and $\AddrScr$. The new script addresses contain the hash
of the validator script. In accordance with the extended UTxO
specification~\cite{plutus_eutxo}, the producer signs the script when creating
and the consumer provides it later when spending the output. The type $\Script$
is partitioned into subtypes for each language, in this case for illustration:
Plutus scripts, $\ScriptPlutus$ and msig scripts $\ScriptMSig$ for the native
interpreter, see Sections~\ref{sec:plutus-scripts}
and~\ref{sec:native-script-interp} for details.

A transaction output that is locked by a script carries the hash of the
validator script. The output can only be spent if the matching script is
presented and validates its input. The $\AddrScr$
(Figure~\ref{fig:types-scripts}) sub-type of $\Addr$ carries the necessary
information and can therefore be part of a transaction output that consists of a
pair of $\Addr\times\Coin$. Analogously to $\AddrVKey$, $\AddrScr$ also has an
\emph{enterprise} script address sub-type which does not allow for using the
locked funds in staking, as well as \emph{base} and \emph{pointer} script
address sub-types. We will refer to the parts of an address used for payment as
\emph{payment object} and the part used for staking as \emph{staking
  reference}. Analogous to the payment object, the staking reference for an
$\AddrScr$ is also a script, i.e., staking can also require a combination of
signatures which can be different from the combination required for payment.

The $\fun{hashScript}$ function calculates the hash of the serialized
script. The accessor function $\fun{validatorHash}$ returns the hash of a script
of a script address. The domain of the accessor function $\fun{paymentHK}$ is
changed to pubkey addresses. The domains of the accessor functions
$\fun{stakeHK_b}$, $\fun{stakeHK_{r}}$ and $\fun{addrPtr}$ are extended to also
include the respective script address variants. The return types are adapted to
be a staking reference.

\begin{figure*}[hbt]
  \emph{Transaction Type}

  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{wit} & \TxWitness & (\VKey \mapsto \Sig, \HashScr \mapsto \Script)
      \\
      \var{tx}
      & \Tx
      & \TxBody \times \TxWitness
      \\
    \end{array}
  \end{equation*}

  \emph{Accessor Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{txwitsVKey} & \Tx \to (\VKey \mapsto \Sig) & \text{VKey witnesses} \\
      \fun{txwitsScripts} & \Tx \to (\HashScr \mapsto \Script) & \text{script witnesses}
    \end{array}
  \end{equation*}

  \emph{Abstract Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{validateScript} & \Script \to \Tx \to \Bool & \text{script interpreter}
    \end{array}
  \end{equation*}
  \caption{Types for Transaction Inputs with Scripts}
  \label{fig:types_defs_multi}
\end{figure*}

In Figure~\ref{fig:types_defs_multi} the type of a transaction
from~\cite{shelley_formal_spec} is extended to carry an additional witness
type. This is achieved by explicitly defining $\TxWitness$ as a type of the form
of a pair of pubkey witnesses and script witnesses. The former accessor function
$\fun{txwits}$ is renamed to $\fun{txwitsVKey}$. The new accessor function
$\fun{txwitsScript}$ returns a map of script hashes to validator scripts of a
transaction. All scripts in the map need to validate the transaction in order
for it to be accepted.

\begin{figure*}[htb]
  \emph{Helper Functions}
  %
  \begin{align*}
    \fun{txinsVKey} & \in \powerset \TxIn \to \UTxO \to \powerset\TxIn & \text{VKey Tx inputs}\\
    \fun{txinsVKey} & ~\var{txins}~\var{utxo} =
    \var{txins} \cap \dom (\var{utxo} \restrictrange (\AddrVKey \times Coin))
    \\
    \\
    \fun{txinsScript} & \in \powerset \TxIn \to \UTxO \to \powerset\TxIn & \text{Script Tx inputs}\\
    \fun{txinsScript} & ~\var{txins}~\var{utxo} =
                        \var{txins} \cap \dom (\var{utxo} \restrictrange (\AddrScr \times Coin))
  \end{align*}
  %
  \caption{Helper Functions for Transaction Inputs}
  \label{fig:defs:functions-txins}
\end{figure*}

Figure~\ref{fig:defs:functions-txins} shows the helper functions
$\fun{txinsVKey}$ and $\fun{txinsScript}$ which partition the set of transaction
inputs of the transaction into those that are locked with a private key and
those that are locked via a script.

\section{Ledger Transitions for Multi-Signature}
\label{sec:ledg-trans-multi}

While both spending values and changing delegation decisions can be locked by
multi-signature scripts, the checks for script validation of both cases can be
treated in the same way. The validation of all witnesses is done in the UTXOW
STS rule, using function \fun{witsVKeyNeeded} to collect all necessary key
signatures and the function \fun{scriptsNeeded} to collect all necessary
multi-signature scripts.

\subsection{Delegation Specific Changes}
\label{sec:deleg-trans-rules}

Multi-signature staking requires a change to the type of staking reference from
being just a hashed key to being either a hashed key or a hashed script. This is
reflected in the type of $\StakeDelegs$ with replaces the previous
$\type{StakeKeys}$ type and the type $\StakeObject$ which describes either a key
or a script used for staking, as shown in
Figure~\ref{fig:delegation-state-type}.

\begin{figure}
  \emph{Delegation Types}
    \begin{equation*}
      \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
        \var{stakeCred} & \StakeObject & (\KeyHash_{stake} \uniondistinct
                                            \HashScr) \\
        \var{stakeDelegator} & \StakeDelegs & \StakeObject \mapsto \Slot \\
      \end{array}
    \end{equation*}
    %
  \emph{Delegation States}
  %
  \begin{equation*}
    \begin{array}{l}
    \DState =
    \left(\begin{array}{r@{~\in~}lr}
      \var{stDelegs} & \StakeDelegs & \text{registered stake delegators}\\
      \var{rewards} & \AddrRWD \mapsto \Coin & \text{rewards}\\
      \var{delegations} & \StakeObject \mapsto \KeyHash_{pool} & \text{delegations}\\
      \var{ptrs} & \Ptr \mapsto \StakeObject & \text{pointer to staking reference}\\
      \var{fdms} & (\Slot\times\VKeyGen) \mapsto \VKey & \text{future genesis key delegations}\\
      \var{dms} & \VKeyGen \mapsto \VKey & \text{genesis key delegations}\\
          \end{array}\right)
    \end{array}
  \end{equation*}
  %
  \emph{Certificate Accessor functions}
  %
  \begin{equation*}
  \begin{array}{r@{~\in~}lr}
    \cwitness{} & \DCert \to \StakeDelegs & \text{certificate witness}
  \end{array}
  \end{equation*}
  \caption{Delegation State type}
  \label{fig:delegation-state-type}
\end{figure}

\textbf{Note:} In contrast to staking reference delegation, staking pools
themselves cannot use multi-signature schemes. Else, the lightweight
certificates for delegation from the pool to the KES hot key would have to be
script witnesses. These certificates have to be included in each header, but
those headers are required to have a fixed size and be as small as possible.

\subsection{UTXOW Transition Rule}
\label{sec:utxow-transition}

The UTXOW extended transition system is shown in
Figure~\ref{fig:rules:utxow-multi-sig}. The constraint on the set of required
witnesses is relaxed in such a way that \emph{redundant} signatures can be
supplied in the transaction. The set of verification keys is passed to the
validator script via the concrete implementation of $\fun{validateScript}$ for
the specific script type.

The set of all validator scripts of $\fun{txinsScript}~(\fun{txins}~tx)$ is
checked for:

\begin{itemize}
\item the hashed script being equal to the hash stored in the output to spent,
  and
\item the validator script validating the transaction, and
\item being equal to the set of the scripts required for the transaction (as
  returned from $\fun{scriptsNeeded}$).
\end{itemize}

We also check that the set of spent outputs locked by a script is equal to the
elements of the inputs for which we have a validator script. This ensures that
for each script-locked output there exists a corresponding validation script.

\begin{figure}[htb]
  \begin{equation*}
    \inference[UTxO-wit]
    {
      (utxo, \wcard, \wcard) \leteq \var{utxoSt}\\
      \\~\\
      \forall \var{hs} \mapsto \var{validator} \in \fun{txwitsScript}~{tx},\\
      \fun{hashScript}~\var{validator} = \var{hs} \wedge
      \fun{validateScript}~\var{validator}~\var{tx}\\~\\
      \fun{scriptsNeeded}~\var{utxo}~\var{tx} = \dom (\fun{txwitsScript}~{tx})
      \\~\\
      \forall \var{vk} \mapsto \sigma \in \txwitsVKey{tx},
      \mathcal{V}_{\var{vk}}{\serialised{\txbody{tx}}}_{\sigma} \\
      \fun{witsVKeyNeeded}~{utxo}~{tx} \subseteq \{ \hashKey \var{vk} \mid \var{vk}\in\dom{(\txwitsVKey{tx})} \}\\~\\
      {
        \begin{array}{l}
        \var{utxoEnv}
        \end{array}
      }
      \vdash \var{utxoSt} \trans{utxo}{tx} \var{utxoSt'}\\
    }
    {
      \begin{array}{l}
        \var{utxoEnv}
      \end{array}
      \vdash \var{utxoSt} \trans{utxow}{tx} \varUpdate{\var{utxoSt'}}
    }
  \end{equation*}
  \caption{UTxO with Witnesses and Multi-Sig}
  \label{fig:rules:utxow-multi-sig}
\end{figure}

Multi-signature staking also incurs reward accounts locked by a multi-signature
scheme. This means that in order to allow for spending of rewards accumulated in
a multi-signature rewards account, we also need to validate the required
script. This is done in a predicate in the UTXOW rule which checks that for each
withdrawal of a transaction which uses a multi-script rewards account, there
exists a corresponding script matching the hash in the reward address and which
validates the transaction. Because of the changes to the staking reference type,
the original function $\fun{witsNeeded}$ is changed as shown in
Figure~\ref{fig:functions-witnesses}. It also shows the function
$\fun{scriptNeeded}$ which computes the requires script hashes from the set of
spent inputs locked by scripts and consumed withdrawals locked by scripts.

\begin{figure}[htb]
  \begin{align*}
    & \hspace{-1cm}\fun{witsVKeyNeeded} \in \UTxO \to \Tx \to (\VKeyGen\mapsto\VKey) \to
      \powerset{\KeyHash}
    & \text{required keyhashes} \\
    &  \hspace{-1cm}\fun{witsVKeyNeeded}~\var{utxo}~\var{tx}~\var{dms} = \\
    & ~~\{ \fun{paymentHK}~a \mid i \mapsto (a, \wcard) \in \var{utxo},~i\in\txins{tx} \} \\
    \cup & ~~\{\fun{stakeCred_r}~a \mid a\mapsto \wcard \in \AddrRWDVKey
      \restrictdom \txwdrls{tx}\} \\
    \cup & ~~\{\cwitness{c} \mid c \in \txcerts{tx}\}~\cup \\
    \cup & ~~\fun{propWits}~(\fun{txup}~\var{tx}) \\
    \cup & ~~\bigcup_{\substack{c \in \txcerts{tx} \\ ~c \in\DCertRegPool}} \fun{poolOwners}~{c}
  \end{align*}
  \begin{align*}
    & \hspace{-1.5cm}\fun{scriptsNeeded} \in \UTxO \to \Tx \to
      \powerset{\HashScr}
    & \text{required script hashes} \\
    &  \hspace{-1.5cm}\fun{scriptsNeeded}~\var{utxo}~\var{tx} = \\
    & ~~\{ \fun{validatorHash}~a \mid i \mapsto (a, \wcard) \in \var{utxo},\\
    & ~~~~~i\in\fun{txinsScript}~{(\fun{txins~\var{tx}})}~{utxo}\} \\
    \cup & ~~\{ \fun{stakeCred_{r}}~\var{a} \mid a \in \dom (\AddrRWDScr
           \restrictdom \fun{txwdrls}~\var{tx}) \} \\
    \cup & ~~\{\AddrScr \cap \fun{cwitness}~\var{c} \mid c \in \fun{txcerts}~\var{tx}\}
  \end{align*}
  \caption{Required Witnesses}
  \label{fig:functions-witnesses}
\end{figure}

\section{Implementation of Script-Based Multi-Signature}
\label{sec:altern-impl}

There are different implementation possibilities for the introduced
multi-signature scheme. Section~\ref{sec:plutus-scripts} describes an
implementation based on Plutus~\cite{plutus_eutxo} which uses only simple
scripts, without redeemer or data
scripts. Section~\ref{sec:native-script-interp} describes an alternative
implementation based on a script-like DSL that allows for validation using a
native implementation.

\subsection{Plutus Scripts}
\label{sec:plutus-scripts}

\begin{figure*}[hbt]
  \emph{Abstract Type}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      pendingTx & \PendingTx & \text{information about pending Tx}
    \end{array}
  \end{equation*}

  \emph{Abstract Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{validateScript} & \ScriptPlutus \to \Tx \to \Bool & \text{Plutus script
                                                               interpreter} \\
      \fun{validate} & () \to () \to \PendingTx \to \Bool & \text{Plutus
                                                            validator script type}
    \end{array}
  \end{equation*}
  \caption{Implementation based on Plutus Scripts}
  \label{fig:types_defs_plutus}
\end{figure*}

$\PendingTx$ is a representation of the pending transaction. In particular, this
information contains the set of keys that signed the transaction. The function
$\fun{txPending}$ constructs the necessary information about a transaction
which can be passed as value of type $\PendingTx$ to the validator script.

In order to spend funds locked by a multi-signature script, the validator
scripts need to validate the transaction. The abstract function $\fun{validate}$
corresponds to such a Plutus validator script. Its type consists of two
parameters of unit type and one parameter of type $\PendingTx$; its return type
is Boolean. The first two input parameters correspond to the redeemer and the
data scripts which are used in the full extended UTxO model for
Plutus~\cite{plutus_eutxo}. As those values are not required for simple
multi-signature, we the unit type for them. The Boolean return type signals
whether the script succeeded in validating the transaction. The function
$\fun{validateScript}$ specialized for $\ScriptPlutus$ takes a Plutus script
representation and a $\PendingTx$ value, and evaluates the script using the
Plutus interpreter.

The following is a possible Plutus implementation of a simple $m$ out of $n$
multi-signature validation script. The type $\type{MultiSig}$ is a list of keys
and a threshold value.

\begin{verbatim}
import qualified Language.PlutusTx            as P
import           Ledger.Validation            as V

data MultiSig = MultiSig
                { signatories :: [Ledger.PubKey]
                -- ^ List of public keys of people who may sign the transaction
                , requiredSignatures :: Integer
                -- ^ Minimum number of signatures required to unlock
                --   the output (should not exceed @length signatories@)
                }

validate :: MultiSig -> () -> () -> PendingTx -> Bool
validate multiSig@(MultiSig keys num) () () p =
    let present = P.length (P.filter (V.txSignedBy p) keys)
    in present `P.geq` num
\end{verbatim}

The above Plutus script takes a parameter \var{multiSig} of type
$\type{MultiSig}$ which is a list of keys $\var{keys}$ and a threshold $num$
which indicates how many of the keys are required as signatures. When the
validation script is called, it computes the list of keys in $keys$ which signed
the transaction. If the length of that list is greater than or equal to $num$,
then enough signatures for the multi-signature are present. Therefore, with
\var{hkeys} being a value of type \type{MultiSig}, partially application of
$\fun{validate}~multisig$ will return a validator script with the correct type
according to Figure~\ref{fig:types_defs_plutus}.

\subsection{Native Script Interpreter}
\label{sec:native-script-interp}

\begin{figure*}[hbt]
  \emph{MultiSig Type}

  \begin{equation*}
    \begin{array}{rll}
      \var{msig} & \in & \type{RequireSig}~\KeyHash\\
      & \uniondistinct &
         \type{RequireAllOf}~[\ScriptMSig] \\
      & \uniondistinct&
         \type{RequireAnyOf}~[\ScriptMSig] \\
      & \uniondistinct&
        \type{RequireMOf}~\N~[\ScriptMSig]
    \end{array}
  \end{equation*}

  \emph{Functions}

  \begin{align*}
    \fun{validateScript} & \in\ScriptMSig\to\Tx\to\Bool & \text{validate native
                                                          script} \\
    \fun{validateScript} & ~\var{msig}~\var{tx}= \\
                         & \textrm{let}~\var{vhks}\leteq \{\fun{hashKey}~vk \vert
                           vk \in \fun{txwitsVKey}~\var{tx}\} \\
                         & \fun{evalMultiSigScript}~msig~vhks\\
  \end{align*}
  \begin{align*}
    \fun{evalMultiSigScript} & \in\ScriptMSig\to\powerset\KeyHash\to\Bool & \\
    \fun{evalMultiSigScript} & ~(\type{RequireSig}~hk)~\var{vhks} =  hk \in vhks \\
    \fun{evalMultiSigScript} & ~(\type{RequireAllOf}~ts)~\var{vhks} =
                              \forall t \in ts: \fun{evalMultiSigScript}~t~vhks\\
    \fun{evalMultiSigScript} & ~(\type{RequireAnyOf}~ts)~\var{vhks} =
                              \exists t \in ts: \fun{evalMultiSigScript}~t~vhks\\
    \fun{evalMultiSigScript} & ~(\type{RequireMOf}~m~ts)~\var{vhks} = \\
                             & m \leq \Sigma
                               \left(
                               [\textrm{if}~(\fun{evalMultiSigScript}~\var{t}~\var{vhks})~
                               \textrm{then}~1~\textrm{else}~0\vert t \leftarrow ts]
                               \right)
  \end{align*}

  \caption{Implementation based on Native Scripts}
  \label{fig:types-msig}
\end{figure*}

An alternative implementation for multi-signature scripts is an embedding of the
script as data type which can then be interpreted
natively. Figure~\ref{fig:types-msig} shows the types and necessary functions
for such a native script implementation. The type $\ScriptMSig$ is defined as a
tree-structure which is either a single signature leaf node or a list of values
of type $\ScriptMSig$, which either requires all signatures to validate, at
least one of the signatures to validate or at least the threshold value of $m$
signatures to validate.

\subsection{Lower Level Implementation Details}
\label{sec:lower-level-impl}

For each new type of witness, there will be a requirement to represent such a
witness on-chain and allow for identification when deserializing such a
witness. For this, there will be a language specific tag for each witness (and
staking reference) in its serialized form. This tag will also be part of the
hash to allow for easy identification of the language type.

As an example, one could tag key hash payment object and staking reference with
a tag $0$, for native multi-sig with tag $1$ and simple Plutus scripts with tag
$2$. Every new language would incur using a new tag, changes to the details of
how payment or staking references are treated \emph{within} an existing language
framework will be changed via a software update, not an additional tag.

\section{Summary}
\label{sec:summary}

The presented script based multi-signature scheme does not require the scripts
to use any cryptographic primitives. It requires only the ability to compare the
required keys to those that actually signed the transaction. The worst case
potential calculation cost can therefore be calculated statically in advance and
can be added to the transaction fees or as gas cost. The scripts can be realized
with only limited requirements on functionality on the script language.

The necessary extensions to the data types in the Shelley
specification~\cite{shelley_formal_spec} are relatively simple. They consist
mainly of the introduction of additional optional data for payment objects or
staking references.

The relaxation on accepting a superset of the strictly required signatures
allows the creation of transactions with an arbitrary number of signatures. This
potentially is a risk for an attack. The number of signatures should be taken
into account in some way in the calculation of the transaction fee.

There are two proposed implementation schemes, one based on Plutus, the other on
a script-like integration as DSL for a native interpreter. Both follow the same
strategy for integration: extending addresses, defining witnesses and
specializing the script validation function. If the Plutus approach is not
viable for any reason, e.g., script size or readiness of library, only the
native script implementation could be pursued instead.

\addcontentsline{toc}{section}{References} \bibliographystyle{plainnat}
\bibliography{references}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
