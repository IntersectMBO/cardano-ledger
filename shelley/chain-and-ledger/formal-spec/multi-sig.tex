\documentclass[11pt,a4paper,dvipsnames]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{iohk}
\usepackage{microtype}
\usepackage{mathpazo} % nice fonts
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{extarrows}
\usepackage{slashed}
\usepackage[colon]{natbib}
\usepackage[unicode=true,pdftex,pdfa,colorlinks=true]{hyperref}
\usepackage{xcolor}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{enumerate}


%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
%% Setup for the semantic package
\setpremisesspace{20pt}

%%
%% Types
%%
\newcommand{\Nothing}{\ensuremath{\Diamond}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Bool}{\ensuremath{\mathbb{B}}}
\newcommand{\Tx}{\type{Tx}}
\newcommand{\TxWitness}{\type{TxWitness}}
\newcommand{\TxBody}{\type{TxBody}}
\newcommand{\Ix}{\type{Ix}}
\newcommand{\TxId}{\type{TxId}}
\newcommand{\Addr}{\type{Addr}}
\newcommand{\AddrVKey}{\type{Addr^{vkey}}}
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\Wdrl}{\type{Wdrl}}
\newcommand{\Coin}{\type{Coin}}
\newcommand{\PParams}{\type{PParams}}

\newcommand{\Slot}{\type{Slot}}
\newcommand{\SlotsPerEpoch}{\mathsf{SlotsPerEpoch}}
\newcommand{\SlotsPerKESPeriod}{\mathsf{SlotsPerKESPeriod}}
\newcommand{\Duration}{\type{Duration}}
\newcommand{\StakePools}{\type{StakePools}}
\newcommand{\StakeKeys}{\type{StakeKeys}}

\newcommand{\DCert}{\type{DCert}}
\newcommand{\DCertRegKey}{\type{DCert_{regkey}}}
\newcommand{\DCertDeRegKey}{\type{DCert_{deregkey}}}
\newcommand{\DCertDeleg}{\type{DCert_{delegate}}}
\newcommand{\DCertRegPool}{\type{DCert_{regpool}}}
\newcommand{\DCertRetirePool}{\type{DCert_{retirepool}}}
\newcommand{\PoolParam}{\type{PoolParam}}
\newcommand{\UTxOState}{\ensuremath{\type{UTxOState}}}
\newcommand{\ledgerState}{\ensuremath{\type{ledgerState}}}

\newcommand{\AddrRWD}{\type{Addr_{rwd}}}
\newcommand{\AddrVKeyB}{\type{Addr^{vkey}_{base}}}
\newcommand{\AddrVKeyP}{\type{Addr^{vkey}_{ptr}}}
\newcommand{\AddrVKeyE}{\type{Addr^{vkey}_{enterprise}}}
\newcommand{\AddrVKeyBS}{\type{Addr^{vkey}_{bootstrap}}}
\newcommand{\AddrScr}{\type{Addr^{script}}}
\newcommand{\AddrScrBase}{\type{Addr_{base}^{script}}}
\newcommand{\AddrScrEnterprise}{\type{Addr_{enterprise}^{script}}}
\newcommand{\AddrScrPtr}{\type{Addr_{ptr}^{script}}}
\newcommand{\HashScr}{\type{Hash_{script}}}

\newcommand{\Ptr}{\type{Ptr}}
\newcommand{\DState}{\type{DState}}
\newcommand{\DWEnv}{\type{DWEnv}}
\newcommand{\DPSEnv}{\type{DPSEnv}}
\newcommand{\DPEnv}{\type{DPEnv}}
\newcommand{\DEnv}{\type{DEnv}}
\newcommand{\PEnv}{\type{PEnv}}
\newcommand{\DPState}{\type{DPState}}
\newcommand{\PState}{\type{PState}}
\newcommand{\DCertBody}{\type{DCertBody}}
\newcommand{\TData}{\type{TData}}
\newcommand{\DPoolReap}{\ensuremath{\type{poolreap}}}
\newcommand{\UPIState}{\type{UPIState}}
\newcommand{\UpdatePayload}{\type{UpdatePayload}}

\newcommand{\Script}{\type{Script}}
\newcommand{\ScriptPlutus}{\Script_{plc}}
\newcommand{\ScriptMSig}{\Script_{msig}}
\newcommand{\PendingTx}{\type{PendingTx}}

%% Adding witnesses
\newcommand{\TxIn}{\type{TxIn}}

\newcommand{\TxOut}{\type{TxOut}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\VKeyEv}{\type{VKey_{ev}}}
\newcommand{\VKeyGen}{\type{VKey_G}}
\newcommand{\SKey}{\type{SKey}}
\newcommand{\SKeyEv}{\type{SKey_{ev}}}
\newcommand{\HashKey}{\type{HashKey}}
\newcommand{\KeyPair}{\type{KeyPair}}
\newcommand{\KeyPairEv}{\type{KeyPair_{ev}}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
%% Adding delegation
\newcommand{\Epoch}{\type{Epoch}}
\newcommand{\KESPeriod}{\type{KESPeriod}}
%% Blockchain
\newcommand{\Gkeys}{\var{G_{keys}}}
\newcommand{\Block}{\type{Block}}
\newcommand{\SlotId}{\type{SlotId}}
\newcommand{\UTxOEnv}{\type{UTxOEnv}}
\newcommand{\CEEnv}{\type{CEEnv}}
\newcommand{\CEState}{\type{CEState}}
\newcommand{\BDEnv}{\type{BDEnv}}
\newcommand{\BDState}{\type{BDState}}
\newcommand{\LEnv}{\type{LEnv}}
\newcommand{\LState}{\type{LState}}

%%
%% Functions
%%
\newcommand{\txins}[1]{\fun{txins}~ \var{#1}}
\newcommand{\txouts}[1]{\fun{txouts}~ \var{#1}}
\newcommand{\txcerts}[1]{\fun{txcerts}~ \var{#1}}
\newcommand{\txid}[1]{\fun{txid}~ \var{#1}}
\newcommand{\outs}[1]{\fun{outs}~ \var{#1}}
\newcommand{\values}[1]{\fun{values}~ #1}
\newcommand{\ubalance}[1]{\fun{ubalance}~ \var{#1}}
\newcommand{\txttl}[1]{\fun{txttl}~ \var{#1}}
\newcommand{\firstSlot}[1]{\fun{firstSlot}~ \var{#1}}
\newcommand{\deposits}[2]{\fun{deposits}~ \var{#1} ~ \var{#2}}
\newcommand{\decayedKey}[4]{\fun{decayedKey}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\decayedTx}[3]{\fun{decayedTx}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\keyRefund}[6]{\fun{keyRefund}~ {#1}~{#2}~{#3}~\var{#4}~\var{#5}~\var{#6}}
\newcommand{\refund}[4]{\fun{refund}~ \var{#1}~ \var{#2}~ {#3}~ {#4}}
\newcommand{\keyRefunds}[3]{\fun{keyRefunds}~ \var{#1}~ \var{#2}~ \var{#3}}
\newcommand{\consumed}[4]{\fun{consumed}~ \var{#1}~ \var{#2}~ \var{#3}~ \var{#4}}
\newcommand{\produced}[2]{\fun{produced}~ \var{#1}~ \var{#2}}
\newcommand{\applyFun}[2]{\fun{#1}~\var{#2}}

\newcommand{\RegKey}[1]{\textsc{RegKey}(#1)}
\newcommand{\DeregKey}[1]{\textsc{DeregKey}(#1)}
\newcommand{\Delegate}[1]{\textsc{Delegate}(#1)}
\newcommand{\RegPool}[1]{\textsc{RegPool}(#1)}
\newcommand{\RetirePool}[1]{\textsc{RetirePool}(#1)}
\newcommand{\cwitness}[1]{\fun{cwitness}~ \var{#1}}
\newcommand{\dpool}[1]{\fun{dpool}~ \var{#1}}
\newcommand{\poolParam}[1]{\fun{poolParam}~ \var{#1}}
\newcommand{\retire}[1]{\fun{retire}~ \var{#1}}
\newcommand{\addrRw}[1]{\fun{addr_{rwd}}~ \var{#1}}
\newcommand{\epoch}[1]{\fun{epoch}~\var{#1}}
\newcommand{\kesPeriod}[1]{\fun{kesPeriod}~\var{#1}}
\newcommand{\dcerts}[1]{\fun{dcerts}~ \var{#1}}
\newcommand{\pps}[1]{\fun{pps}~ \var{#1}}

%% UTxO witnesses
\newcommand{\inputs}[1]{\fun{inputs}~ \var{#1}}
\newcommand{\txwitsVKey}[1]{\fun{txwitsVKey}~\var{#1}}
\newcommand{\txwitsScript}[1]{\fun{txwitsScript}~\var{#1}}
\newcommand{\verify}[3]{\fun{verify} ~ #1 ~ #2 ~ #3}
\newcommand{\sign}[2]{\fun{sign} ~ #1 ~ #2}
\newcommand{\verifyEv}[4]{\fun{verify_{ev}} ~ #1 ~ #2 ~ #3 ~ #4}
\newcommand{\signEv}[3]{\fun{sign_{ev}} ~ #1 ~ #2 ~ #3}
\newcommand{\serialised}[1]{\llbracket \var{#1} \rrbracket}
\newcommand{\hashKey}[1]{\fun{hashKey}~ \var{#1}}
\newcommand{\txbody}[1]{\fun{txbody}~ \var{#1}}
\newcommand{\txfee}[1]{\fun{txfee}~ \var{#1}}
\newcommand{\txwdrls}[1]{\fun{txwdrls}~ \var{#1}}
\newcommand{\minfee}[2]{\fun{minfee}~ \var{#1}~ \var{#2}}
\newcommand{\slotminus}[2]{\var{#1}~-_{s}~\var{#2}}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
% wildcard parameter
\newcommand{\wcard}[0]{\underline{\phantom{a}}}
%% Adding ledgers...
\newcommand{\utxo}[1]{\fun{utxo}~ #1}
%% Delegation
\newcommand{\delegatesName}{\fun{delegates}}
\newcommand{\delegates}[3]{\delegatesName~#1~#2~#3}
\newcommand{\dwho}[1]{\fun{dwho}~\var{#1}}
\newcommand{\depoch}[1]{\fun{depoch}~\var{#1}}
\newcommand{\dval}{\ensuremath{d_{\mathsf{val}}}}
%% Delegation witnesses
\newcommand{\dbody}[1]{\fun{dbody}~\var{#1}}
\newcommand{\dwit}[1]{\fun{dwit}~\var{#1}}
%% Blockchain
\newcommand{\bwit}[1]{\fun{bwit}~\var{#1}}
\newcommand{\bslot}[1]{\fun{bslot}~\var{#1}}
\newcommand{\bbody}[1]{\fun{bbody}~\var{#1}}
\newcommand{\bhbody}[1]{\fun{bhbody}~\var{#1}}
\newcommand{\bdlgs}[1]{\fun{bdlgs}~\var{#1}}
%% ledgerstate constants
\newcommand{\genesisId}{\ensuremath{Genesis_{Id}}}
\newcommand{\genesisTxOut}{\ensuremath{Genesis_{Out}}}
\newcommand{\genesisUTxO}{\ensuremath{Genesis_{UTxO}}}
\newcommand{\emax}{\ensuremath{\mathsf{E_{max}}}}

\newcommand{\unitInterval}{\ensuremath{[0,~1]}}
\newcommand{\unitIntervalNonNull}{\ensuremath{(0,~1]}}
\newcommand{\nonnegReals}{\ensuremath{[0,~\infty)}}
\newcommand{\posReals}{\ensuremath{(0,~\infty)}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{property}{Property}[section]

\newcommand{\leteq}{\ensuremath{\mathrel{\mathop:}=}}

\begin{document}

\hypersetup{
  pdftitle={A Formal Specification of a Multi-Signature Scheme using Scripts},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}

\title{A Formal Specification of a Multi-Signature Scheme using Scripts}

\author{Jared Corduan  \\ {\small \texttt{jared.corduan@iohk.io}} \\
   \and Matthias G\"udemann  \\ {\small \texttt{matthias.gudemann@iohk.io}}}

%\date{}

\maketitle

\begin{abstract}
  This documents specifies a way to support multi-signature transactions. It is
  based on a simple script model which uses only single step script execution
  and does not require data scripts. We provide two different ways to implement
  such a scheme on top of the Shelley formal ledger specification. One based on
  Plutus script, the other based on a simple script language for which a native
  interpreter can be used.

  A multi-signature scheme allows an unspent transaction output to be used as an
  input to a new transaction if a pre-defined combination of signatures is
  provided, e.g., two persons have to sign simultaneously, two out of three
  keys have to be provided, etc.

  For an output that is locked with a multi-signature, the set of all keys that
  signed the transaction is given to the script for validation. In this way, the
  script can decide in a single step whether is has the correct key combination
  to spend the output.
\end{abstract}

% \section*{List of Contributors}
% \label{acknowledgements}

% \tableofcontents
% \listoffigures

\section{Introduction}
\label{sec:introduction}

This specification for a simple multi-signature scheme is based
on~\cite{shelley_formal_spec} which formally specifies the Shelley Cardano
ledger. The main changes are the following:

\begin{itemize}
\item Add a new address type that for outputs locked by scripts.
\item Add a new witness type to the transaction.
\item Adapt the transaction validation in such a way that funds locked by a
  multi-signature script can be spent.
\item Adapt the functions used in the validation for the extended types of
  addresses and transaction inputs with scripts.
\end{itemize}

In this approach for multi-signature, the scripts receive the set of keys which
were used to sign the transaction. The script can then check those against its
own representation of which keys in which combination can unlock the unspent
output.

This means that the scripts are completely stateless and no data needs to be
supplied to the script apart from the information about which keys and in which
combination can sign the transaction. It allows for any type of $n$ out of $m$
required signatures for a specific unspent transaction output.

\section{Types}
\label{sec:types}

\begin{figure*}[hbt]
  \emph{Abstract types}

  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      script & \Script & \ScriptPlutus\uniondistinct\ScriptMSig  & \text{Representation of a script}
    \end{array}
  \end{equation*}

  \emph{Derived types}

  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{addr_{s}} & \AddrScr & \AddrScrBase \uniondistinct \AddrScrEnterprise
                              \uniondistinct \AddrScrPtr & \text{Script address} \\
      \var{addr_{vk}} & \AddrVKey & \begin{array}{l@{~\uniondistinct}l}
                             \AddrVKeyB & \AddrVKeyP \uniondistinct \AddrVKeyE \\
                                    & \AddrVKeyBS
                           \end{array}
                                & \text{VKey address}\\
      \var{addr} & \Addr & \AddrScr \uniondistinct \AddrVKey
    \end{array}
  \end{equation*}

  \emph{Accessor Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{paymentHK} & \AddrVKey \to \HashKey_{pay}
      & \text{hash of payment key from addr}\\
      \fun{validatorHash} & \AddrScr \to \HashScr & \text{hash of validator
                                                     script} \\
      \fun{stakeHK_{b}} & (\AddrVKeyB \uniondistinct \AddrScrBase) \to
                          \HashKey_{stake} & \text{hash of stake key for base
                                             addresses}\\
      \fun{addrPtr} & (\AddrVKeyP \uniondistinct \AddrScrPtr) \to \Ptr &
                                                                     \text{pointer
                                                                     from
                                                                     pointer addresses}
    \end{array}
  \end{equation*}

  \emph{Abstract Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{hashScript} & \Script \to \HashScr & \text{hash a serialized script}
    \end{array}
  \end{equation*}

  \caption{Types for Scripts and Script Addresses}
  \label{fig:types-scripts}
\end{figure*}

In Figure~\ref{fig:types-scripts} the $\Addr$ type of~\cite{shelley_formal_spec}
is changed to include both public key and script addresses, split into the
sub-types $\AddrVKey$ and $\AddrScr$. The new script addresses contain the hash
of the validator script. In accordance with the extended UTxO
specification~\cite{plutus_eutxo}, the producer signs the script when creating
and the consumer provides it later when spending the output. The type $\Script$
is partitioned into Plutus scripts, $\ScriptPlutus$ and msig scripts
$\ScriptMSig$ for the native interpreter, see Sections~\ref{sec:plutus-scripts}
and~\ref{sec:native-script-interp} for details.

A transaction output that is locked by a script carries the hash of the
validator script. The output can only be spent if the matching script is
presented and validates its input. The $\AddrScr$
(Figure~\ref{fig:types-scripts}) sub-type of $\Addr$ carries the necessary
information and can therefore be part of a transaction output that consists of a
pair of $\Addr\times\Coin$. Analogously to $\AddrVKey$, $\AddrScr$ also has an
\emph{enterprise} script address sub-type which does not allow for using the
locked funds in staking, as well as \emph{base} and \emph{pointer} script
address sub-types which allow for staking in the same way as $\AddrVKeyB$ and
$\AddrVKeyP$.

The $\fun{hashScript}$ function calculates the hash of a script by serializing
and then hashing it. The accessor function $\fun{validatorHash}$ returns the
hash of a script of a script address. The domain of the accessor function
$\fun{paymentHK}$ is changed to pubkey addresses. The domains of the accessor
functions $\fun{stakeHK_b}$ and $\fun{addrPtr}$ are extended to also include the
respective script address variants.

\begin{figure*}[hbt]
  \emph{Transaction Type}

  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{wit} & \TxWitness & (\VKey \mapsto \Sig, \HashScr \mapsto \Script)
      \\
      \var{tx}
      & \Tx
      & \TxBody \times \TxWitness \times \UpdatePayload
      \\
    \end{array}
  \end{equation*}

  \emph{Accessor Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{txwitsVKey} & \Tx \to (\VKey \mapsto \Sig) & \text{VKey witnesses} \\
      \fun{txwitsScripts} & \Tx \to (\HashScr \mapsto \Script) & \text{script witnesses}
    \end{array}
  \end{equation*}

  \emph{Abstract Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{validateScript} & \Script \to \Tx \to \Bool & \text{script interpreter}
    \end{array}
  \end{equation*}
  \caption{Types for Transaction Inputs with Scripts}
  \label{fig:types_defs_multi}
\end{figure*}

In Figure~\ref{fig:types_defs_multi} the type of a transaction
from~\cite{shelley_formal_spec} is extended to carry an additional witness
type. This is achieved by explicitly defining $\TxWitness$ as a type of the form
of a pair of pubkey witnesses and script witnesses. The former accessor function
$\fun{txwits}$ is renamed to $\fun{txwitsVKey}$. The new accessor function
$\fun{txwitsScript}$ returns a map of script hashes to validator scripts of a
transaction. All scripts in the map need to validate the transaction in order
for it to be accepted.

\begin{figure*}[htb]
  \emph{Helper Functions}
  %
  \begin{align*}
    \fun{txinsVKey} & \in \powerset \TxIn \to \UTxO \to \powerset\TxIn & \text{VKey Tx inputs}\\
    \fun{txinsVKey} & ~\var{txins}~\var{utxo} =
    \var{txins} \cap \dom (\var{utxo} \restrictrange (\AddrVKey \times Coin))
    \\
    \\
    \fun{txinsScript} & \in \powerset \TxIn \to \UTxO \to \powerset\TxIn & \text{Script Tx inputs}\\
    \fun{txinsScript} & ~\var{txins}~\var{utxo} =
                        \var{txins} \cap \dom (\var{utxo} \restrictrange (\AddrScr \times Coin))
    \\
    \\
    \fun{validators} & \in \powerset\TxIn \to \UTxO \to (\HashScr\mapsto\Script) \to
                       (\TxIn \mapsto \Script) \\
    \fun{validators} &~\var{txins}~\var{utxo}~\var{scripts} = \\
                       & \{
                         i\mapsto s \vert
                         i\mapsto (a,\wcard) \in \var{txins}\restrictdom(utxo
                         \restrictrange (\AddrScr\times\Coin)) \\
                    & \wedge (\fun{validatorHash}~a) \mapsto s \in scripts
                      \wedge \fun{validatorHash}~a = \fun{hashScript}~s\}
  \end{align*}
  %
  \caption{Helper Functions for Transaction Inputs}
  \label{fig:defs:functions-txins}
\end{figure*}

Figure~\ref{fig:defs:functions-txins} shows the helper functions
$\fun{txinsVKey}$ and $\fun{txinsScript}$ which partition the set of transaction
inputs of the transaction into those that are locked with a private key and
those that are locked via a script. The helper function $\fun{validators}$
constructs a map from transaction inputs to scripts where for each input, the
corresponding output of the UTxO can only be spent if the script validates the
transaction.

\section{Ledger Transition for Multi-Signature}
\label{sec:ledg-trans-multi}

The main change for the ledger transitions when using script based
multi-signature is the validation of the UTXOW transition
of~\cite{shelley_formal_spec}. Its extended transition system is shown in
Figure~\ref{fig:rules:utxow-multi-sig}, in the format described
in~\cite{small_step_semantics}. The constraint on the set of required witnesses
is relaxed in such a way that ``redundant'' signatures can be supplied in the
transaction. The set of verification keys is passed to the validator script via
the concrete implementation of $\fun{validateScript}$ for the specific script
type.

The set of all validator scripts of $\fun{txinsScript}~(\fun{txins}~tx)$ is
checked for:
\begin{itemize}
\item the script hash being equal to the hash stored in the output to spent
  (done in the function $\fun{validators}$) and
\item the validator script validating the transaction.
\end{itemize}

We also check that the size of the set of spent outputs locked by a script is
equal to the elements of the inputs for which we have a validator
script. Overall that means that for each spent output we have one signature or
one validation script.

\begin{figure}[htb]
  \begin{equation*}
    \inference[UTxO-wit]
    {
      (utxo, \wcard, \wcard) \leteq \var{utxoSt}\\
      scriptWits \leteq \fun{txwitsScript}~tx\\
      scriptIns \leteq \fun{txinsScript}~(\fun{txins}~tx)~utxo\\
      \\~\\
      \forall \var{inp}\mapsto\var{validator} \in
      \fun{validators}~(\fun{txinsScript}~(\fun{txins}~tx))~utxo~scriptWits,
      \\ \fun{validateScript}~validator~(\fun{pendingTx}~tx)
      \\~\\
      scriptIns = \dom(\fun{validators}~scriptIns~utxo~scriptWits)
      \\~\\
      \forall \var{vk} \mapsto \sigma \in \txwitsVKey{tx},
      \mathcal{V}_{\var{vk}}{\serialised{\txbody{tx}}}_{\sigma} \\
      \fun{witsNeeded}~{utxo}~{tx} \subseteq \{ \hashKey \var{vk} \mid \var{vk}\in\dom{(\txwitsVKey{tx})} \}\\~\\
      {
        \begin{array}{l}
        \var{utxoEnv}
        \end{array}
      }
      \vdash \var{utxoSt} \trans{utxo}{tx} \var{utxoSt'}\\
    }
    {
      \begin{array}{l}
        \var{utxoEnv}
      \end{array}
      \vdash \var{utxoSt} \trans{utxow}{tx} \varUpdate{\var{utxoSt'}}
    }
  \end{equation*}
  \caption{UTxO with Witnesses and Multi-Sig}
  \label{fig:rules:utxow-multi-sig}
\end{figure}

\section{Implementation of Script-Based Multi-Signature}
\label{sec:altern-impl}

There are different implementation possibilities for the introduced
multi-signature scheme. Section~\ref{sec:plutus-scripts} describes an
implementation based on Plutus~\cite{plutus_eutxo} which uses only simple
scripts, without redeemer or data
scripts. Section~\ref{sec:native-script-interp} describes and alternative
implementation based on a script-like DSL that allows for validation using a
native implementation.

\subsection{Plutus Scripts}
\label{sec:plutus-scripts}

\begin{figure*}[hbt]
  \emph{Abstract Type}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      pendingTx & \PendingTx & \text{information about pending Tx}
    \end{array}
  \end{equation*}

  \emph{Abstract Functions}

  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{validateScript} & \ScriptPlutus \to \Tx \to \Bool & \text{Plutus script
                                                               interpreter} \\
      \fun{validate} & () \to () \to \PendingTx \to \Bool & \text{Plutus
                                                            validator script type}
    \end{array}
  \end{equation*}
  \caption{Implementation based on Plutus Scripts}
  \label{fig:types_defs_plutus}
\end{figure*}

$\PendingTx$ is a representation of the pending transaction. In particular, this
information contains the set of keys that signed the transaction. The function
$\fun{txPending}$ constructs the necessary information about a transaction
which can be passed as value of type $\PendingTx$ to the validator script.

In order to spend funds locked by a multi-signature script, the validator
scripts need to validate the transaction. The abstract function $\fun{validate}$
corresponds to such a Plutus validator script. Its type consists of two
parameters of unit type and one parameter of type $\PendingTx$; its return type
is Boolean. The first two input parameters correspond to the redeemer and the
data scripts which are used in the full extended UTxO model for
Plutus~\cite{plutus_eutxo}. As those values are not required for simple
multi-signature, we the unit type for them. The Boolean return type signals
whether the script succeeded in validating the transaction. The function
$\fun{validateScript}$ takes a Plutus script representation and a $\PendingTx$
value, evaluates the script and returns a Boolean result.

The following is a possible Plutus implementation of a simple $n$ out of $m$
multi-signature validation script. The type $\type{MultiSig}$ is a list of keys
and a threshold value.

\begin{verbatim}
import qualified Language.PlutusTx            as P
import           Ledger.Validation            as V

data MultiSig = MultiSig
                { signatories :: [Ledger.PubKey]
                -- ^ List of public keys of people who may sign the transaction
                , requiredSignatures :: Integer
                -- ^ Minimum number of signatures required to unlock
                --   the output (should not exceed @length signatories@)
                }

validate :: MultiSig -> () -> () -> PendingTx -> Bool
validate multiSig@(MultiSig keys num) () () p =
    let present = P.length (P.filter (V.txSignedBy p) keys)
    in present `P.geq` num
\end{verbatim}

The above Plutus script takes a parameter \var{multiSig} of type
$\type{MultiSig}$ which is a list of keys $\var{keys}$ and a threshold $num$
which indicates how many of the keys are required as signatures. When the
validation script is called, it computes the list of keys in $keys$ which signed
the transaction. If the length of that list is greater than or equal to $num$,
then enough signatures for the multi-signature are present. Therefore, with
\var{hkeys} being a value of type \type{MultiSig}, calling
$\fun{validate}~multisig$ will return a validator script with the correct type
according to Figure~\ref{fig:types_defs_plutus}.

\subsection{Native Script Interpreter}
\label{sec:native-script-interp}

An alternative implementation for multi-signature scripts is an embedding of the
script as data type which can then be interpreted natively. In the below example
code, the type $\type{MultiSigScript}$ is defined as a tree-structure
$\type{MultiSigTerm}$ that is either a single signature leaf node or a list of
$\type{MultiSigTerms}$ and a threshold.

\begin{figure*}[hbt]
  \emph{MultiSig Type}

  \begin{equation*}
    \begin{array}{rll}
      \var{msig} & \in \ScriptMSig = & \,\,\,\type{SingleSig}~\HashKey \\
       && \vert\,\,\type{MultSig}~Int~[\ScriptMSig]
    \end{array}
  \end{equation*}

  \emph{Functions}

  \begin{align*}
    \fun{validateScript} & \in\ScriptMSig\to\Tx\to\Bool & \text{validate native
                                                          script} \\
    \fun{validateScript} & \var{msig}~\var{tx}= \\
                         & \textrm{let}~\var{vhks}\leteq \{\fun{hashKey}~vk \vert
                           vk \in \fun{txwitsVKey}~\var{tx}\} \\
                         & \fun{evalMultiSigScript}~msig~vhks\\
  \end{align*}
  \begin{align*}
    \fun{evalMultiSigScript} & \in\ScriptMSig\to\powerset\HashKey\to\Bool & \\
    \fun{evalMultiSigScript} & ~\serialised{\type{SingleSig}~hk}_{hks}~\var{vhks} =  hk \in vhks \\
    \fun{evalMultiSigScript} & ~\serialised{\type{MultiSig}~m~ts}_{hks}~\var{vhks} = \\
                             & m \leq \Sigma
                               \left(
                               [\textrm{if}~(\fun{evalMultiSigScript}~\var{t}~\var{vhks})~
                               \textrm{then}~1~\textrm{else}~0\vert t \leftarrow ts]
                               \right)
  \end{align*}

  \caption{Implementation based on Native Scripts}
  \label{fig:types-msig}
\end{figure*}

The validation of such a term is done as shown in the specialization of
\fun{validateScript} for $\ScriptMSig$ as shown in Figure~\ref{fig:types-msig}.
It checks for presence of a single signature in the set of signatures of a
transaction as the base case and compares the number of validating nodes in the
list with the threshold in the recursion case. The
Appendix~\ref{sec:native-multi-sign} provides some examples of how this scheme
can be used.

\section{Summary}
\label{sec:summary}

The presented script based multi-signature scheme does not require the scripts
to use any cryptographic primitives. It requires only the ability to compare the
required keys to those that actually signed the transaction. Potential gas cost
can therefore be calculated statically in advance. The scripts can be realized
as smart contracts with only limited requirements on functionality on the script
language.

The necessary extensions to the data types in the Shelley
specification~\cite{shelley_formal_spec} are relatively simple. They consist
mainly of the introduction of additional optional data for scripts or hashed
scripts.

The relaxation on accepting a superset of the strictly required signatures
allows the creation of transactions with an arbitrary number of signatures. This
potentially is a risk for an attack. The number of signatures should be taken
into account in some way in the calculation of the transaction fee.

There are two proposed implementation schemes, one based on Plutus, the other on
a script-like integration as DSL for a native interpreter. Both follow the same
strategy for integration: extending addresses, defining witnesses and
specializing the script validation function. If the Plutus approach is not
viable for any reason, e.g., script size or readiness of library, only the
native script implementation could be pursued instead.

\addcontentsline{toc}{section}{References} \bibliographystyle{plainnat}
\bibliography{references}

\appendix

\section{Native Multi-Signature Examples}
\label{sec:native-multi-sign}

\begin{verbatim}
verifyCases :: MultiSigScript -> [(Set VKeyHash, Bool)] -> Bool
verifyCases script cases =
    and [ evalMultiSigScript script keyset == expected
        | (keyset, expected) <- cases]

mkVKeyHashSet :: [Int] -> Set VKeyHash
mkVKeyHashSet = Set.fromList . map VKeyHash

example1Of2 =
  MultiSig 1 [SingleSig (VKeyHash 1), SingleSig (VKeyHash 2)]

example1Of2_verify =
    verifyCases
      example1Of2
      [ (mkVKeyHashSet [],    False)
      , (mkVKeyHashSet [1],   True)
      , (mkVKeyHashSet [2],   True)
      , (mkVKeyHashSet [1,2], True)
      , (mkVKeyHashSet [3],   False)
      ]

example2Of2 =
  MultiSig 2 [SingleSig (VKeyHash 1), SingleSig (VKeyHash 2)]

example2Of2_verify =
    verifyCases
      example2Of2
      [ (mkVKeyHashSet [],      False)
      , (mkVKeyHashSet [1],     False)
      , (mkVKeyHashSet [2],     False)
      , (mkVKeyHashSet [1,2],   True)
      , (mkVKeyHashSet [3],     False)
      , (mkVKeyHashSet [1,2,3], True)
      ]

exampleNestedOrAnd =
  MultiSig 1 [ MultiSig 2 [SingleSig (VKeyHash 1), SingleSig (VKeyHash 2)]
             , MultiSig 2 [SingleSig (VKeyHash 3), SingleSig (VKeyHash 4)]
             ]

exampleNestedAndOr =
  MultiSig 2 [ MultiSig 1 [SingleSig (VKeyHash 1), SingleSig (VKeyHash 2)]
             , MultiSig 1 [SingleSig (VKeyHash 3), SingleSig (VKeyHash 4)]
             ]

exampleNestedOrAnd_verify =
    verifyCases
      exampleNestedOrAnd
      [ (keysset, expected)
      | has1 <- [False, True]
      , has2 <- [False, True]
      , has3 <- [False, True]
      , has4 <- [False, True]
      , has5 <- [False, True]
      , let keysset = mkVKeyHashSet $ [ 1 | has1 ]
                                   ++ [ 2 | has2 ]
                                   ++ [ 3 | has3 ]
                                   ++ [ 4 | has4 ]
                                   ++ [ 5 | has5 ]
            expected = (has1 && has2)
                    || (has3 && has4)
      ]

exampleNestedAndOr_verify =
    verifyCases
      exampleNestedAndOr
      [ (keysset, expected)
      | has1 <- [False, True]
      , has2 <- [False, True]
      , has3 <- [False, True]
      , has4 <- [False, True]
      , has5 <- [False, True]
      , let keysset = mkVKeyHashSet $ [ 1 | has1 ]
                                   ++ [ 2 | has2 ]
                                   ++ [ 3 | has3 ]
                                   ++ [ 4 | has4 ]
                                   ++ [ 5 | has5 ]
            expected = (has1 || has2)
                    && (has3 || has4)
      ]
\end{verbatim}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
