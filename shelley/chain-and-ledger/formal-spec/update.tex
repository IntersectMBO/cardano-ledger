\section{Update Proposal Mechanism}
\label{sec:update}


The $\mathsf{UPDATE}$ transition is responsible for the federated governance model in Shelley.
The governance process includes a mechanism for core nodes to propose and vote on
updates. In this chapter we
outline rules for genesis keys \textit{proposing} both protocol parameter
and application version updates, as well as voting on whether a particular
software update is an acceptable future option (again, only genesis keys vote on this).
For rules regarding the \textit{adoption} of protocol
parameter updates, see \ref{sec:pparam-update}. For rules regarding
adoption of new software versions see \ref{sec:software-updates}.

\underline{Distinction between protocol parameter and application updates.}
\begin{itemize}
\item \textbf{Protocol parameters} (excluding $\ProtVer$, explained below): constants
currently used in ledger calculations according to the rules described in this document
\begin{itemize}
\item[$\circ$] Stored on the leger
\item[$\circ$] Changed only at epoch boundary
\item[$\circ$] Changed according to the genesis key votes, which are also stored on the ledger
\item[$\circ$] All nodes automatically adopt new values (this mechanism is an explicit
 part of the ledger rules, and is included in the epoch boundary transition)
\item[$\circ$] Has no effect on ledger transition rules
\end{itemize}
\item \textbf{Protocol version} ($\ProtVer$): a special value in PP's which
corresponds to a specific version of the \textit{ledger rules}
\begin{itemize}
\item[$\circ$] I.e. if $\var{pv}$ changes, this document should be updated with
the new rules
\item[$\circ$] E.g. the change may be that the new rules now allow \textit{all} nodes
to vote on update proposals
\item[$\circ$] Adoption mechanism is the same as PP's (which this value is included it),
so the new rules come into effect at an epoch boundary
\item[$\circ$] Because a new set of transition rules must now be followed, nodes must have
software installed that can implement these rules at the epoch boundary
when the PP adoption occurs
\item[$\circ$] Switching to using these new rules is mandatory in the sense that
if the nodes do not have the applications implementing them, this
may prevent a user from reading and
writing to the blockchain, e.g changing the
transaction data structure would cause such a problem
\end{itemize}
\item \textbf{Applications} The version of the software the nodes run,
as well as the related system tags and metadata
\begin{itemize}
\item[$\circ$] These updates cannot be forced
\item[$\circ$] Any application version that is capable of implementing the protocol version
currently on the ledger can be used by a node
\item[$\circ$] Users can update applications as soon as update is agreed upon, and should
do so before their current application becomes incompatible with the
current protocol version (due to an update)
\end{itemize}
\end{itemize}

Applications must sometimes support \textit{several different versions}
of ledger rules in order to accommodate the timely switch of the $\ProtVer$ at the
epoch boundary. Usually, the currently accepted protocol version, and next the
version they are ready to upgrade to (that their application versions can
implement).
The protocol version a node is ready to upgrade to is actually part of the block
header of a block it makes, see \ref{sec:defs-blocks}.

So, users have some agency in the process of adoption of
new protocol versions. They may refuse to download and install updates.
Since software updates cannot be \textit{forced} on the users, if the majority of
users do not perform an update which allows to switch to the next $\ProtVer$,
it cannot happen.

There is no data in the transaction that says what application
versions a user has, or what protocol version they are using (this always has to
be the version recorded on the ledger).
Having the wrong version of an application
may potentially become problematic (when it is not able to follow the current
ledger rules dictated by $\ProtVer$), however, the update mechanism should
ensure this does not happen often.

This chapter does not discuss authentication of update proposals.
The signature for the keys in the proposal will be checked in the
$\mathsf{UTXOW}$ transition, which checks all the necessary witnesses
for a transaction, see \ref{sec:witnesses-shelley}.

\begin{note}
\underline{Genesis Key Delegations}
\newline
\noindent The environment for both PP and AV updates contains
the value $\var{dms}$, which is a finite map indexed by genesis keys.
This is the genesis key delegations. During the Byron era, they are expected
to all have delegated to some $\VKey$, and these delegations are inherited
through the Byron-Shelley transition (see \ref{sec:byron-to-shelley}).
These delegations can be updated as described in \ref{sec:delegation-shelley},
but those genesis keys that do not delegate to anything are not able to vote,
since the rules below only count the votes of delegated keys.
\end{note}

Because the PP and application update mechanisms are very different, the
update proposals for these are handled by separate sets of rules.

\section{PP Update Proposals}
\label{sec:pp-proposals}

The transition type $\mathsf{PPUP}$ is for proposing updates to protocol
parameters, see Figure \ref{fig:ts-types:pp-update} (for the corresponding rules,
see Figure \ref{fig:rules:pp-update}).
The signal for this transition is a finite map of proposed updates (indexed by
genesis keys).

\begin{itemize}
  \item PP-Update-Empty : no new updates were proposed, do nothing
  \item PP-Update-Nonempty : some new updates $\var{pup}$ were proposed
  Add these to
  the existing proposals using a right override. That is, if a genesis key
  has previously submitted an update proposal, replace it with its new
  proposal in $\var{pup}$. This rule has the following predicate failures:

  \begin{enumerate}
  \item In the case of \var{slot} being smaller than
    $\fun{firstSlot}~((\fun{epoch}~\var{slot}) + 1) - \fun{SlotsPrior}$, there is
    a \em{PPUpdateTooEarly} failure.
  \item In the case of \var{pup} being non-empty, if the check $\dom pup \subseteq
    \dom dms$ fails, there is a \em{NonGenesisUpdate} failure as only genesis keys
    can be used in the protocol parameter update.
  \item If a protocol parameter update in \var{pup} cannot follow the current
    protocol paramter, there is a \em{PVCannotFollow} failure.
  \end{enumerate}
\end{itemize}

Note that $\fun{pvCanFollow}$
was defined in \cite{byron_ledger_spec}. Note also that the constant $\SlotsPrior$
is used in defining the blockchain layer functionality,
and is explained in detail in the paper \cite{ouroboros_praos}. It is used in this document in
Section \ref{sec:chain}.


\begin{figure}[htb]
  \emph{Protocol Parameter Update environment}
  \begin{equation*}
    \PPUpdateEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{slot} & \Slot & \text{current slot}\\
        \var{dms} & \VKeyGen\mapsto\VKey & \text{genesis key delegations} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Protocol Parameter Update transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{ppup}{\_} \var{\_}
    \subseteq \powerset (\PPUpdateEnv \times \PPUpdate \times \PPUpdate \times \PPUpdate)
  \end{equation*}
  %
  \caption{Protocol Parameter Update Transition System Types}
  \label{fig:ts-types:pp-update}
\end{figure}

\begin{figure}[htb]
  \begin{equation}\label{eq:pp-update-Empty}
    \inference[PP-Update-Empty]
    {
      \var{pup} = \emptyset
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{dms}\\
      \end{array}
      \vdash \var{pup_s}\trans{ppup}{pup}\var{pup_s}
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:update-nonempty}
    \inference[PP-Update-Nonempty]
    {
      \var{pup}\neq\emptyset
      &
      \dom{pup}\subseteq\dom{dms}
      \\
      \var{ppv}\mapsto\var{v}\in\var{pup}\implies\fun{pvCanFollow}~(\fun{ppv}~\var{pup_s})~\var{v}
      \\
      \var{slot} < \firstSlot{((\epoch{slot}) + 1) - \SlotsPrior}
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{dms}\\
      \end{array}
      \vdash
      \var{pup_s}
      \trans{ppup}{pup}
      \varUpdate{pup_s\unionoverrideRight pup}
    }
  \end{equation}

  \caption{Protocol Parameter Update Inference Rules}
  \label{fig:rules:pp-update}
\end{figure}

\clearpage

Figure~\ref{fig:funcs:helper-updates} gives some helper functions for the
application version update transition.
The function $\fun{votedValue_T}$ returns
the consensus value of update proposals in the event that at least five
genesis keys agree. Note that this is greater than majority (there are seven
core nodes), so there can
be \text{at most one value} with five or more votes.
This function will also be used for the protocol parameters later in Section~\ref{sec:epoch}.
Note that $\type{T}$ is an arbitrary type. The specific choice of this type
determines what is being voted on, e.g. the application version.
Recall here that $\type{T}^?$ is the option type, see \ref{sec:notation-shelley},
and a term of this type can have a value of type $\type{T}$ or no value.

The function $\fun{validAV}$ uses three functions from \cite{byron_ledger_spec}, namely
$\fun{apNameValid}$, $\fun{svCanFollow}$, and $\fun{sTagValid}$. It determines
whether an application version is valid, given its name, version number,
metadata, and a set of applications to compare against.
The function $\fun{newAVs}$ adds the most recent valid application
versions to a finite map of applications using right override.
This helper function will be used in the ledger update.

%%
%% Figure - Helper Function for Consensus of Update Proposals
%%
\begin{figure}[htb]
  \begin{align*}
      & \fun{votedValue_T} \in (\VKeyGen\mapsto\type{T}) \to \type{T}^?\\
      & \fun{votedValue_T}~\var{vs} =
        \begin{cases}
          t & \exists t\in\range{vs}~(|vs\restrictrange t|\geq 5) \\
          \Nothing & \text{otherwise} \\
        \end{cases}
  \end{align*}

  \begin{align*}
      & \fun{validAV} \in \ApName \to \ApVer \to \Metadata \to \Applications \to \Bool\\
      & \fun{validAV}~\var{an}~\var{av}~\var{md}~\var{avs} = \\
      & ~~~~\fun{apNameValid}~\var{an}
        ~\land~\fun{svCanFollow}~\var{avs}~(\var{an},~\var{av})
        ~\land~\forall\var{st}\in\dom{md},~\fun{sTagValid}~\var{st}
  \end{align*}

  \begin{align*}
      & \fun{newAVs} \in \Applications \to (\Slot\mapsto\Applications) \to \Applications \\
      & \fun{newAVs}~\var{avs}~\var{favs} =
        \begin{cases}
          \var{avs}\unionoverrideRight\var{avs}'
                     & \var{favs}\neq\emptyset \\
                     & ~\land~s_m\mapsto\var{avs'}\in\var{favs} \\
                     & ~\land~s_m=\max(\dom{\var{favs}}) \\
                     & ~\land~\forall(an\mapsto(av, mdt)\in\var{avs}'),
                         ~\fun{validAV}~\var{an}~\var{av}~\var{md}~\var{avs}
          \\
          \var{avs} & \text{otherwise}
        \end{cases}
  \end{align*}

  \caption{Epoch Helper Functions}
  \label{fig:funcs:helper-updates}
\end{figure}

\section{Application Update Proposals}
\label{sec:app-proposals}

The application (or software) version update is defined by the $\mathsf{AVUP}$
transition type (see Figure \ref{fig:ts-types:av-update}), and the rules in
Figure \ref{fig:rules:av-update}.
The state contains a finite map of update proposals
$\var{aup} \in \AVUpdate$ ($= \VKeyGen \mapsto \Applications$) that the genesis keys have
made previously.
The \textit{voting} and \textit{proposing an AV update} is done through the same
mechanism - the $\var{aup}$ signal carried by a transaction. The difference
is that a proposal is not in the
range of the $\var{aup}$, but a vote is for an existing proposal
in $\var{aup}$.

Recall here that a single AV update proposal can be
proposing changes to multiple parts of the Cardano system software simultaneously.
This is why it is stored as the finite map $\Applications$, associating the
specific bit of software (referred to by name) with the proposed version.
A proposal for several versions of the same application cannot be made in
a single transaction by the same genesis key.

Now, the state variable $\var{favs}$ contains update proposals that
were voted on by at least five genesis keys in a given slot.
At most one
can be selected for a given slot, and some slots do not have any
updates selected by voting - either because none were proposed, or the vote
did not reach a concensus. Finally, the $\var{avs}$ variable stores
the versions of the software that are currently in use. The update
proposal rules are as follows:

\begin{itemize}
  \item AV-Update-Empty: rule represents an update with
and empty set of AV proposals, when nothing happens.
  \item AV-Update-No-Consensus: rule
is for the case where a voting consensus was not reached on a proposed software
update after combining the set of new (signal) and existing (state) proposals
by a right override. In this case, we simply use this combined new value
of update proposal (votes) as the state UP value.
  \item AV-Update-Consensus: applies when voting on update proposals by genesis keys
reaches consensus. In this case, the proposal which was voted on in this slot
is considered an update upcoming in the future, and is stored associated
with a slot which is $\SlotsPrior$ in the future, to be implemented at that time.
All other update proposals are scrapped.
\end{itemize}

The AVUP rule has one predicate failure:
\begin{itemize}
\item In the case of \var{aup} being non-empty, if the check $\dom aup \subseteq
  \dom dms$ fails, there is a \em{NonGenesisUpdate} failure as only genesis keys
  can be used in the application version update.
\end{itemize}

\begin{figure}[htb]
  \emph{Application Version Update environment}
  \begin{equation*}
    \AVUpdateEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{slot} & \Slot & \text{current slot}\\
        \var{dms} & \VKeyGen\mapsto\VKey & \text{genesis key delegations} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Application Version Update states}
  \begin{equation*}
    \AVUpdateState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{aup} & \AVUpdate & \text{application versions proposals} \\
        \var{favs} & \Slot\mapsto\Applications & \text{future application versions} \\
        \var{avs} & \Applications & \text{current application versions} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Application Version Update transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{avup}{\_} \var{\_}
    \subseteq \powerset (\AVUpdateEnv \times \AVUpdateState \times \AVUpdate \times \AVUpdateState)
  \end{equation*}
  %
  \caption{Application Version Update transition-system types}
  \label{fig:ts-types:av-update}
\end{figure}

\begin{figure}[htb]
  \begin{equation}\label{eq:av-update-Empty}
    \inference[AV-Update-Empty]
    {
      \var{aup} = \emptyset
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{dms}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{l}
        \var{aup_s}\\
        \var{favs}\\
        \var{avs}\\
      \end{array}
      \right)
      \trans{avup}{aup}
      \left(
      \begin{array}{l}
        \var{aup_s}\\
        \var{favs}\\
        \var{avs}\\
      \end{array}
      \right)
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:update-no-consensus}
    \inference[AV-Update-No-Consensus]
    {
      \var{aup}\neq\emptyset
      &
      \dom{\var{aup}}\subseteq\dom{\var{dms}}
      \\
      \var{aup'}\leteq\var{aup_s}\unionoverrideRight\var{aup}
      &
      \var{fav}\leteq\fun{votedValue_{Applications}}~\var{aup'}
      \\
      \var{fav}=\Nothing
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{dms}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{l}
        \var{aup_s}\\
        \var{favs}\\
        \var{avs}\\
      \end{array}
      \right)
      \trans{avup}{aup}
      \left(
      \begin{array}{l}
        \varUpdate{\var{aup'}}\\
        \var{favs}\\
        \var{avs}\\
      \end{array}
      \right)
    }
  \end{equation}

  \nextdef

  \begin{equation}\label{eq:update-consensus}
    \inference[AV-Update-Consensus]
    {
      \var{aup}\neq\emptyset
      &
      \dom{\var{aup}}\subseteq\dom{\var{dms}}
      \\
      \var{aup'}\leteq\var{aup_s}\unionoverrideRight\var{aup}
      &
      \var{fav}\leteq\fun{votedValue_{Applications}}~\var{aup'}
      \\
      \var{fav}\neq\Nothing
      &
      s\leteq\var{slot}+\SlotsPrior
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{dms}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{l}
        \var{aup_s}\\
        \var{favs}\\
        \var{avs}\\
      \end{array}
      \right)
      \trans{avup}{aup}
      \left(
      \begin{array}{l}
        \varUpdate{\emptyset}\\
        \varUpdate{\var{favs}\unionoverrideRight\{\var{s}\mapsto\var{fav}\}}\\
        \var{avs}\\
      \end{array}
      \right)
    }
  \end{equation}

  \caption{Application Version Update inference rules}
  \label{fig:rules:av-update}
\end{figure}

\clearpage

The $\mathsf{UP}$ transition type combines processing update
proposals for protocol parameters and applications. The signal for this
transition is a pair of update proposals for parameters and applications,
and each of these is a signal for updating the corresponding data structure.
Both get updated simultaneously by this rule according to a relevant
update rules for each.

\begin{figure}[htb]
  \emph{Update environment}
  \begin{equation*}
    \UpdateEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{slot} & \Slot & \text{current slot}\\
        \var{dms} & \VKeyGen\mapsto\VKey & \text{genesis key delegations} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Update states}
  \begin{equation*}
    \UpdateState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pup} & \PPUpdate & \text{protocol parameter proposals} \\
        \var{aup} & \AVUpdate & \text{application versions proposals} \\
        \var{favs} & \Slot\mapsto\Applications & \text{future application versions} \\
        \var{avs} & \Applications & \text{current application versions} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Update transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{up}{\_} \var{\_}
    \subseteq \powerset (\UpdateEnv \times \UpdateState \times \Update \times \UpdateState)
  \end{equation*}
  %
  \caption{Application Version Update transition-system types}
  \label{fig:ts-types:update}
\end{figure}

\begin{figure}[htb]
  \begin{equation}\label{eq:update}
    \inference[Update]
    {
      (\var{pup_{u}},~\var{aup_{u}})\leteq\var{up}
      \\~\\
      {
        \left(
          \begin{array}{r}
            \var{slot} \\
            \var{dms} \\
          \end{array}
        \right)
      }
      \vdash
      \left(\var{pup}\right)
      \trans{\hyperref[fig:rules:pp-update]{ppup}}{\var{pup_{u}}}
      \left(\var{pup'}\right)
      &
      {
        \left(
          \begin{array}{r}
            \var{slot} \\
            \var{dms} \\
          \end{array}
        \right)
      }
      \vdash
      {
        \left(
          \begin{array}{r}
            \var{aup}\\
            \var{favs}\\
            \var{avs}\\
          \end{array}
        \right)
      }
      \trans{\hyperref[fig:rules:av-update]{avup}}{\var{aup_{u}}}
      {
        \left(
          \begin{array}{r}
            \var{aup'}\\
            \var{favs'}\\
            \var{avs'}\\
          \end{array}
        \right)
      }
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{dms}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{l}
        \var{pup}\\
        \var{aup}\\
        \var{favs}\\
        \var{avs}\\
      \end{array}
      \right)
      \trans{up}{up}
      \left(
      \begin{array}{l}
        \varUpdate{\var{pup}'} \\
        \varUpdate{\var{aup}'} \\
        \varUpdate{\var{favs}'} \\
        \varUpdate{\var{avs}'} \\
      \end{array}
      \right)
    }
  \end{equation}

  \caption{Update inference rules}
  \label{fig:rules:update}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
