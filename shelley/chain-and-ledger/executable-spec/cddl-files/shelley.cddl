; Shelley Types

block =
  [ header
  , transaction_bodies         : [* transaction_body]
  , transaction_witness_sets   : [* transaction_witness_set]
  , transaction_metadata_set   :
      { * transaction_index => transaction_metadata }
  ]; Valid blocks must also satisfy the following two constraints:
   ; 1) the length of transaction_bodies and transaction_witness_sets
   ;    must be the same
   ; 2) every transaction_index must be strictly smaller than the
   ;    length of transaction_bodies

transaction =
  [ transaction_body
  , transaction_witness_set
  , transaction_metadata / null
  ]

transaction_index = uint

header =
  [ header_body
  , body_signature : $kes_signature
  ]

header_body =
  [ block_number     : uint
  , slot             : uint
  , prev_hash        : $hash32 / null
  , issuer_vkey      : $vkey
  , vrf_vkey         : $vrf_vkey
  , nonce_vrf        : $vrf_cert
  , leader_vrf       : $vrf_cert
  , block_body_size  : uint
  , block_body_hash  : $hash32 ; merkle triple root
  , operational_cert
  , protocol_version
  ]

operational_cert =
  ( hot_vkey        : $kes_vkey
  , sequence_number : uint
  , kes_period      : uint
  , sigma           : $signature
  )

protocol_version = (uint, uint)

transaction_body =
  { 0 : set<transaction_input>
  , 1 : [* transaction_output]
  , 2 : coin ; fee
  , 3 : uint ; ttl
  , ? 4 : [* certificate]
  , ? 5 : withdrawals
  , ? 6 : update
  , ? 7 : metadata_hash
  }

transaction_input = [ transaction_id : $hash32
                    , index : uint
                    ]

transaction_output = [address, amount : uint]

address =
 (  0, addr_keyhash, addr_keyhash ; base address
 // 1, addr_keyhash, scripthash   ; base address
 // 2, scripthash, addr_keyhash   ; base address
 // 3, scripthash, scripthash     ; base address
 // 4, addr_keyhash, pointer      ; pointer address
 // 5, scripthash, pointer        ; pointer address
 // 6, addr_keyhash               ; enterprise address
 // 7, scripthash                 ; enterprise address
 // 8, addr_keyhash               ; bootstrap address
 )
pointer = (uint, uint, uint)

certificate =
  [  0, stake_credential                   ; stake registration
  // 1, stake_credential                   ; stake deregistration
  // 2, stake_credential, pool_keyhash     ; stake delegation
  // 3, pool_params                        ; pool registration
  // 4, pool_keyhash, epoch                ; pool retirement
  // 5, genesishash, genesis_delegate_hash ; genesis key delegation
  // 6, move_instantaneous_reward          ; move inst. rewards
  ]

move_instantaneous_reward = { * stake_credential => coin }

stake_credential =
  [  0, addr_keyhash
  // 1, scripthash
  ]

pool_params = ( operator:       pool_keyhash
              , vrf_keyhash:    vrf_keyhash
              , pledge:         coin
              , cost:           coin
              , margin:         unit_interval
              , reward_account: stake_credential
              , pool_owners:    set<addr_keyhash>
              , relays:         [* relay]
              , pool_metadata:  pool_metadata / null
              )

port = uint .le 65535
ipv4 = bytes .size 4
ipv6 = bytes .size 16
dns_name = tstr .size (0..64)

single_host_addr = ( 0
                   , port / null
                   , ipv4 / null
                   , ipv6 / null
                   )
single_host_name = ( 1
                   , port / null
                   , dns_name ; An A or AAAA DNS record
                   )
multi_host_name = ( 2
                   , port / null
                   , dns_name ; A SRV DNS record
                   )
relay =
  [  single_host_addr
  // single_host_name
  // multi_host_name
  ]

pool_metadata = [url, metadata_hash]
url = tstr .size (0..64)

withdrawals = { * stake_credential => coin }

update = [ proposed_protocol_parameter_updates
         , epoch
         ]

proposed_protocol_parameter_updates =
  { * genesishash => protocol_param_update }

protocol_param_update =
  { ? 0:  uint               ; minfee A
  , ? 1:  uint               ; minfee B
  , ? 2:  uint               ; max block body size
  , ? 3:  uint               ; max transaction size
  , ? 4:  uint               ; max block header size
  , ? 5:  coin               ; key deposit
  , ? 6:  unit_interval      ; key deposit min refund
  , ? 7:  rational           ; key deposit decay rate
  , ? 8:  coin               ; pool deposit
  , ? 9:  unit_interval      ; pool deposit min refund
  , ? 10: rational           ; pool deposit decay rate
  , ? 11: epoch              ; maximum epoch
  , ? 12: uint               ; n_opt: desired number of stake pools
  , ? 13: rational           ; pool pledge influence
  , ? 14: unit_interval      ; expansion rate
  , ? 15: unit_interval      ; treasury growth rate
  , ? 16: unit_interval      ; d. decentralization constant
  , ? 17: $nonce             ; extra entropy
  , ? 18: [protocol_version] ; protocol version
  }

transaction_witness_set =
  { ?0 => [* vkeywitness ]
  , ?1 => [* multisig_script ]
  ; In the future, new kinds of witnesses can be added like this:
  ; , ?2 => [* monetary_policy_script ]
  ; , ?3 => [* plutus_script ]
  }

transaction_metadatum =
    { * transaction_metadatum => transaction_metadatum }
  / [ * transaction_metadatum ]
  / int
  / bytes .size 64
  / text .size 64

transaction_metadadum_label = uint

transaction_metadata =
  { * transaction_metadadum_label => transaction_metadatum }


vkeywitness = [ $vkey, $signature ]

multisig_script =
  [  0, addr_keyhash                 ; public key
  // 1, [ * multisig_script ]        ; all of
  // 2, [ * multisig_script ]        ; any of
  // 3, uint, [ * multisig_script ]  ; n of k
  ]

coin = uint
epoch = uint

addr_keyhash = $hash28
scripthash   = $hash28

genesis_delegate_hash = $hash32
pool_keyhash          = $hash32
genesishash           = $hash32
metadata_hash         = $hash32
vrf_keyhash           = $hash32
